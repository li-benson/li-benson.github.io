<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文为准备面试时遇到的数据库知识">
<meta property="og:type" content="article">
<meta property="og:title" content="interview-database">
<meta property="og:url" content="http://example.com/2022/03/19/interview-database/index.html">
<meta property="og:site_name" content="Benson&#39;s Blog">
<meta property="og:description" content="本文为准备面试时遇到的数据库知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/2NF.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/3NF.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/Phantom_read.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/lock.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/ILock.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/next_lock.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/dead_lock.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/undo_log.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mvcc_example.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mvcc_rc.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mvcc_rr.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/join.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mysql_index.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/prefix_index.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/explain.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/leftIndex.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mysql_syc.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/horizontal_sharding.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/vertical_sharding.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/redis_dict.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/skip_list.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/redis_eliminating.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/save.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/bgsave.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/auto.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/redis_sync.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/multi1.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/multi2.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/multi3.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/multi4.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/multi5.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/file_event.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/time_event.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/master_slave.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/sentinel.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/level.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/cluster.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/cluster_add.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mongodb.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mongodb_example.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mongodb_type.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mongodb_objectID.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mongodb_sync.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/mongodb_shard.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/row.png">
<meta property="og:image" content="http://example.com/2022/03/19/interview-database/col.png">
<meta property="article:published_time" content="2022-03-19T09:28:18.000Z">
<meta property="article:modified_time" content="2022-04-11T11:42:20.268Z">
<meta property="article:author" content="Benson">
<meta property="article:tag" content="Interview">
<meta property="article:tag" content="Database">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/19/interview-database/2NF.png">

<link rel="canonical" href="http://example.com/2022/03/19/interview-database/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>interview-database | Benson's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Benson's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-study">

    <a href="/study/" rel="section"><i class="fa fa-archive fa-fw"></i>学习</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    

  <a href="https://github.com/li-benson" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/19/interview-database/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Benson">
      <meta itemprop="description" content="学习、记录、成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Benson's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          interview-database
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-19 17:28:18" itemprop="dateCreated datePublished" datetime="2022-03-19T17:28:18+08:00">2022-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-11 19:42:20" itemprop="dateModified" datetime="2022-04-11T19:42:20+08:00">2022-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview-Knowledge/" itemprop="url" rel="index"><span itemprop="name">Interview Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>16 分钟</span>
            </span>
            <div class="post-description">本文为准备面试时遇到的数据库知识</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h1><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h3><ul>
<li>关系型数据库<br>  是指采用了关系模型来组织数据的数据库，简单来说，关系模式就是二维表格模型。关系型数据库的最大优点就是事务的一致性，这个特性，使得关系型数据库中可以适用于一切要求一致性比较高的系统中。</li>
<li>非关系型数据库<br>  指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统</li>
</ul>
<h3 id="函数依赖和三范式"><a href="#函数依赖和三范式" class="headerlink" title="函数依赖和三范式"></a>函数依赖和三范式</h3><ul>
<li><p>函数依赖</p>
<ul>
<li>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</li>
<li>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</li>
<li>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖</li>
</ul>
</li>
<li><p>三范式</p>
<ul>
<li><p>第一范式<br>每个属性（表的一列）都不可再分，比如某个字段是json数据，就不符合第一范式。</p>
</li>
<li><p>第二范式<br>在1NF的基础上，非主属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）举例如下：虽然成绩完全依赖于学号和课程号，但是姓名部分函数依赖于（学号+课程号），即只需要学号即可确定姓名。</p>
<p><img src="/2022/03/19/interview-database/2NF.png" alt="image"></p>
</li>
<li><p>第三范式<br>在2NF基础上消除传递依赖。比如，课程号-&gt;授课老师-&gt;教师姓名，所以教师姓名传递依赖课程号。</p>
<p><img src="/2022/03/19/interview-database/3NF.png" alt="image"></p>
</li>
</ul>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务的ACID特性"><a href="#什么是事务的ACID特性" class="headerlink" title="什么是事务的ACID特性"></a>什么是事务的ACID特性</h3><p>略</p>
<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><ul>
<li><p>丢失修改</p>
</li>
<li><p>脏读</p>
</li>
<li><p>不可重复读</p>
</li>
<li><p>幻读</p>
<ul>
<li><p>概念</p>
<p>是指在同一个事务中，前后两次查询相同范围时，得到的结果不一致，后一次查询到新插入的行。</p>
<p><img src="/2022/03/19/interview-database/Phantom_read.png" alt="image"></p>
<p>对于 <code>select * from t where d=5 for update;</code> 来说，锁住d&#x3D;5对应的行或者锁住扫描过程中所有的行都是没有用的, 因为插入并不影响之前行的操作，所以 InnoDB 为了解决幻读，引入了新的锁 - 间隙锁。</p>
<p>当再执行select * from t where d&#x3D;5 for update;时，不但会将全表的数据行锁住，还会将间隙锁住。由于间隙锁解决的是幻读插入的问题，所以间隙锁仅仅对插入操作本身互斥，不同事务之间的间隙锁并不互斥。</p>
</li>
<li><p>缺点</p>
<p>间隙锁的引入导致同样的语句锁住更大的范围，降低了并发度。</p>
</li>
</ul>
</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="数据库锁的类型有哪些？"><a href="#数据库锁的类型有哪些？" class="headerlink" title="数据库锁的类型有哪些？"></a>数据库锁的类型有哪些？</h3><ul>
<li><p>共享锁：允许事务对一条行数据进行读取，其他事务只能加读锁，即并行读。</p>
</li>
<li><p>排他锁：允许事务对一条行数据进行删除或更新，其他事务不能加任何锁，即无法读和写.</p>
<p>共享锁之间是兼容的，而互斥锁与其他任意锁都不兼容，因为可以并行读，但是只能串行写。</p>
<p><img src="/2022/03/19/interview-database/lock.png" alt="image"></p>
</li>
</ul>
<h3 id="乐观锁和悲观锁的区别，以及各自的使用场景"><a href="#乐观锁和悲观锁的区别，以及各自的使用场景" class="headerlink" title="乐观锁和悲观锁的区别，以及各自的使用场景"></a>乐观锁和悲观锁的区别，以及各自的使用场景</h3><ul>
<li><p>悲观锁</p>
<p>  总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p>
<p>  多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
</li>
<li><p>乐观锁</p>
<ul>
<li><p>理解</p>
<p>  总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。</p>
</li>
<li><p>场景</p>
<p>  乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>
</li>
<li><p>乐观锁常见的两种实现方式：</p>
<ul>
<li><p>版本号机制</p>
<p>  一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>  假设数据库中账户信息表中有一个 version 字段，当前值为 1 ；而当前账户余额字段（ balance ）为 $100 。</p>
<ol>
<li>操作员 A 此时将其读出（ version&#x3D;1 ），并从其账户余额中扣除 $50（ $100-$50 ）。</li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version&#x3D;1 ），并从其账户余额中扣除 $20 （ $100-$20 ）。</li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version&#x3D;2 ），连同帐户扣除后余额（ balance&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。</li>
<li>操作员 B 完成了操作，也将版本号加一（ version&#x3D;2 ）试图向数据库提交数据（ balance&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。<br>  这样，就避免了操作员 B 用基于 version&#x3D;1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</li>
</ol>
</li>
<li><p>CAS</p>
<p>  compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>
<ul>
<li><p>需要读写的内存值 V</p>
</li>
<li><p>进行比较的值 A</p>
</li>
<li><p>拟写入的新值 B</p>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>乐观锁的缺点：</p>
<ul>
<li><p>ABA问题</p>
<p>  如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的  ABA 问题。</p>
</li>
<li><p>循环时间大</p>
<p>  自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</p>
</li>
<li><p>只能保证一个共享变量的原子操作</p>
<p>  CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><ul>
<li><p>行锁：例如，共享锁和排他锁</p>
</li>
<li><p>表锁：例如，意向锁</p>
<p>  意向锁分为两种：</p>
<ul>
<li><p>意向共享锁：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁；</p>
</li>
<li><p>意向互斥锁：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁；</p>
<p>为什么需要意向锁？</p>
<p>如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。</p>
<p><img src="/2022/03/19/interview-database/ILock.png" alt="image"></p>
</li>
</ul>
</li>
</ul>
<h3 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h3><ul>
<li><p>Record Lock</p>
<p>  例如：<code>SELECT * FROM users WHERE id = 1</code> 时，如果id为主键，则会锁住对应的记录，否则全变扫描时会锁住整个表。</p>
</li>
<li><p>Gap Lock</p>
<p>  间隙锁是对索引记录中的一段连续区域的锁。当使用类似 <code>SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE;</code> 的 SQL 语句时，就会阻止其他事务向表中插入 id &#x3D; 15 的记录，因为整个范围都被间隙锁锁定了。</p>
</li>
<li><p>Next-Key Lock</p>
<p>  Next-Key 锁相比前两者就稍微有一些复杂，它是记录锁和记录前的间隙锁的结合。</p>
<p>  <img src="/2022/03/19/interview-database/next_lock.png" alt="image"></p>
<p>  当我们更新一条记录，比如 <code>SELECT * FROM users WHERE age = 30 FOR UPDATE;</code>，InnoDB 不仅会在范围 (21, 30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30, 40] 加间隙锁，所以插入 (21, 40] 范围内的记录都会被锁定。</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>  InnoDB 中实现的锁是悲观的，那么不同事务之间就可能会互相等待对方释放锁造成死锁，最终导致事务发生错误；<br>  <img src="/2022/03/19/interview-database/dead_lock.png" alt="image"></p>
<h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><p>  运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放</p>
<ul>
<li><p>三级封锁协议</p>
<ul>
<li><p>一级封锁协议</p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。它不能保证可重复读和不读“脏”数据。</p>
</li>
<li><p>二级封锁协议</p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。还可以进一步防止读“脏”数据</p>
</li>
<li><p>三级封锁协议</p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题</p>
</li>
</ul>
</li>
<li><p>两段锁协议</p>
<p>所有的事务必须分两个阶段对数据项加锁和解锁。</p>
<p>可以证明：若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。</p>
<p>可串行化：多个事务的并发执行是正确的，当且仅当其结果与某一次序串行地执行它们时的结果相同，称这种调度策略是可串行化调度。</p>
<p>两阶段锁的使用却引入了另一个严重的问题，死锁；不同的事务等待对方已经锁定的资源就会造成死锁</p>
</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><ul>
<li><p>未提交读</p>
<p>  事务中的修改，即使没有提交，对其它事务也是可见的。</p>
</li>
<li><p>提交读</p>
<p>  一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
</li>
<li><p>可重复读</p>
<p>  保证在同一个事务中多次读取同样数据的结果是一样的。</p>
</li>
<li><p>可串行化</p>
<p>  强制事务串行执行。</p>
</li>
</ul>
<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>常见的三种并发控制机制：分别是悲观并发控制、乐观并发控制和多版本并发控制，其中悲观并发控制其实是最常见的并发控制机制，也就是锁；而乐观并发控制其实也有另一个名字：乐观锁，乐观锁其实并不是一种真实存在的锁。</p>
<p>MVCC是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p>同一行数据平时发生读写请求时，会上锁阻塞住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。</p>
<p>当前读是指读取的是最新的数据，需要加锁。</p>
<p>快照读是指使用 MVCC 读取历史快照中的数据，不需要加锁，提升性能。</p>
<p>具体原理：</p>
<ul>
<li><p>事务版本号：每次事务开启前都会从数据库获得一个自增长的事务ID</p>
</li>
<li><p>数据库记录隐藏的列：</p>
<p>  <code>DB_TRX_ID</code>: 记录操作该数据事务的事务ID；</p>
<p>  <code>DB_ROLL_PTR</code>：指向上一个版本数据在undo log 里的位置指针；</p>
</li>
<li><p>undo log：当事务进行回滚需要用到</p>
<p>  <img src="/2022/03/19/interview-database/undo_log.png" alt="image"></p>
</li>
<li><p>ReadView</p>
<p>  <code>trx_ids</code>: 当前系统活跃(未提交)事务版本号集合。</p>
<p>  <code>low_limit_id</code>: 创建当前read view 时“当前系统最大事务版本号+1”。</p>
<p>  <code>up_limit_id</code>: 创建当前read view 时“系统正处于活跃事务最小版本号”</p>
<p>  <code>creator_trx_id</code>: 创建当前read view的事务版本号；</p>
</li>
</ul>
<p>是否从undo log版本链中读数据，依据下面的算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Check whether the changes by id are visible.</span></span><br><span class="line"><span class="comment">@param[in]   id    transaction id to check against the view</span></span><br><span class="line"><span class="comment">@param[in]  name   able name</span></span><br><span class="line"><span class="comment">@return     whether the view sees the modifications of id. */</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">changes_visible</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">trx_id_t</span>                id,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">table_name_t</span>&amp;    name)</span> <span class="type">const</span></span><br><span class="line">    <span class="title function_">MY_ATTRIBUTE</span><span class="params">((warn_unused_result))</span></span><br><span class="line">&#123;</span><br><span class="line">    ut_ad(id&gt;<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (id &lt; m_up_limit_id || id==m_creator_trx_id)&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    check_trx_id_sanity(id, name);</span><br><span class="line">    <span class="keyword">if</span>(id&gt;=m_low_limit_id)&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">false</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(m_ids.empty())&#123;</span><br><span class="line">        <span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">ids_t</span>::value_type* p=m_ids.data();</span><br><span class="line">    <span class="keyword">return</span>(!<span class="built_in">std</span>::binary_search(p, P + m_ids.size(), id));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个例子：</p>
<p><img src="/2022/03/19/interview-database/mvcc_example.png" alt="image"></p>
<p>RC(read commit) 级别下同一个事务里面的每一次查询都会获得一个新的read view副本。这样就可能造成同一个事务里前后读取数据可能不一致的问题（重复读）<br><img src="/2022/03/19/interview-database/mvcc_rc.png" alt="image"></p>
<p>RR(重复读)级别下的一个事务里只会获取一次read view副本，从而保证每次查询的数据都是一样的。<br><img src="/2022/03/19/interview-database/mvcc_rr.png" alt="image"></p>
<h1 id="Sql"><a href="#Sql" class="headerlink" title="Sql"></a>Sql</h1><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h3><p>  首先，union和union all关键字都是将两个结果集合并为一个显示出来。但是它们的区别是：union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。</p>
<p>  union 在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。</p>
<p>  从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL</p>
<h3 id="MySQL-中-join-与-left-join-的区别是什么？"><a href="#MySQL-中-join-与-left-join-的区别是什么？" class="headerlink" title="MySQL 中 join 与 left join 的区别是什么？"></a>MySQL 中 join 与 left join 的区别是什么？</h3><p>  “内连接”join，其实就是“inner join”，为了简写才写成join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来。</p>
<p>  <img src="/2022/03/19/interview-database/join.png" alt="image"></p>
<h3 id="SQL优化的方案有哪些，如何定位问题并解决问题？？"><a href="#SQL优化的方案有哪些，如何定位问题并解决问题？？" class="headerlink" title="SQL优化的方案有哪些，如何定位问题并解决问题？？"></a>SQL优化的方案有哪些，如何定位问题并解决问题？？</h3><ul>
<li>定位问题：使用explain</li>
<li>优化思路<ul>
<li><p>尽量用union all代替union</p>
<p>  union的排序去重操作，增加大量的CPU运算，加大资源消耗及延迟。使用union all的前提是两个结果集没有重复数据。</p>
</li>
<li><p>SELECT语句务必指明字段名称</p>
<p>  SELECT* 增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性；</p>
</li>
<li><p>避免在where子句中对字段进行表达式操作</p>
<p>  会导致索引失效</p>
</li>
<li><p>对于联合索引来说，要遵守最左前缀法则</p>
<p>  查询从索引的最左列开始，并且不跳过索引中的列。也就是说查询的条件当中要包含索引最左侧的列，并且不能跳过索引当中的列。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(name, status, address);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 测试<span class="number">1</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address <span class="operator">=</span> <span class="string">&#x27;北京市&#x27;</span> <span class="operator">/</span><span class="operator">/</span>这样走索引吗？不走，因为没从索引最左边的列开始</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 测试<span class="number">2</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address <span class="operator">=</span> <span class="string">&#x27;北京市&#x27;</span> <span class="operator">/</span><span class="operator">/</span>这样走索引吗？不走，因为没从索引最左边的列开始</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 测试<span class="number">3</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address <span class="operator">=</span> <span class="string">&#x27;北京市&#x27;</span> <span class="keyword">and</span> name <span class="operator">=</span> <span class="string">&#x27;小米科技&#x27;</span> <span class="operator">/</span><span class="operator">/</span>走索引，顺序并不影响，只看查询条件有没有包含最左列</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 测试<span class="number">4</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> address <span class="operator">=</span> <span class="string">&#x27;北京市&#x27;</span> <span class="operator">/</span><span class="operator">/</span>走索引，只用到了name字段的索引，没用到address字段的索引</span><br></pre></td></tr></table></figure></li>
<li><p>注意范围查询语句</p>
<p>  对于联合索引来说，如果存在范围查询，比如 between,&gt;,&lt;等条件时，会造成后面的索引字段失效。</p>
</li>
<li><p>关于JOIN优化</p>
<p>  join的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环数据，再一次作为循环条件到后一个表中查询数据。</p>
<ul>
<li>用小结果集驱动大结果集，将筛选结果小的表首先连接，再去连接结果集比较大的表，尽量减少join语句中的Nested Loop的循环总次数；举例：假设A表10000行，B表100行；也就是说如果用A表做驱动表会伴随着10000次随机读，而如果是B表作为驱动表，会伴随着100次随机读。</li>
<li>对被驱动表的join字段上建立索引；使得对内表的查询走索引提高效率。这种做法最高效的就是外表是一张小表，而内表的连接谓词刚好是内表的主键。</li>
</ul>
</li>
<li><p>不建议使用%前缀模糊查询</p>
<p>  可以建立全文索引</p>
</li>
<li><p>避免在 where 子句中对字段进行 null 值判断</p>
<p>  对于 null的判断会导致引擎放弃使用索引而进行全表扫描</p>
</li>
</ul>
</li>
</ul>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="主键索引和辅助索引的区别？"><a href="#主键索引和辅助索引的区别？" class="headerlink" title="主键索引和辅助索引的区别？"></a>主键索引和辅助索引的区别？</h3><p>主键索引中存放着一条行记录的全部信息，而辅助索引中只包含索引列和一个用于查找对应行记录的『书签』，一般是主键。<br><img src="/2022/03/19/interview-database/mysql_index.png" alt="image"></p>
<h3 id="聚簇索引和非聚簇索引的区别？"><a href="#聚簇索引和非聚簇索引的区别？" class="headerlink" title="聚簇索引和非聚簇索引的区别？"></a>聚簇索引和非聚簇索引的区别？</h3><p>  聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据，一个表只有一个聚簇索引。</p>
<p>  非聚簇索引：将数据存储与索引分开，索引结构的叶子节点指向了数据的对应行</p>
<p>  innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。</p>
<h3 id="利用索引如何进行优化？"><a href="#利用索引如何进行优化？" class="headerlink" title="利用索引如何进行优化？"></a>利用索引如何进行优化？</h3><ul>
<li><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引<br>例如，SELECT actor_id FROM actor WHERE actor_id + 1 &#x3D; 5;</p>
</li>
<li><p>多列索引</p>
<p>  在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。<br>例如：SELECT film_id, actor_ id FROM film_actor WHERE actor_id &#x3D; 1 AND film_id &#x3D; 1;</p>
</li>
<li><p>索引列的顺序</p>
<p>  让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
</li>
<li><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>  对于前缀长度的选取需要根据索引选择性来确定。例如下面的表，使用前1-5位字符做前缀索引就会出现大量索引值重复的情况，导致查询效率低。<br>  <img src="/2022/03/19/interview-database/prefix_index.png" alt="image"></p>
</li>
<li><p>覆盖索引</p>
<p>  索引包含所有需要查询的字段。即从辅助索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。</p>
</li>
<li><p>如何优化查询的性能？</p>
<ul>
<li>使用explain进行分析<br>Explain 用来分析 SELECT 查询语句，结果如下<br><img src="/2022/03/19/interview-database/explain.png" alt="image"></li>
</ul>
</li>
<li><p>什么是全文索引？</p>
<p>通过倒排的方式，得到分词到全文的一个映射关系。</p>
</li>
</ul>
<h3 id="MySQL为什么用B-树做索引？"><a href="#MySQL为什么用B-树做索引？" class="headerlink" title="MySQL为什么用B+树做索引？"></a>MySQL为什么用B+树做索引？</h3><p>相比于二叉树、AVL树、红黑树来说，使用B+树有更少的查询次数，树节点出度越多，树高越矮，需要的查询次数越少，磁盘加载的次数也越少。</p>
<p>相比于B树来说，由于B+树叶节点保存有所有的数据，内节点保存的是索引，使得对于每个数据，查询都比较稳定。此外，B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况。</p>
<h3 id="MySQL为什么要有最左匹配原则？"><a href="#MySQL为什么要有最左匹配原则？" class="headerlink" title="MySQL为什么要有最左匹配原则？"></a>MySQL为什么要有最左匹配原则？</h3><p>最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被索引用到。</p>
<p>要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p>
<p>举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子。</p>
<p><img src="/2022/03/19/interview-database/leftIndex.png" alt="image"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b&#x3D;2这种查询条件没有办法利用索引。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h3><ul>
<li><p>事务：</p>
<p>  InnoDB是事务型存储引擎，实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ），在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。<br>  MyISAM不支持事务。</p>
</li>
<li><p>并发：</p>
<p>  InNoDB支持行级锁和表级锁，MyISAM只支持表级锁。</p>
</li>
<li><p>索引：</p>
<p>  InnoDB的索引是聚簇索引，MyISAM是非聚簇索引。</p>
<p>  InnoDB支持不支持全文索引，MyISAM支持。</p>
</li>
<li><p>场景：</p>
<p>  MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</p>
</li>
</ul>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><ul>
<li><p>好处</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
</li>
<li><p>原理</p>
<p>MySQL主从复制涉及到三个线程，一个运行在主节点，其余两个运行在从节点：</p>
<ul>
<li><p>binlog 线程：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</p>
</li>
<li><p>I&#x2F;O 线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</p>
</li>
<li><p>SQL 线程：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中执行。</p>
<p><img src="/2022/03/19/interview-database/mysql_syc.png" alt="image"></p>
</li>
</ul>
</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h3><p>  单库太大：数据库里面的表太多，所在服务器磁盘空间装不下，IO次数多，即IO瓶颈<br>  单表太大：一张表的字段太多，数据太多。查询起来困难，查询时扫描的行太多，SQl效率低，CPU瓶颈</p>
<h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>  水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。</p>
<p>  <img src="/2022/03/19/interview-database/horizontal_sharding.png" alt="image"></p>
<h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>  按照一定业务逻辑进行垂直切，此时不同的数据库应该存放在不同的服务器上，此时磁盘空间、内存、TPS等等都会得到解决。</p>
<p>  <img src="/2022/03/19/interview-database/vertical_sharding.png" alt="image"></p>
<h3 id="分库分表可能带来的问题？"><a href="#分库分表可能带来的问题？" class="headerlink" title="分库分表可能带来的问题？"></a>分库分表可能带来的问题？</h3><ul>
<li><p>事务</p>
<p>  分库分表后，就需要支持分布式事务了。</p>
</li>
<li><p>联合查询</p>
<p>  两个相关联的表可能会分布在不同的数据库。</p>
</li>
</ul>
<h2 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25960208">https://zhuanlan.zhihu.com/p/25960208</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="mysql如何进行故障恢复的？"><a href="#mysql如何进行故障恢复的？" class="headerlink" title="mysql如何进行故障恢复的？"></a>mysql如何进行故障恢复的？</h3><h3 id="简述-undo-log-和-redo-log-的作用"><a href="#简述-undo-log-和-redo-log-的作用" class="headerlink" title="简述 undo log 和 redo log 的作用"></a>简述 undo log 和 redo log 的作用</h3><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>string</p>
</li>
<li><p>list</p>
</li>
<li><p>set<br>set是一个无序的、自动去重的集合数据类型，Set底层用两种数据结构存储，一个是hashtable，一个是inset。</p>
<p>inset为可以理解为数组，使用inset数据结构需要满足下述两个条件：</p>
<ul>
<li>元素个数不少于默认值512</li>
<li>元素可以用整型表示</li>
</ul>
<p>查询方式一般采用二分查找法，实际查询复杂度也就在log(n)</p>
</li>
<li><p>hash</p>
</li>
<li><p>zset</p>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><img src="/2022/03/19/interview-database/redis_dict.png" alt="image"></p>
<ul>
<li><p>为什么要进行扩缩容？</p>
<p>  当哈希表中的元素太多或太少时，会进行扩容或者缩容。扩容是出于哈希表的查找效率考虑，当哈希表中的元素达到一定数量时，表中链的长度会随着哈希表元素的增长而增长，链表越长意味着查询效率也会越慢。缩容是为了节省内存空间，避免数组中太多空元素造成空间浪费。</p>
</li>
<li><p>Redis如何进行扩缩容？</p>
<p>  Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p>
<p>  rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1]上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p>
</li>
</ul>
<h3 id="有序集合zset"><a href="#有序集合zset" class="headerlink" title="有序集合zset"></a>有序集合zset</h3><p>  有序集合的底层实现之一是跳跃表，跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。<br><img src="/2022/03/19/interview-database/skip_list.png" alt="image"></p>
<p>与红黑树等平衡树相比，跳跃表具有以下优点：</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li>
<li>更容易实现；</li>
<li>支持无锁操作。</li>
<li>范围查找时比红黑树有优势。</li>
<li>查找、添加、删除操作都可以在对数期望时间下完成。</li>
</ul>
<h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ul>
<li>计数器</li>
<li>缓存</li>
<li>查找表</li>
<li>消息队列</li>
<li>session缓存</li>
<li>分布式锁实现</li>
<li>利用Zset实现排行榜</li>
</ul>
<h2 id="Redis和Memcached的区别"><a href="#Redis和Memcached的区别" class="headerlink" title="Redis和Memcached的区别"></a>Redis和Memcached的区别</h2><ul>
<li><p>数据类型</p>
<p>Memcached只支持字符串类型，Redis支持五种数据类型</p>
</li>
<li><p>数据持久化</p>
<p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p>
</li>
<li><p>分布式</p>
<p>Memcached 不支持分布式；Redis Cluster 实现了分布式的支持。</p>
</li>
<li><p>内存管理机制</p>
<p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而Memcached 的数据则会一直在内存中。Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。</p>
</li>
</ul>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p><img src="/2022/03/19/interview-database/redis_eliminating.png" alt="image"></p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<ul>
<li>RDB持久化<ul>
<li><p>触发机制：</p>
<ul>
<li><p>save命令：客户端向Redis发送save命令来创建一个快照文件。</p>
<p>  <img src="/2022/03/19/interview-database/save.png" alt="image"></p>
</li>
<li><p>bgsave命令：客户端向Redis发送bgsave命令，Redis调用fork创建一个子进程， 然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。</p>
<p>  <img src="/2022/03/19/interview-database/bgsave.png" alt="image"></p>
</li>
<li><p>自动生成：通过配置，满足任何一个条件就会创建快照文件。</p>
<p>  <img src="/2022/03/19/interview-database/auto.png" alt="image"></p>
</li>
</ul>
</li>
<li><p>具体执行：</p>
<ol>
<li>redis调用系统的fork()函数创建一个子进程</li>
<li>子进程将数据集写入一个临时的RDB文件</li>
<li>当子进程完成对临时的RDB文件的写入时，redis用新的RDB文件来替换原来旧的RDB文件，并将旧的RDB文件删除</li>
</ol>
</li>
<li><p>优点：</p>
<ul>
<li>RDB 非常适用于灾难恢复</li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
<li>RDB对redis对外提供读写服务的时候，影响非常小，因为redis 主进程只需要fork一个子进程出来，让子进程对磁盘io来进行rdb持久化。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>如果redis要故障时要尽可能少的丢失数据，RDB没有AOF好，</li>
</ul>
</li>
</ul>
</li>
<li>AOF持久化<ul>
<li>实现：<ul>
<li><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
</li>
<li><p>使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<p>  <img src="/2022/03/19/interview-database/redis_sync.png" alt="image"></p>
</li>
<li><p>always 选项会严重降低服务器的性能；</p>
</li>
<li><p>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</p>
</li>
<li><p>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</p>
</li>
</ul>
</li>
<li>优点：<ul>
<li>AOF可以更好的保护数据不丢失，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。</li>
</ul>
</li>
<li>缺点：<ul>
<li>AOF 文件比 RDB 文件大，且恢复速度慢。</li>
<li>数据集大的时候，比 rdb 启动效率低。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><ul>
<li><p>MULTI 命令用于开启一个事务，它总是返回 OK 。</p>
</li>
<li><p>MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。</p>
<p>  <img src="/2022/03/19/interview-database/multi1.png" alt="image"></p>
</li>
<li><p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p>  <img src="/2022/03/19/interview-database/multi2.png" alt="image"></p>
</li>
<li><p>事务中的错误</p>
<ul>
<li><p>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误。对于这种情况，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</p>
<p><img src="/2022/03/19/interview-database/multi3.png" alt="image"></p>
</li>
<li><p>命令可能在 EXEC 调用之后失败。比如，事务中的命令可能处理了错误类型的键。对于这种情况，即使事务中有某个&#x2F;某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</p>
<p><img src="/2022/03/19/interview-database/multi4.png" alt="image"></p>
</li>
</ul>
</li>
<li><p>带watch的事务<br>WATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务将被打断，不再执行， 直接返回失败。</p>
<p><img src="/2022/03/19/interview-database/multi5.png" alt="image"></p>
</li>
<li><p>三个特性</p>
<ul>
<li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题</li>
<li>不保证原子性：Redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Redis服务器是事件驱动程序</p>
<h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I&#x2F;O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p>
<p><img src="/2022/03/19/interview-database/file_event.png" alt="image"></p>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器</p>
<p><img src="/2022/03/19/interview-database/time_event.png" alt="image"></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>为了增加系统可靠性和读写性能，可以建立Redis主从集群。Redis Replication是一种简单、易用的主从模式（master-slave）的复制机制，它能够使得slave节点成为与master节点完全相同的副本。</p>
<h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ol>
<li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</li>
<li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li>
<li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li>
</ol>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022808576">https://segmentfault.com/a/1190000022808576</a></p>
<h3 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h3><ul>
<li><p>介绍</p>
<ul>
<li><p>主从模式里使用一个redis实例作为主机(master)，其余多个实例作为备份机(slave)；</p>
</li>
<li><p>master用来支持数据的写入和读取操作，而slave支持读取及master的数据同步；</p>
</li>
<li><p>在整个架构里，master和slave实例里的数据完全一致；</p>
<p><img src="/2022/03/19/interview-database/master_slave.png" alt="image"></p>
</li>
</ul>
</li>
<li><p>原理</p>
<ul>
<li><p>全量同步</p>
<ul>
<li>当从节点启动时，会向主节点发送SYNC命令；</li>
<li>主节点接收到SYNC命令后，开始在后台执行保存快照的命令生成RDB文件，并使用缓冲区记录此后执行的所有写命令；</li>
<li>主节点快照完成后，将快照文件和所有缓存命令发送给集群内的从节点，并在发送期间继续记录被执行的写命令；</li>
<li>主节点快照发送完毕后开始向从节点发送缓冲区中的写命令；</li>
<li>从节点载入快照文件后，开始接收命令请求，执行接收到的主节点缓冲区的写命令。</li>
</ul>
</li>
<li><p>增量同步</p>
<p>  主从复制中因网络等原因造成数据丢失场景，当从节点再次连上主节点。如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。</p>
</li>
</ul>
</li>
<li><p>主节点故障处理方式</p>
<p>  主从模式中，每个客户端连接redis实例时都指定了ip和端口号。如果所连接的redis实例因为故障下线了，则无法通知客户端连接其他客户端地址，因此只能进行手动操作。主从模式很好地解决了数据备份的问题，但是主节点因为故障下线后，需要手动更改客户端配置重新连接，这种模式并不能保证服务的高可用。</p>
</li>
</ul>
<h3 id="Sentinel（哨兵）模式"><a href="#Sentinel（哨兵）模式" class="headerlink" title="Sentinel（哨兵）模式"></a>Sentinel（哨兵）模式</h3><ul>
<li><p>参考</p>
<p>  <a target="_blank" rel="noopener" href="https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html</a></p>
</li>
<li><p>介绍</p>
<p>  和主从模式不一样的是，哨兵模式中增加了独立进程（即哨兵）来监控集群中的一举一动。客户端在连接集群时，首先连接哨兵，通过哨兵查询主节点的地址，然后再去连接主节点进行数据交互。哨兵的核心功能是主节点的自动故障转移。</p>
<p>  如下图所示，如果master异常，则会进行master-slave切换，将最优的一个slave切换为主节点。</p>
<p>  <img src="/2022/03/19/interview-database/sentinel.png" alt="image"></p>
</li>
<li><p>原理</p>
<ul>
<li><p>每个哨兵每秒向集群中的master、slave以及其他哨兵发送一个PING命令；</p>
</li>
<li><p>如果某个实例距离最后一次有效回复ping命令的时间超过一定值，则会被标记为主观下线；</p>
</li>
<li><p>如果master被标记为主观下线，那么其他正在监视master的哨兵以每秒的频率确认其确实进入主观下线状态，且数量达到一定值时，master会被标记为下线，然后通知其他的从服务器，修改配置文件，让它们切换主机；</p>
</li>
<li><p>客户端在master节点发生故障时会重向哨兵要地址，此时会获得最新的master节点地址。</p>
<p>补充：</p>
</li>
<li><p>主观下线：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断；</p>
</li>
<li><p>客观下线：由哨兵集群共同决定Redis节点是否下线；</p>
<p><img src="/2022/03/19/interview-database/level.png" alt="image"></p>
</li>
</ul>
</li>
<li><p>选举&#x2F;共识机制</p>
<p>  判断完主库下线后，由哪个哨兵节点来执行主从切换呢？这里就需要哨兵集群的选举机制了。</p>
<ul>
<li><p>为什么必然会出现选举&#x2F;共识机制？</p>
<p>  为了避免哨兵的单点情况发生，所以需要一个哨兵的分布式集群。作为分布式集群，必然涉及共识问题（即选举问题）；同时故障的转移和通知都只需要一个主的哨兵节点就可以了。</p>
</li>
<li><p>哨兵的选举机制是什么样的？</p>
<p>  哨兵的选举机制其实很简单，就是一个Raft选举算法： 选举的票数大于<code>num(sentinels)/2+1</code>时，将成为领导者，如果没有超过，继续选举</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<p>  哨兵模式的出现虽然解决了主从模式中master节点宕机不能自主切换（即高可用）的问题。但是，随着业务的逐渐增长，不可避免需要对当前业务进行扩容，无法可扩展。<br>  常见的扩容方式有垂直和水平扩容两种方式：</p>
<ul>
<li><p>垂直扩容：通过增加master内存来增加容量；</p>
</li>
<li><p>水平扩容：通过增加节点来进行扩容，即在当前基础上再增加一个master节点。</p>
<p>水平扩容涉及到数据的迁移，且迁移过程中又要保证服务的可用性，哨兵模式无法满足这种情形。因此，redis cluster应运而生。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Cluster-模式"><a href="#Cluster-模式" class="headerlink" title="Cluster 模式"></a>Cluster 模式</h3><ul>
<li><p>介绍</p>
<ul>
<li><p>redis cluster模式采用了无中心节点的方式来实现，每个主节点都会与其它主节点保持连接。节点间通过gossip协议交换彼此的信息，同时每个主节点又有一个或多个从节点；</p>
</li>
<li><p>客户端连接集群时，直接与redis集群的每个主节点连接，根据hash算法取模将key存储在不同的哈希槽上；</p>
</li>
<li><p>在集群中采用数据分片的方式，将redis集群分为16384个哈希槽。举个例子，比如当前集群有3个节点，那么这些哈希槽分别存储于三个主节点中：</p>
<ul>
<li>Master1负责0~5460号哈希槽</li>
<li>Master2负责5461~10922号哈希槽</li>
<li>Master3负责10922~16383号哈希槽</li>
</ul>
<p>每个节点会保存一份数据分布表，节点会将自己的slot信息发送给其他节点，节点间不停的传递数据分布表；</p>
<p>客户端连接集群时，通过集群中某个节点地址进行连接。客户端尝试向这个节点执行命令时，比如获取某个key值，如果key所在的slot刚好在该节点上，则能够直接执行成功。如果slot不在该节点，则节点会返回MOVED错误，同时把该slot对应的节点告诉客户端，客户端可以去该节点执行命令。<br><img src="/2022/03/19/interview-database/cluster.png" alt="image"></p>
</li>
</ul>
</li>
<li><p>原理</p>
<p>  redis cluster中主节点故障处理方式与哨兵模式较为相像，当约定时间内某节点无法与集群中的另一个节点顺利完成ping消息通信时，则将该节点标记为主观下线状态，同时将这个信息向整个集群广播。</p>
<p>  如果一个节点收到某个节点失联的数量达到了集群的大多数时，那么将该节点标记为客观下线状态，并向集群广播下线节点的fail消息。然后立即对该故障节点进行主从切换。等到原来的主节点恢复后，会自动成为新主节点的从节点。如果主节点没有从节点，那么当它发生故障时，集群就将处于不可用状态。</p>
</li>
<li><p>扩容问题</p>
<p>  在哨兵模式中我们在扩容的时候遇到了问题，那么cluster中我们如何动态上线某个节点呢。当集群中加入某个节点时，哈希槽又是如何来进行分配的？当集群中加入新节点时，会与集群中的某个节点进行握手，该节点会把集群内的其它节点信息通过gossip协议发送给新节点，新节点与这些节点完成握手后加入到集群中。</p>
<p>  然后集群中的节点会各取一部分哈希槽分配给新节点，如下图：</p>
<ul>
<li><p>Master1负责1365-5460</p>
</li>
<li><p>Master2负责6827-10922</p>
</li>
<li><p>Master3负责12288-16383</p>
</li>
<li><p>Master4负责0-1364,5461-6826,10923-12287</p>
<p><img src="/2022/03/19/interview-database/cluster_add.png" alt="image"></p>
<p>当集群中要删除节点时，只需要将节点中的所有哈希槽移动到其它节点，然后再移除空白（不包含任何哈希槽）的节点就可以了。</p>
</li>
</ul>
</li>
</ul>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="为什么-Redis-在单线程下能如此快？"><a href="#为什么-Redis-在单线程下能如此快？" class="headerlink" title="为什么 Redis 在单线程下能如此快？"></a>为什么 Redis 在单线程下能如此快？</h3><ul>
<li><p>纯内存操作</p>
<p>  Redis提供了丰富的数据类型，并使用高效的操作方式进行操作，这些操作都在内存中进行，并不会大量消耗CPU资源，所以速度极快。</p>
</li>
<li><p>使用IO多路复用技术</p>
<p>  Redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读&#x2F;可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。</p>
</li>
<li><p>非CPU密集型任务</p>
<p>  采用单线程的缺点很明显，无法使用多核CPU，由于Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽。</p>
</li>
<li><p>单线程的优势</p>
<ul>
<li>没有了多线程上下文切换的性能损耗</li>
<li>没有了访问共享资源加锁的性能损耗</li>
<li>开发和调试非常友好，可维护性高</li>
</ul>
</li>
</ul>
<h3 id="Redis-如何处理热点-key-访问"><a href="#Redis-如何处理热点-key-访问" class="headerlink" title="Redis 如何处理热点 key 访问"></a>Redis 如何处理热点 key 访问</h3><ul>
<li><p>问题</p>
<p>  所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。</p>
</li>
<li><p>发现</p>
<ul>
<li>借业务经验，进行预估哪些是热key</li>
<li>在Proxy层做收集</li>
<li>客户端进行统计</li>
</ul>
</li>
<li><p>如何解决</p>
<ul>
<li>利用二级缓存<br>  发现热key以后，把热key加载到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。</li>
<li>对热key进行备份<br>  不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。</li>
</ul>
</li>
</ul>
<h3 id="简述-Redis-哨兵的选举过程"><a href="#简述-Redis-哨兵的选举过程" class="headerlink" title="简述 Redis 哨兵的选举过程"></a>简述 Redis 哨兵的选举过程</h3><p>略  </p>
<h1 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h1><h2 id="什么是MongoDB？"><a href="#什么是MongoDB？" class="headerlink" title="什么是MongoDB？"></a>什么是MongoDB？</h2><p>  MongoDB是一个分布式文件存储的数据库，提供高性能，高可用性和易扩展性。</p>
<p>  MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。 MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</p>
<p><img src="/2022/03/19/interview-database/mongodb.png" alt="image"></p>
<p><img src="/2022/03/19/interview-database/mongodb_example.png" alt="image"></p>
<h2 id="MongoDB有什么特点？"><a href="#MongoDB有什么特点？" class="headerlink" title="MongoDB有什么特点？"></a>MongoDB有什么特点？</h2><ul>
<li><p>MongoDB目前只支持单文档事务，MongoDB暂时不适合需要复杂事务的场景。</p>
</li>
<li><p>高性能、高可用、可扩展</p>
</li>
<li><p>丰富的查询支持<br>  支持读写（CRUD）操作、比如数据聚合、文本搜索、地理空间查询等</p>
</li>
<li><p>支持动态Schemas。（动态Schema意味着单个集合中的文档可以包含不同类型的结构或形状。例如，以下两个文档都可以存储在一个集合中）</p>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; message  :  Hello World &#125;</span><br><span class="line">&#123; id  : 10,  description  :  India &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="MongoDB支持哪些数据类型？"><a href="#MongoDB支持哪些数据类型？" class="headerlink" title="MongoDB支持哪些数据类型？"></a>MongoDB支持哪些数据类型？</h2><p><img src="/2022/03/19/interview-database/mongodb_type.png" alt="image"></p>
<h2 id="解释一下NoSql，它与RDBMS的区别？"><a href="#解释一下NoSql，它与RDBMS的区别？" class="headerlink" title="解释一下NoSql，它与RDBMS的区别？"></a>解释一下NoSql，它与RDBMS的区别？</h2><ul>
<li>NoSQL是非关系型数据库，NoSQL &#x3D; Not Only SQL。</li>
<li>关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。</li>
<li>在处理非结构化&#x2F;半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。再考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。</li>
</ul>
<h2 id="NoSQL有哪些类型？"><a href="#NoSQL有哪些类型？" class="headerlink" title="NoSQL有哪些类型？"></a>NoSQL有哪些类型？</h2><ul>
<li><p>文档数据库</p>
<p>  这种类型的NoSQL数据库总是基于面向文档的方法来存储数据。文档数据库的主要目标是将单个实体的所有数据存储为一个文档，并且所有文档可以存储为一个集合。一些文档数据库的例子：MongoDB。</p>
</li>
<li><p>键值数据库</p>
<p>  这种类型的数据库以无模式的方式存储数据，因为键值存储是存储数据的最简单的方式。键可以是指向任何类型数据的点，比如对象、字符串或任何其他类型的数据。这些数据库的主要优点是易于实现和添加数据。例如:Redis,</p>
</li>
<li><p>列式数据库</p>
<p>   这些类型的数据库将数据存储在键空间中的列中。键空间总是在唯一的名称、值和时间戳上定义。如clickhouse。</p>
</li>
<li><p>图数据库</p>
<p>  这些类型的数据库主要是为可以很容易地表示为图形数据的数据而设计的。这意味着，数据之间存在着数量不定的数据关系，如家庭关系和社会关系等。如GraphDB。</p>
</li>
</ul>
<h2 id="Mongodb的object-id如何理解？"><a href="#Mongodb的object-id如何理解？" class="headerlink" title="Mongodb的object_id如何理解？"></a>Mongodb的object_id如何理解？</h2><p>  ObjectId 类似唯一主键，可以很快的去生成和排序，包含 12 bytes，含义如下：</p>
<p><img src="/2022/03/19/interview-database/mongodb_objectID.png" alt="image"></p>
<p>  MongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象。</p>
<h2 id="MongoDB如何保证可靠性的？"><a href="#MongoDB如何保证可靠性的？" class="headerlink" title="MongoDB如何保证可靠性的？"></a>MongoDB如何保证可靠性的？</h2><p>  通过复制将数据同步在多个服务器，保证冗余容灾。</p>
<p>  mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。</p>
<p>  <img src="/2022/03/19/interview-database/mongodb_sync.png" alt="image"></p>
<h2 id="说说MongoDB的分片？"><a href="#说说MongoDB的分片？" class="headerlink" title="说说MongoDB的分片？"></a>说说MongoDB的分片？</h2><p>  有时，MongoDB中的数据会非常庞大，以至于对如此大的数据集进行查询会导致服务器上大量的CPU被占用。为了解决这种情况，MongoDB提出了分片的概念，基本上是将数据集拆分到多个MongoDB实例中。</p>
<p>  分片的组成部分包括：</p>
<ul>
<li><p>分片（Shard）–基本上说，这不过是一个保存数据子集的MongoDB实例。在生产环境中，所有分片都必须是副本集的一部分。</p>
</li>
<li><p>配置服务器–一个mongodb实例，其中包含有关集群的元数据，基本上是有关将保存分片数据的各种mongodb实例的信息。</p>
</li>
<li><p>路由器–一个mongodb实例，主要负责将客户端发送的命令重定向到正确的服务器。</p>
<p><img src="/2022/03/19/interview-database/mongodb_shard.png" alt="image"></p>
</li>
</ul>
<h1 id="clickhouse"><a href="#clickhouse" class="headerlink" title="clickhouse"></a>clickhouse</h1><h2 id="什么是clickhouse？"><a href="#什么是clickhouse？" class="headerlink" title="什么是clickhouse？"></a>什么是clickhouse？</h2><p>  ClickHouse是一个用于联机分析(OLAP)的列式数据库管理系统(DBMS)。</p>
<p>  在传统的行式数据库系统中，数据按如下顺序存储，处于同一行中的数据总是被物理的存储在一起。如mysql。<br><img src="/2022/03/19/interview-database/row.png" alt="image"><br>  在列式数据库系统中，数据按如下的顺序存储：<br><img src="/2022/03/19/interview-database/col.png" alt="image"></p>
<h2 id="列式存储的好处？"><a href="#列式存储的好处？" class="headerlink" title="列式存储的好处？"></a>列式存储的好处？</h2><ul>
<li>针对分析类查询，通常只需要读取表的一小部分列。在列式数据库中你可以只读取你需要的数据。例如，如果只需要读取100列中的5列，这将帮助你最少减少20倍的I&#x2F;O消耗。</li>
<li>由于数据总是打包成批量读取的，所以压缩是非常容易的。同时数据按列分别存储这也更容易压缩。这进一步降低了I&#x2F;O的体积。</li>
<li>由于I&#x2F;O的降低，这将帮助更多的数据被系统缓存。</li>
</ul>
<h2 id="clickhouse的特点"><a href="#clickhouse的特点" class="headerlink" title="clickhouse的特点"></a>clickhouse的特点</h2><ul>
<li>没有完整的事务支持。</li>
<li>缺少高频率，低延迟的修改或删除已存在数据的能力。仅能用于批量删除或修改数据，</li>
<li>适合在线查询：在没有对数据做任何预处理的情况下以极低的延迟处理查询并将结果加载到用户的页面中。</li>
<li>真正的列式数据库管理系统</li>
<li>拥有完善的SQl支持和函数</li>
<li>支持高可用</li>
</ul>
<h2 id="行式存储和列式存储的区别？"><a href="#行式存储和列式存储的区别？" class="headerlink" title="行式存储和列式存储的区别？"></a>行式存储和列式存储的区别？</h2><ul>
<li>行式存储（Row-based）的适用场景包括：<ul>
<li>适合随机的增删改查操作;</li>
<li>需要在行中选取所有属性的查询操作;</li>
<li>需要频繁插入或更新的操作，其操作与索引和行的大小更为相关。<br>通常行式数据库的给出的优化方案是加“索引”，给表分区等等之类的.</li>
</ul>
</li>
<li>列式存储的适用场景包括：<ul>
<li>大数据量查询</li>
<li>非事务</li>
</ul>
</li>
</ul>

    </div>

    
    
    

<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:16px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>
        <div class="reward-container">
  <div>您的捐赠是对作者的最大鼓励</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpeg" alt="Benson 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpeg" alt="Benson 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Interview/" rel="tag"># Interview</a>
              <a href="/tags/Database/" rel="tag"># Database</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/19/interview-network/" rel="prev" title="interview-network">
      <i class="fa fa-chevron-left"></i> interview-network
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/20/interview-SystemDesign/" rel="next" title="interview-SystemDesign">
      interview-SystemDesign <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86"><span class="nav-number">1.</span> <span class="nav-text">数据库系统原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.1.</span> <span class="nav-text">关系数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">关系型数据库和非关系型数据库的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%92%8C%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">函数依赖和三范式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.2.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.1.</span> <span class="nav-text">什么是事务的ACID特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">1.3.</span> <span class="nav-text">并发一致性问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">1.4.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.4.1.</span> <span class="nav-text">数据库锁的类型有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%90%84%E8%87%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.4.2.</span> <span class="nav-text">乐观锁和悲观锁的区别，以及各自的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="nav-number">1.4.3.</span> <span class="nav-text">锁的粒度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">1.4.4.</span> <span class="nav-text">锁的算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.4.5.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.4.6.</span> <span class="nav-text">封锁协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.5.1.</span> <span class="nav-text">四种隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">1.5.2.</span> <span class="nav-text">多版本并发控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sql"><span class="nav-number">2.</span> <span class="nav-text">Sql</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">2.1.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#union%E5%92%8Cunion-all%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.1.</span> <span class="nav-text">union和union all的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E4%B8%AD-join-%E4%B8%8E-left-join-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.1.2.</span> <span class="nav-text">MySQL 中 join 与 left join 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98%E5%B9%B6%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%EF%BC%9F%EF%BC%9F"><span class="nav-number">2.1.3.</span> <span class="nav-text">SQL优化的方案有哪些，如何定位问题并解决问题？？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mysql"><span class="nav-number">3.</span> <span class="nav-text">Mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">3.1.</span> <span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.1.1.</span> <span class="nav-text">主键索引和辅助索引的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.1.2.</span> <span class="nav-text">聚簇索引和非聚簇索引的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">3.1.3.</span> <span class="nav-text">利用索引如何进行优化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8B-%E6%A0%91%E5%81%9A%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">3.1.4.</span> <span class="nav-text">MySQL为什么用B+树做索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="nav-number">3.1.5.</span> <span class="nav-text">MySQL为什么要有最左匹配原则？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">3.2.</span> <span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.1.</span> <span class="nav-text">InnoDB和MyISAM的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-number">3.3.</span> <span class="nav-text">读写分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">3.4.</span> <span class="nav-text">分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="nav-number">3.4.1.</span> <span class="nav-text">为什么要分库分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86"><span class="nav-number">3.4.2.</span> <span class="nav-text">水平切分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86"><span class="nav-number">3.4.3.</span> <span class="nav-text">垂直切分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">3.4.4.</span> <span class="nav-text">分库分表可能带来的问题？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88"><span class="nav-number">3.5.</span> <span class="nav-text">高可用方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">3.6.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E7%9A%84%EF%BC%9F"><span class="nav-number">3.6.1.</span> <span class="nav-text">mysql如何进行故障恢复的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-undo-log-%E5%92%8C-redo-log-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.6.2.</span> <span class="nav-text">简述 undo log 和 redo log 的作用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis"><span class="nav-number">4.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E5%85%B8"><span class="nav-number">4.2.1.</span> <span class="nav-text">字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88zset"><span class="nav-number">4.2.2.</span> <span class="nav-text">有序集合zset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.3.</span> <span class="nav-text">Redis使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%92%8CMemcached%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.4.</span> <span class="nav-text">Redis和Memcached的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">4.5.</span> <span class="nav-text">淘汰策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">4.6.</span> <span class="nav-text">持久化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="nav-number">4.7.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.8.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.8.1.</span> <span class="nav-text">文件事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6"><span class="nav-number">4.8.2.</span> <span class="nav-text">时间事件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-number">4.9.</span> <span class="nav-text">主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E7%9A%84"><span class="nav-number">4.9.1.</span> <span class="nav-text">目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B"><span class="nav-number">4.9.2.</span> <span class="nav-text">连接过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.10.</span> <span class="nav-text">集群模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.10.1.</span> <span class="nav-text">主从复制模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel%EF%BC%88%E5%93%A8%E5%85%B5%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.10.2.</span> <span class="nav-text">Sentinel（哨兵）模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cluster-%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.10.3.</span> <span class="nav-text">Cluster 模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96-1"><span class="nav-number">4.11.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Redis-%E5%9C%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%83%BD%E5%A6%82%E6%AD%A4%E5%BF%AB%EF%BC%9F"><span class="nav-number">4.11.1.</span> <span class="nav-text">为什么 Redis 在单线程下能如此快？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%83%AD%E7%82%B9-key-%E8%AE%BF%E9%97%AE"><span class="nav-number">4.11.2.</span> <span class="nav-text">Redis 如何处理热点 key 访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0-Redis-%E5%93%A8%E5%85%B5%E7%9A%84%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">4.11.3.</span> <span class="nav-text">简述 Redis 哨兵的选举过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Mongodb"><span class="nav-number">5.</span> <span class="nav-text">Mongodb</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFMongoDB%EF%BC%9F"><span class="nav-number">5.1.</span> <span class="nav-text">什么是MongoDB？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MongoDB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">MongoDB有什么特点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MongoDB%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">5.3.</span> <span class="nav-text">MongoDB支持哪些数据类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BNoSql%EF%BC%8C%E5%AE%83%E4%B8%8ERDBMS%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">5.4.</span> <span class="nav-text">解释一下NoSql，它与RDBMS的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NoSQL%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">5.5.</span> <span class="nav-text">NoSQL有哪些类型？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mongodb%E7%9A%84object-id%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="nav-number">5.6.</span> <span class="nav-text">Mongodb的object_id如何理解？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MongoDB%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="nav-number">5.7.</span> <span class="nav-text">MongoDB如何保证可靠性的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4MongoDB%E7%9A%84%E5%88%86%E7%89%87%EF%BC%9F"><span class="nav-number">5.8.</span> <span class="nav-text">说说MongoDB的分片？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#clickhouse"><span class="nav-number">6.</span> <span class="nav-text">clickhouse</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFclickhouse%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">什么是clickhouse？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">6.2.</span> <span class="nav-text">列式存储的好处？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clickhouse%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">6.3.</span> <span class="nav-text">clickhouse的特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.4.</span> <span class="nav-text">行式存储和列式存储的区别？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Benson"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Benson</p>
  <div class="site-description" itemprop="description">学习、记录、成长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/li-benson" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;li-benson" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:benson_li@stu.pku.edu.cn" title="E-Mail → mailto:benson_li@stu.pku.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Benson</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">125k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:54</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '78e128a5e6832a2a453f',
      clientSecret: '1c1f08f5d6455a4478e97ad5b09b0513fc5e7e0e',
      repo        : 'li-benson.github.io',
      owner       : 'li-benson',
      admin       : ['li-benson'],
      id          : 'b47b06d9cd77b76cb7efcc05f788cbfc',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
