<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="../../../../images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="../../../../images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="../../../../images/favicon-16x16.png">

<link rel="stylesheet" href="../../../../css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="../../../../lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":{"gitalk":{"order":-2}},"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文为准备面试时遇到的系统设计知识">
<meta property="og:type" content="article">
<meta property="og:title" content="interview-SystemDesign">
<meta property="og:url" content="http://example.com/2022/03/20/interview-SystemDesign/index.html">
<meta property="og:site_name" content="Benson&#39;s Blog">
<meta property="og:description" content="本文为准备面试时遇到的系统设计知识">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/03/20/interview-SystemDesign/DL.png">
<meta property="og:image" content="http://example.com/2022/03/20/interview-SystemDesign/local.png">
<meta property="og:image" content="http://example.com/2022/03/20/interview-SystemDesign/2PC1.png">
<meta property="og:image" content="http://example.com/2022/03/20/interview-SystemDesign/2PC2.png">
<meta property="og:image" content="http://example.com/2022/03/20/interview-SystemDesign/hash_add.png">
<meta property="og:image" content="http://example.com/2022/03/20/interview-SystemDesign/hash_ring.png">
<meta property="og:image" content="http://example.com/2022/03/20/interview-SystemDesign/ID.png">
<meta property="og:image" content="http://example.com/2022/03/20/interview-SystemDesign/db_id.png">
<meta property="og:image" content="http://example.com/2022/03/20/interview-SystemDesign/snowflow.png">
<meta property="article:published_time" content="2022-03-19T17:09:21.000Z">
<meta property="article:modified_time" content="2022-03-20T07:32:57.662Z">
<meta property="article:author" content="Benson">
<meta property="article:tag" content="Interview">
<meta property="article:tag" content="System Design">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/20/interview-SystemDesign/DL.png">

<link rel="canonical" href="http://example.com/2022/03/20/interview-SystemDesign/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>interview-SystemDesign | Benson's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Benson's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="../../../../index.html" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="../../../../about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="../../../../tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="../../../../categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="../../../../archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-study">

    <a href="../../../../study/" rel="section"><i class="fa fa-archive fa-fw"></i>学习</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    

  <a href="https://github.com/li-benson" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/20/interview-SystemDesign/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="../../../../images/avatar.jpg">
      <meta itemprop="name" content="Benson">
      <meta itemprop="description" content="学习、记录、成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Benson's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          interview-SystemDesign
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-03-20 01:09:21 / 修改时间：15:32:57" itemprop="dateCreated datePublished" datetime="2022-03-20T01:09:21+08:00">2022-03-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="../../../../categories/Interview-Knowledge/" itemprop="url" rel="index"><span itemprop="name">Interview Knowledge</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>
            <div class="post-description">本文为准备面试时遇到的系统设计知识</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="系统设计基础"><a href="#系统设计基础" class="headerlink" title="系统设计基础"></a>系统设计基础</h2><h3 id="如何对系统的性能进行优化？"><a href="#如何对系统的性能进行优化？" class="headerlink" title="如何对系统的性能进行优化？"></a>如何对系统的性能进行优化？</h3><ul>
<li><p>集群 </p>
<p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。 </p>
</li>
<li><p>缓存 </p>
</li>
<li><p>异步</p>
</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="/2022/03/20/interview-SystemDesign/DL.png"></p>
<h4 id="分布式锁的三种常用实现"><a href="#分布式锁的三种常用实现" class="headerlink" title="分布式锁的三种常用实现"></a>分布式锁的三种常用实现</h4><ul>
<li><p>数据库的唯一索引 </p>
<p>  创建一张锁表，定义方法或者资源名、失效时间等字段，同时针对加锁的信息添加唯一索引，比如方法名，当要锁住某个方法或资源时，就在该表中插入对应方法的一条记录，插入成功表示获取了锁，想要释放锁的时候就删除这条记录。 </p>
<p>但是这种方案有一些问题： </p>
<ul>
<li><p>存在单点故障风险 </p>
<p>一旦数据库挂掉，则会导致业务系统不可用，为了解决这个问题，需要配置数据库主从机器，防止单点故障。 </p>
</li>
<li><p>超时无法失效 </p>
<p>如果一旦解锁操作失败，则会导致锁记录一直在数据库中，其他线程无法再获得锁，解决这个问题，可以添加独立的定时任务，通过时间戳对比等方式，删除超时数据。 </p>
</li>
<li><p>不可重入 </p>
<p>可重入性是锁的一个重要特性。同一个线程在没有释放锁之前无法再次获得该锁，因为数据已经存在，再次插入会失败。实现可重入，需要改造加锁方法，额外存储和判断线程信息，不阻塞获得锁的线程再次请求加锁。 </p>
</li>
<li><p>无法实现阻塞 </p>
<p>其他线程在请求对应方法时，插入数据失败会直接返回，不会阻塞线程，如果需要阻塞其他线程，需要不断的重试 insert 操作，直到数据插入成功，这个操作是服务器和数据库资源的极大浪费。</p>
</li>
</ul>
</li>
<li><p>Redis缓存 </p>
<p>相比基于数据库实现分布式锁，缓存的性能更好，并且各种缓存组件也提供了多种集群方案，可以解决单点问题。 </p>
<p>在 Redis 中，setnx 是<code>「set if not exists」</code>如果不存在，则 SET 的意思，当一个线程执行 setnx 返回 1，说明 key 不存在，该线程获得锁；当一个线程执行 setnx 返回 0，说明 key 已经存在，那么获取锁失败，expire 就是给锁加一个过期时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(setnx(key,value)==1)&#123;</span><br><span class="line">    expire(key,expireTime)</span><br><span class="line">    try&#123;</span><br><span class="line">        //业务处理</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        del(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 setnx 和 expire 有一个问题，这两条命令可能不会同时失败，不具备原子性，如果一个线程在执行完 setnx 之后突然崩溃，导致锁没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取。可以使用SETEX 命令，SETEX 支持 setnx 和 expire 指令组合的原子操作，解决了加锁过程中失败的问题。 </p>
</li>
<li><p>Zookeeper </p>
<p>ZooKeeper 有四种节点类型，包括持久节点、持久顺序节点、临时节点和临时顺序节点，利用 ZooKeeper 支持临时顺序节点的特性，可以实现分布式锁。 </p>
<p>当客户端对某个方法加锁时，在 ZooKeeper 中该方法对应的指定节点目录下，生成一个唯一的临时有序节点。 </p>
<ul>
<li>使用zk的临时节点和有序节点，每个线程获取锁就是在zk创建一个临时有序的节点，比如在&#x2F;lock&#x2F;目录下。 </li>
<li>创建节点成功后，获取&#x2F;lock目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点 </li>
<li>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。 </li>
<li>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</li>
</ul>
<p>优点：ZooKeeper分布式锁（如InterProcessMutex），能有效的解决分布式问题，不可重入问题，使用起来也较为简单。 </p>
<p>缺点：ZooKeeper实现的分布式锁，性能并不太高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。大家知道，ZK中创建和删除节点只能通过Leader服务器来执行，然后Leader服务器还需要将数据同步到所有的Follower机器上，这样频繁的网络通信，性能的短板是非常突出的。总之，在高性能，高并发的场景下，不建议使用ZooKeeper的分布式锁。 </p>
</li>
<li><p>如何选择？ </p>
<p>（1）基于ZooKeeper的分布式锁，适用于高可靠（高可用）而并发量不是太大的场景； </p>
<p>（2）基于Redis的分布式锁，适用于并发量很大、性能要求很高的、而可靠性问题可以通过其他方案去弥补的场景。 </p>
</li>
<li><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazymakercircle/p/14504520.html">https://www.cnblogs.com/crazymakercircle/p/14504520.html</a></p>
</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ul>
<li><p>实例 </p>
<p>例如，在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。库存和订单要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。 </p>
</li>
<li><p>如何实现分布式事务？ </p>
<p>多个服务同时访问多个数据源的事务处理机制 </p>
<ul>
<li><p>本地消息表 </p>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。 </p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。 </li>
<li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。 </li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
<p><img src="/2022/03/20/interview-SystemDesign/local.png"></p>
</li>
<li><p>2PC </p>
<p>两阶段提交协议的目标在于为分布式系统保证数据的一致性，该协议将一个分布式的事务过程拆分成两个阶段： 投票 和 事务提交 。为了让整个数据库集群能够正常的运行，该协议指定了一个 协调者 单点，用于协调整个数据库集群各节点的运行。 </p>
<ul>
<li><p>运行过程 </p>
<p>1、第一阶段——投票 </p>
<p>该阶段的主要目的在于打探数据库集群中的各个参与者是否能够正常的执行事务，具体步骤如下： </p>
<ul>
<li>协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果； </li>
<li>事务参与者收到请求之后，执行事务但不提交，并记录事务日志； </li>
<li>参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。</li>
</ul>
<p>2、第二阶段——事务提交 </p>
<p>在经过第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在 3 种可能性： </p>
<ul>
<li><p>所有的参与者都回复能够正常执行事务。 </p>
<p><img src="/2022/03/20/interview-SystemDesign/2PC1.png"></p>
</li>
<li><p>一个或多个参与者回复事务执行失败。</p>
</li>
</ul>
<p><img src="/2022/03/20/interview-SystemDesign/2PC2.png"></p>
<ul>
<li>协调者等待超时。<br>同上。</li>
</ul>
</li>
<li><p>存在的问题 </p>
<ul>
<li><p>同步阻塞 </p>
<p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。 </p>
</li>
<li><p>单点问题 </p>
<p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响 </p>
</li>
<li><p>数据不一致 </p>
<p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>  分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：PartitionTolerance），最多只能同时满足其中两项。 </p>
<ul>
<li><p>一致性： </p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。 </p>
</li>
<li><p>可用性： </p>
<p>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。 </p>
</li>
<li><p>分区容忍性： </p>
<p>一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。</p>
</li>
</ul>
<p>  在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时： </p>
<ul>
<li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性； </li>
<li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>  BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。 </p>
<p>  BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 </p>
<ul>
<li><p>基本可用 </p>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。 </p>
</li>
<li><p>软状态 </p>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延 </p>
</li>
<li><p>最终一致性 </p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li><p>简述 Zookeeper 基础原理以及使用场景 </p>
<p>略</p>
</li>
</ul>
<h3 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h3><ul>
<li><p>要解决的问题 </p>
<p>paxos的工作, 就是把一堆运行的机器协同起来, 让多个机器成为一个整体系统. 在这个系统中, 每个机器都必须让系统中的状态达成一致, 例如三副本集群如果一个机器上上传了一张图片, 那么另外2台机器上也必须复制这张图片过来, 整个系统才处于一个一致的状态. </p>
</li>
<li><p>不太完美的复制策略 </p>
<p>在paxos之前有一些复制策略用来同步不同副本集群的数据： </p>
<ul>
<li><p>主从异步复制 </p>
<p>例如，MySQL的主从复制，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主库已经提交的事务可能并没有传到从库上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。 </p>
</li>
<li><p>主从同步复制 </p>
<p>当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会受到严重的影响。而且，如果整个系统中有任何一个机器宕机, 写入就进行不下去了. 相当于系统的可用性随着副本数量指数降低. </p>
</li>
<li><p>半同步复制 </p>
<p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP&#x2F;IP往返的时间。所以，半同步复制最好在低延时的网络中使用。 </p>
<p>而且，半同步复制也会导致数据不一致情况发生，例如数据a复制到slave-1, 但没有到达slave-2; 数据b复制达到了slave-2但没有到达slave-1, 这时如果master挂掉了需要从某个slave恢复出数据, 任何一个slave都不能提供完整的数据. </p>
</li>
<li><p>多数派读写 </p>
<p>每条数据必须写入到半数以上的机器上. 每次读取数据都必须检查半数以上的机器上是否有这条数据。这种策略下, 数据可靠性足够, 宕机容忍足够, 任一机器故障也能读到全部数据。<br>举个例子, 如果有5个存储节点{a, b, c, d, e}, 一笔操作给x赋值为3(x&#x3D;3) 成功写入了abc 3个节点, 那么另外一个读, 只要联系到任意3个节点, 就一定能读到x&#x3D;3 这就是安全的.<br>然而，多数派读写也可能导致不一致的状态。<br>例如: </p>
<ul>
<li>node-1, node-2都写入了a&#x3D;x, </li>
<li>下一次更新时，node-2, node-3写入了a&#x3D;y.<br>这时, 一个要进行读取a的客户端如果联系到了node-1和node-2, 它将看到2条不同的数据.</li>
</ul>
</li>
</ul>
</li>
<li><p>paxos协议 </p>
<p>paxos可以认为是多数派读写的进一步升级, paxos中通过2次原本并不严谨的多数派读写, 实现了严谨的强一致consensus算法。于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值<br><a target="_blank" rel="noopener" href="https://blog.openacid.com/algo/paxos/">https://blog.openacid.com/algo/paxos/</a></p>
</li>
</ul>
<h3 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h3><p>待补充</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ul>
<li><p>轮询 </p>
<p>把每个请求轮流发送到每个服务器上。适用于每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载。 </p>
</li>
<li><p>加权轮询 </p>
<p>在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。 </p>
</li>
<li><p>最少连接 </p>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。<br>最少连接算法就是将请求发送给当前最少连接数的服务器上。 </p>
</li>
<li><p>加权最少连接 </p>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。 </p>
</li>
<li><p>随机算法 </p>
<p>把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。 </p>
</li>
<li><p>源地址哈希法 </p>
<p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞。</p>
</li>
</ul>
<h3 id="负载均衡器是如何实现转发的？"><a href="#负载均衡器是如何实现转发的？" class="headerlink" title="负载均衡器是如何实现转发的？"></a>负载均衡器是如何实现转发的？</h3><ul>
<li><p>http重定向 </p>
<p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。 </p>
<p>缺点： </p>
<ul>
<li><p>需要两次请求，因此访问延迟比较高； </p>
</li>
<li><p>HTTP 负载均衡器处理能力有限，会限制集群的规模。</p>
</li>
</ul>
</li>
<li><p>DNS域名解析 </p>
<p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。<br>优点：DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。<br>缺点：由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。 </p>
</li>
<li><p>反向代理服务器 </p>
<p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。<br>反向代理可以用来进行缓存、日志记录等，同时也可以用来作为负载均衡服务器。在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。 </p>
<p>优点：与其它功能集成在一起，部署简单。</p>
<p>缺点：所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。 </p>
</li>
<li><p>IP负载均衡 </p>
<p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。 </p>
<p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。 </p>
<p>优点：在内核进程中进行处理，性能比较高。</p>
<p>缺点：和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。 </p>
</li>
<li><p>数据链路层负载均衡 </p>
<p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。 </p>
<p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。 </p>
<p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p>
</li>
</ul>
<h3 id="集群下如何进行session管理的？"><a href="#集群下如何进行session管理的？" class="headerlink" title="集群下如何进行session管理的？"></a>集群下如何进行session管理的？</h3><p>  一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。 </p>
<ul>
<li><p>Sticky Session </p>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。<br>缺点：当服务器宕机时，将丢失该服务器上的所有 Session。 </p>
</li>
<li><p>Session Replication </p>
<p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。<br>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。 </p>
</li>
<li><p>Session Server </p>
<p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。 </p>
<p>优点：为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。 </p>
<p>缺点：需要去实现存取 Session 的代码。</p>
</li>
</ul>
<h2 id="攻击技术"><a href="#攻击技术" class="headerlink" title="攻击技术"></a>攻击技术</h2><h3 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h3><h3 id="跨站请求伪造"><a href="#跨站请求伪造" class="headerlink" title="跨站请求伪造"></a>跨站请求伪造</h3><h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h3><ul>
<li><p>命中率 </p>
<p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。 </p>
<p>缓存命中率越高，缓存的利用率也就越高。 </p>
</li>
<li><p>最大空间 </p>
<p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p>
</li>
</ul>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ul>
<li><p>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用FIFO，使得最先进入的数据（最晚的数据）被淘汰。 </p>
</li>
<li><p>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。<br>实现：双向链表+哈希表 </p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/lfu-cache/">LFU</a>（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。 </p>
<p>实现：两个map</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;int,list&lt;node&gt;::iterator&gt; key_mp;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;int,list&lt;node&gt;&gt; freq_mp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><ul>
<li><p>浏览器 </p>
<p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。 </p>
</li>
<li><p>ISP </p>
<p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。 </p>
</li>
<li><p>反向代理 </p>
<p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。 </p>
</li>
<li><p>本地缓存 </p>
<p>将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。 </p>
</li>
<li><p>分布式缓存 </p>
<p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。 </p>
</li>
<li><p>数据库缓存 </p>
<p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p>
</li>
</ul>
<h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><ul>
<li><p>缓存穿透 </p>
<ul>
<li>含义：指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。 </li>
<li>危害：如果存在海量请求查询压根就不存在的数据，那么这些海量请求都会落到数据库中，数据库压力剧增，可能会导致系统崩溃 </li>
<li>解决方案： <ul>
<li>对这些不存在的数据缓存一个空数据； </li>
<li>对这类请求进行过滤。 </li>
<li>使用布隆过滤器。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存雪崩 </p>
<ul>
<li>含义：指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。 </li>
<li>危害：当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃 </li>
<li>解决方案： <ul>
<li>进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。 </li>
<li>防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。 </li>
<li>观察用户行为，合理设置缓存过期时间来实现。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存击穿 </p>
<ul>
<li>含义：指数据库原本有数据，但是缓存中没有，一般是缓存突然失效了，导致请求到达数据库。 </li>
<li>危害：如果有大量用户请求该数据，缓存没有则会去数据库请求，会引发数据库压力增大，可能会瞬间打垮。 </li>
<li>解决方案： <ul>
<li>如果是热点数据，那么可以考虑设置永远不过期。 </li>
<li>如果数据一定会过期，那么就需要在数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，要不其他线程会一直拿不到锁。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存一致性 </p>
<p><a href="https://link.juejin.cn/?target=https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">Cache Aside Pattern</a>思路： </p>
<ul>
<li>失效：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中 </li>
<li>命中：程序先从缓存中读取数据，如果命中，则直接返回 </li>
<li>更新：程序先更新数据库，再删除缓存</li>
</ul>
<p>关键问题在于第三点，也就是数据更新流程，为什么要先更新数据库？为什么之后要删除缓存而不是更新？ </p>
<ul>
<li><p>先更新缓存，再更新数据库 </p>
<p>从数据持久化的角度来说，数据库当然要比缓存做的好，我们也应当以数据库中的数据为主，所以需要更新数据的时候我们应当首先更新数据库，而不是缓存。 </p>
</li>
<li><p>先更新数据库，再更新缓存 </p>
<p>可能会出现两种问题： </p>
<ul>
<li><p>并发导致的不一致，例如下面的执行顺序： </p>
<ol>
<li>线程A更新了数据库 </li>
<li>线程B更新了数据库 </li>
<li>线程B更新了缓存 </li>
<li>线程A更新了缓存</li>
</ol>
</li>
<li><p>资源浪费 </p>
<p>我们不确定要更新的这个缓存项是否会被经常读取。</p>
</li>
</ul>
</li>
<li><p>先删除缓存，再更新数据库 </p>
<p>也会出现并发导致的不一致，例如下面的执行顺序： </p>
<ul>
<li>请求A删除缓存 </li>
<li>请求B读取缓存，发现不存在，从数据库中读取到旧值 </li>
<li>请求A将新值写入数据库 </li>
<li>请求B将旧值写入缓存</li>
</ul>
</li>
<li><p>先更新数据库，再删除缓存 </p>
<p>也可能出现问题，但概率很低。</p>
</li>
</ul>
<p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p>
</li>
</ul>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>一致性哈希解决了简单哈希算法在分布式哈希表（Distributed Hash Table，DHT）中存在的动态伸缩等问题 。例如：服务器数量从3增加到4，原先的key将会被导致节点映射错误。对于分布式缓存这种的系统而言，映射规则失效就意味着之前缓存的失效，若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。 </p>
<p><img src="/2022/03/20/interview-SystemDesign/hash_add.png"></p>
<ul>
<li><p>基本原理 </p>
<p>将哈希空间 [0, 2^n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上（可以选择服务器的 IP 或主机名作为键进行哈希）。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。 </p>
<p>  <img src="/2022/03/20/interview-SystemDesign/hash_ring.png"></p>
<p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如上图中新增节点cs4，只需要对t2和t4之间的数据重新进行分布即可，对于其他的对象都没有影响。 </p>
</li>
<li><p>虚拟节点 </p>
<p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。 </p>
<p>针对这个问题，我们可以通过引入虚拟节点来解决负载不均衡的问题。即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器。</p>
</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><ul>
<li><p>点对点 </p>
<p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。 </p>
</li>
<li><p>发布-订阅 </p>
<p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p>
</li>
</ul>
<h3 id="推拉模式"><a href="#推拉模式" class="headerlink" title="推拉模式"></a>推拉模式</h3><p>对于消息队列的消费者来说，主要有两种模式从消息队列获取消息，分别是push&#x2F;pull模式。push模式就是消息队列主动推送消息，pull模式就是consumer轮询拉取消息。 </p>
<ul>
<li><p>push模式的实时性非常好，因为队列收到消息以后就立即push给消费者，push模式的主要缺点是消息的消费速度取决于消费者，如果消费者的处理能力有限，push太多消息会导致消费者进程内存占满，甚至崩溃。而且消息队列服务器的负担比较重。push模式还有一个缺点是没有反馈机制，消息是否成功消费无从得知。 </p>
</li>
<li><p>pull模式正好相反，缺乏实时性，但是消息队列服务器的负担轻，消费者可以根据自己的处理速度拿消息，而且有反馈机制，如果消息消费失败会重新进入队列。目前流行的大吞吐量的消息队列比如kafka就是pull模式 </p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3></li>
<li><p>异步 </p>
<p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。 </p>
</li>
<li><p>解耦 </p>
<p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。 </p>
</li>
<li><p>削峰 </p>
<p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p>
</li>
</ul>
<h3 id="kafaka"><a href="#kafaka" class="headerlink" title="kafaka"></a>kafaka</h3><ul>
<li><p>简述 Kafka 的基本架构，如何用 Kafka 保证消息的有序性？ </p>
</li>
<li><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何实现百度搜索功能？"><a href="#如何实现百度搜索功能？" class="headerlink" title="如何实现百度搜索功能？"></a>如何实现百度搜索功能？</h3><h3 id="设计一个阻塞队列"><a href="#设计一个阻塞队列" class="headerlink" title="设计一个阻塞队列"></a>设计一个阻塞队列</h3><h3 id="容器化了解吗？它的基本原理是什么？"><a href="#容器化了解吗？它的基本原理是什么？" class="headerlink" title="容器化了解吗？它的基本原理是什么？"></a>容器化了解吗？它的基本原理是什么？</h3><h3 id="电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？"><a href="#电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？" class="headerlink" title="电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？"></a>电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？</h3><ul>
<li>抢订单环节一般会带来两个问题： <ul>
<li><p>高并发 </p>
<p>比较火热的秒杀在线人数都是10w起的，如此之高的在线人数对于网站架构从前到后都是一种考验。</p>
</li>
<li><p>超卖 </p>
<p>任何商品都会有数量上限，如何避免成功下订单买到商品的人数不超过商品数量的上限，这是每个抢购活动都要面临的难题。</p>
</li>
</ul>
</li>
<li>如何解决 <ul>
<li>超卖问题 <ul>
<li><p>悲观锁 </p>
<p>处理性能不高，当一件商品有多位客户同时下单的时候，每个请求需要等待排他锁，也要较长才知道是否下单成功。 </p>
</li>
<li><p>乐观锁 </p>
<p>乐观锁因为并不需要等待锁，所以在事务竞争较少的情况下比悲观锁有更好的性能，缺点是事务竞争较多的情况下，由于经常需要回滚事务导致性能反而较差。 </p>
</li>
<li><p>分布式锁 </p>
<p>如果有多个服务器，需要加分布式锁。但是也有一些缺点：分布式锁的正确实现并不简单，错误的实现方式容易引起其他一致性的问题。2）分布式锁在高并发下也会产生锁竞争的问题，性能不佳。 </p>
</li>
<li><p>消息队列 </p>
<p>确保每个商品每个时刻只有一个请求。消息队列的优点对业务进行了解耦，除了数据库之外，其他对下单请求感兴趣的业务系统，例如数据分析，日志记录等都可以订阅下单请求的消息。缺点在于 1）因为消息队列可能会崩溃，消息发送也可能失败，所以要考虑消息只消费一次，不会因为重复消费导致重复下单。2）由于引入了新的组件，要考虑消息队列的可靠性，以及崩溃之后的恢复机制。</p>
</li>
</ul>
</li>
<li>高并发 <ul>
<li><p>流量控制 </p>
<ul>
<li><p>CDN </p>
<p>大量的客户端在下单前同时请求同一个商品的秒杀页面，导致服务器压力骤升。可以将秒杀页面使用 CDN 缓存起来，客户端就可以直接从 CDN 获取到秒杀页面，不需要重复请求服务器。 </p>
</li>
<li><p>限流器</p>
<ol>
<li>前端限流包括验证答题，防止重复点击按钮等常见机制。 </li>
<li>后端限流使用限流算法进行流量限制，简单情况下可以使用固定限流算法，例如秒杀商品的库存是 10 件，只要限流器接收到 10 * k（k 可以根据业务进行调整）个请求之后，就停止接受该商品的所有请求。</li>
</ol>
</li>
<li><p>负载均衡 </p>
<p>负载均衡负责将下单请求通过负载均衡算法转发到最合适的服务器。 </p>
</li>
<li><p>安全验证 </p>
<ol>
<li>前端安全验证包括：客户端账户验证（确保客户有资格参考秒杀活动），客户端版本安全验证（防止反编译以及修改客户端代码），秒杀接口动态生成（防止使用刷单脚本） </li>
<li>后端安全验证包括黑名单校验，IP 地址校验等机制。</li>
</ol>
</li>
</ul>
</li>
<li><p>热门资源隔离 </p>
<p>首先识别出热门商品，我们可以将热门商品的资源进行隔离，并且设置独立的策略。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何实现唯一的分布式-ID"><a href="#如何实现唯一的分布式-ID" class="headerlink" title="如何实现唯一的分布式 ID"></a>如何实现唯一的分布式 ID</h3><ul>
<li><p>为什么需要全局唯一ID？ </p>
<p>传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的ID一般我们都是从1增，通过AUTO_INCREMENT&#x3D;1设置自增起始值，但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。 </p>
<p><img src="/2022/03/20/interview-SystemDesign/ID.png"></p>
</li>
<li><p>方式 </p>
<ul>
<li><p>UUID </p>
<p>Universally Unique Identifier，通用唯一识别码的缩写。UUID是由一组32位数的16进制数字所构成。有一些不同的uuid产生方式： </p>
<ul>
<li>基于时间的uuid </li>
<li>基于名字的uuid </li>
<li>随机uuid</li>
</ul>
<p>但是uuid也有一些缺点： </p>
<ul>
<li>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。 </li>
<li>对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能</li>
</ul>
</li>
<li><p>数据库生成 </p>
<p>我们可以在分布式数据库的基础上获取我们需要的ID，由于分布式数据库的起始自增值一样所以才会有冲突的情况发生，那么我们将分布式系统中数据库的同一个业务表的自增ID设计成不一样的起始值，然后设置固定的步长，步长的值即为分库的数量或分表的数量。</p>
<p><img src="/2022/03/20/interview-SystemDesign/db_id.png"> </p>
<p>这种方式明显的优势就是依赖于数据库自身不需要其他资源，并且ID号单调自增，可以实现一些对ID有特殊要求的业务。<br>但是缺点也很明显，首先它强依赖DB，当DB异常时整个系统不可用。虽然配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。 </p>
</li>
<li><p>Redis </p>
<p>通过提供像 INCR 和 INCRBY 这样的自增原子命令，由于Redis自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的。<br>但是单机存在性能瓶颈，无法满足高并发的业务需求，所以可以采用集群的方式来实现。集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。 </p>
</li>
<li><p>雪花算法 </p>
<p>  <img src="/2022/03/20/interview-SystemDesign/snowflow.png"></p>
<p>雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的，而且可以根据自身业务特性分配bit位，非常灵活。但是雪花算法强依赖机器时钟。</p>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    

<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:16px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
  
</div>
        <div class="reward-container">
  <div>您的捐赠是对作者的最大鼓励</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="../../../../images/wechatpay.jpeg" alt="Benson 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="../../../../images/alipay.jpeg" alt="Benson 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="../../../../tags/Interview/" rel="tag"># Interview</a>
              <a href="../../../../tags/System-Design/" rel="tag"># System Design</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="../../19/interview-database/" rel="prev" title="interview-database">
      <i class="fa fa-chevron-left"></i> interview-database
    </a></div>
      <div class="post-nav-item">
    <a href="../interview-OOP/" rel="next" title="interview-OOP">
      interview-OOP <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">系统设计基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">如何对系统的性能进行优化？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">分布式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">2.1.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">分布式锁的三种常用实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.2.</span> <span class="nav-text">分布式事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAP%E7%90%86%E8%AE%BA"><span class="nav-number">2.3.</span> <span class="nav-text">CAP理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Base%E7%90%86%E8%AE%BA"><span class="nav-number">2.4.</span> <span class="nav-text">Base理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper"><span class="nav-number">2.5.</span> <span class="nav-text">Zookeeper</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Paxos%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.6.</span> <span class="nav-text">Paxos协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Raft%E5%8D%8F%E8%AE%AE"><span class="nav-number">2.7.</span> <span class="nav-text">Raft协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4"><span class="nav-number">3.</span> <span class="nav-text">集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">负载均衡算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%BD%AC%E5%8F%91%E7%9A%84%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">负载均衡器是如何实现转发的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E4%B8%8B%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8Csession%E7%AE%A1%E7%90%86%E7%9A%84%EF%BC%9F"><span class="nav-number">3.3.</span> <span class="nav-text">集群下如何进行session管理的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF"><span class="nav-number">4.</span> <span class="nav-text">攻击技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB"><span class="nav-number">4.1.</span> <span class="nav-text">跨站脚本攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0"><span class="nav-number">4.2.</span> <span class="nav-text">跨站请求伪造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB"><span class="nav-number">4.3.</span> <span class="nav-text">SQL注入攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB"><span class="nav-number">4.4.</span> <span class="nav-text">拒绝服务攻击</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">5.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%89%B9%E5%BE%81"><span class="nav-number">5.1.</span> <span class="nav-text">缓存特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">5.2.</span> <span class="nav-text">淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE"><span class="nav-number">5.3.</span> <span class="nav-text">缓存位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98"><span class="nav-number">5.4.</span> <span class="nav-text">缓存问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C"><span class="nav-number">6.</span> <span class="nav-text">一致性哈希</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">7.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">7.1.</span> <span class="nav-text">消息模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">推拉模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">7.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafaka"><span class="nav-number">7.4.</span> <span class="nav-text">kafaka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">7.5.</span> <span class="nav-text">RabbitMQ</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">8.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">如何实现百度搜索功能？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="nav-number">8.2.</span> <span class="nav-text">设计一个阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%8C%96%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%AE%83%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">容器化了解吗？它的基本原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%A7%92%E6%9D%80%E5%8A%9F%E8%83%BD%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%95%86%E5%93%81%E7%9A%84%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">8.4.</span> <span class="nav-text">电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%94%AF%E4%B8%80%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-ID"><span class="nav-number">8.5.</span> <span class="nav-text">如何实现唯一的分布式 ID</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Benson"
      src="../../../../images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Benson</p>
  <div class="site-description" itemprop="description">学习、记录、成长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="../../../../archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="../../../../categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="../../../../tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/li-benson" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;li-benson" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="../../../../mailto:benson_li@stu.pku.edu.cn" title="E-Mail → mailto:benson_li@stu.pku.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Benson</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">93k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">1:24</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="../../../../lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="../../../../lib/anime.min.js"></script>
  <script src="../../../../lib/velocity/velocity.min.js"></script>
  <script src="../../../../lib/velocity/velocity.ui.min.js"></script>

<script src="../js/utils.js"></script>

<script src="../js/motion.js"></script>


<script src="../js/schemes/pisces.js"></script>


<script src="../js/next-boot.js"></script>


  <script defer src="../../../../lib/three/three.min.js"></script>
    <script defer src="../../../../lib/three/three-waves.min.js"></script>


  




  
<script src="../js/local-search.js"></script>













  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '64px',
  right: 'unset',
  left: '32px',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '78e128a5e6832a2a453f',
      clientSecret: '1c1f08f5d6455a4478e97ad5b09b0513fc5e7e0e',
      repo        : 'li-benson.github.io',
      owner       : 'li-benson',
      admin       : ['li-benson'],
      id          : 'd41d8cd98f00b204e9800998ecf8427e',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
