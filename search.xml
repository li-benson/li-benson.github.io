<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux-Commands</title>
    <url>/2022/03/27/Linux-Commands/</url>
    <content><![CDATA[<h2 id="复制文件夹"><a href="#复制文件夹" class="headerlink" title="复制文件夹"></a>复制文件夹</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r [srcName] [dstName]</span><br></pre></td></tr></table></figure>

<h2 id="比较两个文件差异"><a href="#比较两个文件差异" class="headerlink" title="比较两个文件差异"></a>比较两个文件差异</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff [参数] [文件1或目录1] [文件2或目录2]</span><br></pre></td></tr></table></figure>
<p>一些常用的参数</p>
<ul>
<li><code>-i</code>或<code>--ignore-case</code> 　不检查大小写的不同</li>
<li><code>-w</code>或<code>--ignore-all-space</code> 　忽略全部的空格字符。</li>
<li><code>-b</code>或<code>--ignore-space-change</code> 　不检查空格字符的不同。</li>
</ul>
<h2 id="查看磁盘使用情况"><a href="#查看磁盘使用情况" class="headerlink" title="查看磁盘使用情况"></a>查看磁盘使用情况</h2><p>df: <code>disk free</code>的简称，该命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df [参数]</span><br></pre></td></tr></table></figure>

<p>一些常用的参数：</p>
<ul>
<li><code>-a</code> 列出所有的文件系统</li>
<li><code>-T</code> 显示文件系统的类型</li>
</ul>
<p><img src="/2022/03/27/Linux-Commands/df.png"></p>
<h2 id="查看文件所占空间"><a href="#查看文件所占空间" class="headerlink" title="查看文件所占空间"></a>查看文件所占空间</h2><p>du: <code>Disk Usage</code>的简称，它用来估算文件或目录占用的磁盘空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>
<p>常用的选项如下:</p>
<ul>
<li><p><code>-a</code>: 显示目录中所有文件以及文件夹大小</p>
</li>
<li><p><code>-h</code>: 以 Kb、Mb 、Gb 等易读的单位显示大小</p>
</li>
</ul>
<h2 id="查看用户名和组名"><a href="#查看用户名和组名" class="headerlink" title="查看用户名和组名"></a>查看用户名和组名</h2><p>查看用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure>

<p><code>id</code> 命令可以显示真实有效的用户 ID(UID) 和组 ID(GID)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id -un  // 显示用户名称</span><br><span class="line">id -gn  // 显示用户组名称</span><br></pre></td></tr></table></figure>

<h2 id="比较两个文件"><a href="#比较两个文件" class="headerlink" title="比较两个文件"></a>比较两个文件</h2><p><code>cmp</code>命令用于比较两个文件是否有差异。当相互比较的两个文件完全一样时，则该指令不会显示任何信息。如果文件不同，则显示第一个不同的位置。</p>
<h2 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h2><p><code>more</code>功能类似 <code>cat</code> ，<code>cat</code>命令是整个文件的内容从上到下显示在屏幕上。 <code>more</code>会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（<code>space</code>）就往下一页显示，按 <code>b</code> 键就会往回（<code>back</code>）一页显示.</p>
<p><code>less</code> 工具也是对文件或其它输出进行分页显示的工具。<code>less</code> 的用法比起 <code>more</code> 更加的有弹性。 在 <code>more</code> 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 <code>less</code> 时，就可以使用 <code>[pageup] [pagedown]</code> 等按 键的功能来往前往后翻看文件，更容易用来查看一个文件的内容</p>
<h2 id="find用法"><a href="#find用法" class="headerlink" title="find用法"></a>find用法</h2><p><code>find</code> 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find   path   -option</span><br></pre></td></tr></table></figure>
<p>一些常用的参数：</p>
<ul>
<li><code>-type</code> 表示文件类型，f: 一般文件; d: 目录; c: 字符型文件; </li>
<li><code>-name &quot;name&quot;</code>: 文件名称符合 name 的文件。</li>
<li><code>-iname &quot;name&quot;</code>: iname 会忽略大小写。</li>
<li><code>-empty</code>: 空的文件.</li>
<li><code>-size n</code>: 文件大小 是 n 单位</li>
</ul>
<h2 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h2><p>cut命令用于显示每行从开头算起 num1 到 num2 的文字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut  [-bn] [file]</span><br><span class="line">cut [-c] [file]</span><br><span class="line">cut [-df] [file]</span><br></pre></td></tr></table></figure>
<p>例1：截取 temp.txt 的每一行的第 1、2、3 和 第8个字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut -b 1-3, 8 temp.txt</span><br></pre></td></tr></table></figure>

<p>例2：截取 temp.txt 的每一行 @ 前的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cut -d @ -f 1 temp.txt</span><br></pre></td></tr></table></figure>

<p>参数列表：</p>
<ul>
<li><code>-d</code> 自定义分隔符，默认为制表符.</li>
<li><code>-f</code> 与-d一起使用，指定显示哪个区域</li>
</ul>
<h2 id="创建文件链接"><a href="#创建文件链接" class="headerlink" title="创建文件链接"></a>创建文件链接</h2><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用 <code>ln</code> 命令链接它就可以，不必重复的占用磁盘空间。</p>
<p><code>ln</code> : link 链接 的简称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln [参数列表] [源文件或目录] [目标文件或目录]</span><br></pre></td></tr></table></figure>
<p>常用参数列表：</p>
<ul>
<li><code>-s</code> 创建符号链接而不是硬链接，默认是硬链接</li>
<li><code>-f</code> 如果目标文件存在，强制删除并创建，–force的简称</li>
</ul>
<h2 id="使用不同进制查看文件内容"><a href="#使用不同进制查看文件内容" class="headerlink" title="使用不同进制查看文件内容"></a>使用不同进制查看文件内容</h2><p><code>od</code> : Octal Dump 的简称，不加参数时默认以8进制输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">od [OPTION] [FILE]</span><br></pre></td></tr></table></figure>
<p>常用的选项：</p>
<ul>
<li>-d: 以十进制格式查看文件内容</li>
<li>-x: 以十六进制格式查看文件内容</li>
<li>-A：指定地址基数，n不显示偏移量</li>
</ul>
<h2 id="echo显示字符串"><a href="#echo显示字符串" class="headerlink" title="echo显示字符串"></a>echo显示字符串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo [选项] [输出内容]</span><br></pre></td></tr></table></figure>
<p>常用参数：</p>
<ul>
<li><code>-e</code>：支持控制字符, 例如<code>echo -e &quot;Hello\nWorld!&quot;</code></li>
</ul>
<p>也可以输出一个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=&#x27;Jack&#x27;</span><br><span class="line">echo name   // 输出name</span><br><span class="line">echo $name  // 输出Jack</span><br></pre></td></tr></table></figure>
<p>也可以输出一个命令执行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo `date` </span><br></pre></td></tr></table></figure>

<h2 id="查看文件的详细信息"><a href="#查看文件的详细信息" class="headerlink" title="查看文件的详细信息"></a>查看文件的详细信息</h2><p>Linux <code>stat</code>命令是一个命令行工具，用于显示关于文件的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stat [option] file</span><br></pre></td></tr></table></figure>
<p>常用的参数：</p>
<ul>
<li><code>-f</code>: 显示文件所在文件系统的信息</li>
</ul>
<h2 id="awk命令"><a href="#awk命令" class="headerlink" title="awk命令"></a>awk命令</h2><p><code>awk</code>就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。其名字跟创始人有关。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk [选项参数] &#x27;script&#x27; var=value file(s)</span><br></pre></td></tr></table></figure>

<p>常用的参数有：</p>
<ul>
<li><code>-F fs</code>: 指定输入文件折分隔符，默认为空格, <code>fs</code>是一个字符串或者是一个正则表达式。</li>
</ul>
<p>举例说明：使用”,”分割，打印file.txt的第一列和第四列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">awk -F, &#x27;&#123;print $1,$4&#125;&#x27; file.txt</span><br></pre></td></tr></table></figure>

<h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p><code>grep (global search regular expression(RE) and print out the line</code>,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep [参数选项] &#x27;搜寻字符串&#x27; filename</span><br></pre></td></tr></table></figure>
<p>常用的参数：</p>
<ul>
<li><code>-n</code>: 显示行号</li>
<li><code>-i</code> (ignore): 忽略大小写</li>
<li><code>-v</code> (invert): 只打印没有匹配到的</li>
<li><code>--color</code> :将匹配到的内容以颜色高亮显示</li>
<li><code>-A  n</code>：显示匹配到的字符串所在的行及其后n行，after</li>
<li><code>-B  n</code>：显示匹配到的字符串所在的行及其前n行，before</li>
<li><code>-C  n</code>：显示匹配到的字符串所在的行及其前后各n行，context</li>
</ul>
<h2 id="按列比较文件差异"><a href="#按列比较文件差异" class="headerlink" title="按列比较文件差异"></a>按列比较文件差异</h2><p>Linux <code>comm</code> 命令用于比较两个已排过序的文件。</p>
<p>这项指令会一列列地比较两个已排序文件的差异，并将其结果显示出来，如果没有指定任何参数，则会把结果分成 3 列显示：第 1 列仅是在第 1 个文件中出现过的列，第 2 列是仅在第 2 个文件中出现过的列，第 3 列则是在第 1 与第 2 个文件里都出现过的列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">comm [参数][第1个文件][第2个文件]</span><br></pre></td></tr></table></figure>

<p>常用的参数：</p>
<ul>
<li>-1 不显示只在第 1 个文件里出现过的列。</li>
<li>-2 不显示只在第 2 个文件里出现过的列。</li>
<li>-3 不显示只在第 1 和第 2 个文件里出现过的列。</li>
</ul>
<h2 id="查找文件位置"><a href="#查找文件位置" class="headerlink" title="查找文件位置"></a>查找文件位置</h2><p>which指令会在环境变量$PATH设置的目录里查找符合条件的文件。一般用来查找可执行文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">which [文件...]</span><br></pre></td></tr></table></figure>

<h2 id="nl命令"><a href="#nl命令" class="headerlink" title="nl命令"></a>nl命令</h2><p><code>nl (Number of Lines)</code> 将指定的文件添加行号标注后写到标准输出。如果不指定文件或指定文件为”-“ ，程序将从标准输入读取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl [选项]... [文件]...</span><br></pre></td></tr></table></figure>

<h2 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h2><p><code>sed</code>：Stream Editor文本流编辑</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed [option] &#x27;sed command&#x27; filename</span><br></pre></td></tr></table></figure>
<p>常用的sed动作：</p>
<ul>
<li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)</li>
<li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li>
<li>d ：删除，因为是删除啊，所以 d 后面通常不接任何东西，</li>
<li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行</li>
</ul>
<p>例子1：在 file 文件的第 88 行后添加一行以下内容”Hello world!”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &#x27;88a Hello world!&#x27; file</span><br></pre></td></tr></table></figure>

<p>例子2：在 file 文件的第 99 行前添加一行以下内容”Hello world!”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed &#x27;99i Hello world!&#x27; file</span><br></pre></td></tr></table></figure>

<p>例子3：删除 file 文件的第 88 - 99 行，显示行号并将结果输出到标准输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl file | sed 88,99d</span><br></pre></td></tr></table></figure>

<h2 id="文件排序"><a href="#文件排序" class="headerlink" title="文件排序"></a>文件排序</h2><p><code>sort</code> 命令用于将文本文件内容加以排序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sort [option] [file] </span><br></pre></td></tr></table></figure>
<p>常用的参数有：</p>
<ul>
<li><code>-b</code>（blank） 忽略每行前面开始出的空格字符。</li>
<li><code>-r</code> 以相反的顺序来排序</li>
<li><code>-n</code> 依照数值的大小排序。</li>
<li><code>-d</code> 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。</li>
<li><code>-f</code> 排序时，将小写字母视为大写字母。</li>
</ul>
<h2 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h2><p><code>expr</code>命令可以实现数值运算、数值或字符串比较、字符串匹配、字符串提取、字符串长度计算等功能。它还具有几个特殊功能，判断变量或参数是否为整数、是否为空、是否为0等。</p>
<h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><p><code>&quot;string : REGEX&quot;</code> 字符串匹配。要输出匹配到的字符串结果，需要使用”(“和”)“，否则返回的将是匹配到的字符串数量。</p>
<p>例子1：使用 expr 匹配 abcde 里以 ab 为开头的剩余的字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expr abcde : &#x27;ab\(.*\)&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h3><p><code>&quot;index string chars&quot;</code> 该表达式是从string中搜索chars中某个字符的位置，这个字符是string中最靠前的字符</p>
<p>例子2：使用 expr 的 index 查询 abcde 中 c 的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expr index abcde c</span><br></pre></td></tr></table></figure>
<h3 id="长度查询"><a href="#长度查询" class="headerlink" title="长度查询"></a>长度查询</h3><p><code>&quot;length string&quot;</code> 该表达式是返回string的长度，其中string不允许为空，否则将报错，所以可以用来判断变量是否为空。</p>
<h3 id="子串截取"><a href="#子串截取" class="headerlink" title="子串截取"></a>子串截取</h3><p><code>&quot;substr string pos len&quot;</code> 该表达式是从string中取出从pos位置开始长度为len的子字符串。如果pos或len为非正整数时，将返回空字符串。</p>
<p>例子3：使用 expr 的 substr 从字符串 abcde 截取下标 1 开始的长度为 3 的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">expr substr abcde 1 3</span><br></pre></td></tr></table></figure>

<h2 id="计算文件字数"><a href="#计算文件字数" class="headerlink" title="计算文件字数"></a>计算文件字数</h2><p>利用<code>wc</code>指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc [参数] 文件</span><br></pre></td></tr></table></figure>
<p>常用的参数有：</p>
<ul>
<li><code>-c</code>或–bytes或–chars 只显示Bytes数。</li>
<li><code>-l</code>或–lines 显示行数。</li>
<li><code>-w</code>或–words 只显示字数。</li>
</ul>
<h2 id="设置命令别名"><a href="#设置命令别名" class="headerlink" title="设置命令别名"></a>设置命令别名</h2><p>用户可利用alias，自定指令的别名。若仅输入alias，则可列出目前所有的别名设置。alias的效力仅及于该次登入的操作。若要每次登入是即自动设好别名，可在.profile或.cshrc中设定指令的别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias [别名]=[指令名称]</span><br></pre></td></tr></table></figure>
<p>例子1：给 <code>ls sub_dir</code> 命令设置别名 <code>la</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias la=&quot;ls sub_dir&quot;</span><br></pre></td></tr></table></figure>

<p>取消别名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unalias [别名]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Dev Tools</category>
      </categories>
      <tags>
        <tag>Linux Commands</tag>
      </tags>
  </entry>
  <entry>
    <title>git基本用法</title>
    <url>/2022/03/25/git/</url>
    <content><![CDATA[<h1 id="Git的常用命令"><a href="#Git的常用命令" class="headerlink" title="Git的常用命令"></a>Git的常用命令</h1><h2 id="Git跳过使用暂存区域并提交文件更改"><a href="#Git跳过使用暂存区域并提交文件更改" class="headerlink" title="Git跳过使用暂存区域并提交文件更改"></a>Git跳过使用暂存区域并提交文件更改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -am &quot;message&quot;</span><br></pre></td></tr></table></figure>
<p>其中，-a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区。</p>
<p>不过需要注意的是，新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。建议一般不要使用-a参数，正常的提交还是使用git add先将要改动的文件添加到暂存区，再用git commit 提交到本地版本库。</p>
<p>如果确保没有新添加的文件，可以直接通过<code>-a</code>参数，省去了<code>git add</code>的操作。</p>
<h2 id="重写最近的提交消息"><a href="#重写最近的提交消息" class="headerlink" title="重写最近的提交消息"></a>重写最近的提交消息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend </span><br></pre></td></tr></table></figure>

<p>输入上面的命令后会弹出vim框，编辑之后保存提交。</p>
<p>或者直接使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend -m &quot;message&quot;</span><br></pre></td></tr></table></figure>

<h2 id="回退之前的提交"><a href="#回退之前的提交" class="headerlink" title="回退之前的提交"></a>回退之前的提交</h2><p>我们用Git的时候有可能commit提交代码后，发现这一次commit的内容是有错误的，那么有两种处理方法：</p>
<ul>
<li>修改错误内容，再次commit一次</li>
<li>使用git reset 命令撤销这一次错误的commit</li>
</ul>
<p>第一种方法虽然直接，但是会多一种commit记录。</p>
<p><code>git reset</code> 命令用于回退版本，可以指定退回某一次提交的版本。其命令语法格式如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset [--soft | --mixed | --hard] [HEAD]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--soft</code> 修改版本库，保留暂存区，保留工作区</li>
<li><code>--mixed</code> 为默认，可以不用带该参数，用于重置暂存区的文件与上一次的提交(commit)保持一致，工作区文件内容保持不变。文件会回退到未 add（未暂存）的状态。修改版本库，修改暂存区，保留工作区</li>
<li><code>--hard</code> 参数撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交。注意：谨慎使用 <code>–hard</code> 参数，它会删除回退点之前的所有信息。修改版本库，修改暂存区，修改工作区。</li>
</ul>
<p>HEAD 说明：</p>
<ul>
<li><p>HEAD 表示当前版本</p>
</li>
<li><p>HEAD^ 上一个版本</p>
</li>
<li><p>HEAD^^ 上上一个版本</p>
</li>
<li><p>以此类推</p>
</li>
</ul>
<p>可以使用 ～数字表示</p>
<ul>
<li><p>HEAD~0 表示当前版本</p>
</li>
<li><p>HEAD~1 上一个版本</p>
</li>
<li><p>HEAD^2 上上一个版本</p>
</li>
<li><p>以此类推</p>
</li>
</ul>
<h2 id="缓存stash的使用"><a href="#缓存stash的使用" class="headerlink" title="缓存stash的使用"></a>缓存stash的使用</h2><p>如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急Bug，那么使用<code>git stash</code>就可以将你当前未提交到本地（和服务器）的代码推入到Git的栈中。等到修完Bug，提交到服务器上后，再使用<code>git stash apply</code>将以前一半的工作应用回来。这样会避免log上会有多余不必要的记录。</p>
<h3 id="stash当前修改"><a href="#stash当前修改" class="headerlink" title="stash当前修改"></a>stash当前修改</h3><p><code>git stash</code> 会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。补充：stash是本地的，不会通过git push命令上传到git server上。</p>
<h3 id="重新应用缓存的stash"><a href="#重新应用缓存的stash" class="headerlink" title="重新应用缓存的stash"></a>重新应用缓存的stash</h3><p><code>git stash pop</code> 命令恢复之前缓存的工作目录，这个指令将缓存堆栈中的第一个stash删除，并将对应修改应用到当前的工作目录下。</p>
<p>你也可以使用<code>git stash apply</code>命令，将缓存堆栈中的stash多次应用到工作目录中，但并不删除stash拷贝。</p>
<h3 id="查看现有stash"><a href="#查看现有stash" class="headerlink" title="查看现有stash"></a>查看现有stash</h3><p>可以使用<code>git stash list</code>命令，查看所有的stash情况。</p>
<h3 id="移除stash"><a href="#移除stash" class="headerlink" title="移除stash"></a>移除stash</h3><p>可以使用<code>git stash drop</code>命令，后面可以跟着stash名字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</span><br><span class="line">stash@&#123;1&#125;: WIP on master: c264051 Revert &quot;added file_size&quot;</span><br><span class="line">stash@&#123;2&#125;: WIP on master: 21d80a5 added number to log</span><br><span class="line"></span><br><span class="line">$ git stash drop stash@&#123;0&#125;</span><br><span class="line">Dropped stash@&#123;0&#125; (364e91f3f268f0900bc3ee613f9f733e82aaed43)</span><br></pre></td></tr></table></figure>
<p>或者使用<code>git stash clear</code>命令，删除所有缓存的stash。</p>
<h3 id="从stash创建分支"><a href="#从stash创建分支" class="headerlink" title="从stash创建分支"></a>从stash创建分支</h3><p>运行<code>git stash branch</code>，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。</p>
<p>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p>
<h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p><code>git rm</code> 命令用于删除文件。</p>
<ul>
<li>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>。</li>
<li>如果想把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <code>--cached</code> 选项即可</li>
<li>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm –r * </span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="查看历史提交记录"><a href="#查看历史提交记录" class="headerlink" title="查看历史提交记录"></a>查看历史提交记录</h2><p><code>git log</code> 命令可用于查看历史提交记录，支持多种不同格式的查看</p>
<ul>
<li><p>查看最近n次的提交历史: <code>git log -n</code></p>
</li>
<li><p>显示每次提交所引入的差异: <code>git log -p</code></p>
</li>
<li><p>统计总结: <code>git log stat</code></p>
</li>
<li><p>显示提交说明中包含指定字符串的提交: <code>git log --grep &#123;字符串&#125;</code></p>
</li>
<li><p>格式化查看: <code>git log --pretty=format:&quot;%h&quot;</code></p>
<p>  这里为常用的一些格式化占位符：</p>
<ul>
<li><p><code>%H</code>: commit hash</p>
</li>
<li><p><code>%h</code>: 缩短的commit hash</p>
</li>
<li><p><code>%T</code>: tree hash</p>
</li>
<li><p><code>%t</code>: 缩短的 tree hash</p>
</li>
<li><p><code>%an</code>: 作者名字</p>
</li>
<li><p><code>%ae</code>: 作者邮箱</p>
</li>
<li><p><code>%cd</code>: 提交日期 (–date&#x3D; 制定的格式)</p>
</li>
<li><p><code>%s</code>: commit信息标题</p>
</li>
</ul>
</li>
</ul>
<p>“</p>
<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）</p>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p>在 Git 中列出已有的标签非常简单，只需要输入 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag 或者 git tag -l</span><br></pre></td></tr></table></figure>

<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag &#123;tagName&#125;</span><br></pre></td></tr></table></figure>
<p>有一些选项:</p>
<ul>
<li><code>-a</code> 表示创建附注信息</li>
<li><code>-m</code> 表示为附注标签指定一条信息</li>
</ul>
<h3 id="查看标签提交信息"><a href="#查看标签提交信息" class="headerlink" title="查看标签提交信息"></a>查看标签提交信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show &#123;tagName&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag -d &#123;tagName&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Dev Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>interview_c++</title>
    <url>/2022/03/17/interview-Cpp/</url>
    <content><![CDATA[<h3 id="简述-vector-的实现原理以及扩容机制"><a href="#简述-vector-的实现原理以及扩容机制" class="headerlink" title="简述 vector 的实现原理以及扩容机制"></a>简述 vector 的实现原理以及扩容机制</h3><p>vector 是最常用的容器之一，其底层所采用的数据结构就只是一段连续的线性内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//_Alloc 表示内存分配器，此参数几乎不需要我们关心</span><br><span class="line">template &lt;class _Ty, class _Alloc = allocator&lt;_Ty&gt;&gt;</span><br><span class="line">class vector&#123;</span><br><span class="line">    ...</span><br><span class="line">protected:</span><br><span class="line">    pointer _Myfirst;</span><br><span class="line">    pointer _Mylast;</span><br><span class="line">    pointer _Myend;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/17/interview-Cpp/vector.png"></p>
<p>其中，_Myfirst 指向的是 vector 容器对象的起始字节位置；_Mylast 指向当前最后一个元素的末尾字节；_myend 指向整个 vector 容器所占用内存空间的末尾字节。 </p>
<p>当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步： </p>
<ul>
<li>完全弃用现有的内存空间，重新申请更大的内存空间； </li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中； </li>
<li>最后将旧的内存空间释放。</li>
</ul>
<p>这也就解释了，为什么 vector 容器在进行扩容后，与其相关的指针、引用以及迭代器可能会失效的原因。</p>
<p>vector 容器扩容时，不同的编译器申请更多内存空间的量是不同的。以 VS 为例，它会扩容现有容器容量的 50%。 </p>
<h3 id="C-中为什么要使用智能指针？"><a href="#C-中为什么要使用智能指针？" class="headerlink" title="C++ 中为什么要使用智能指针？"></a>C++ 中为什么要使用智能指针？</h3><p>动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。</p>
<p>析构函数：当对象结束其生命周期，如对象所在的函数已调用完毕时，系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作，如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void UseRawPointer()&#123;</span><br><span class="line">    // Using a raw pointer -- not recommended.</span><br><span class="line">    Song* pSong = new Song(L Nothing on You , L Bruno Mars ); </span><br><span class="line"></span><br><span class="line">    // Use pSong...</span><br><span class="line"></span><br><span class="line">    // Don&#x27;t forget to delete!</span><br><span class="line">    delete pSong;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void UseSmartPointer()&#123;</span><br><span class="line">    // Declare a smart pointer on stack and pass it the raw pointer.</span><br><span class="line">    unique_ptr&lt;Song&gt; song2(new Song(L Nothing on You , L Bruno Mars ));</span><br><span class="line"></span><br><span class="line">    // Use song2...</span><br><span class="line">    wstring s = song2-&gt;duration_;</span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">&#125; // song2 is deleted automatically here.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>shared_ptr，支持多个指针指向同一个对象，使用引用计数，每一个shared_ptr的拷贝都指向相同的内存。需要注意避免循环引用的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;A&gt; a1(new A());</span><br><span class="line">std::shared_ptr&lt;A&gt; a2 = a1;//编译正常，允许所有权的共享</span><br></pre></td></tr></table></figure>
</li>
<li><p>unique_ptr，顾名思义，同一时刻只能有一个unique_ptr指向给定对象。利用RAII的特性，当unique_ptr指针离开作用域时，会释放其所指向的对象。同时，禁止拷贝语义，仅支持移动语义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;A&gt; a1(new A());</span><br><span class="line">std::unique_ptr&lt;A&gt; a2 = a1;//编译报错，不允许复制</span><br><span class="line">std::unique_ptr&lt;A&gt; a3 = std::move(a1);//可以转移所有权，所有权转义后a1不再拥有任何指向</span><br></pre></td></tr></table></figure>
</li>
<li><p>weak_ptr，是对对象的一种弱引用，不会增加对象的引用计数，主要用于解决shared_ptr互相引用时引发的死锁问题。,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;A&gt; a1(new A());</span><br><span class="line">std::weak_ptr&lt;A&gt; weak_a1 = a1;//不增加引用计数</span><br></pre></td></tr></table></figure>

<ul>
<li>循环引用的现象可以通过让引用链上的一方持用普通指针或弱智能指针 (weak_ptr) 来解决。</li>
</ul>
</li>
</ul>
<h3 id="简单实现一个智能指针，赋值操作-x3D-时做了什么？是不是并发安全的？"><a href="#简单实现一个智能指针，赋值操作-x3D-时做了什么？是不是并发安全的？" class="headerlink" title="简单实现一个智能指针，赋值操作&#x3D;时做了什么？是不是并发安全的？"></a>简单实现一个智能指针，赋值操作&#x3D;时做了什么？是不是并发安全的？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SmartPointer &#123;</span><br><span class="line">private:</span><br><span class="line">    T* _ptr;</span><br><span class="line">    size_t* _count;</span><br><span class="line">public:</span><br><span class="line">    SmartPointer(T* ptr = nullptr) :</span><br><span class="line">            _ptr(ptr) &#123;</span><br><span class="line">        if (_ptr) &#123;</span><br><span class="line">            _count = new size_t(1);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            _count = new size_t(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SmartPointer(const SmartPointer&amp; ptr) &#123;</span><br><span class="line">        if (this != &amp;ptr) &#123;</span><br><span class="line">            this-&gt;_ptr = ptr._ptr;</span><br><span class="line">            this-&gt;_count = ptr._count;</span><br><span class="line">            (*this-&gt;_count)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SmartPointer&amp; operator=(const SmartPointer&amp; ptr) &#123;</span><br><span class="line">        if (this-&gt;_ptr == ptr._ptr) &#123;</span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this-&gt;_ptr) &#123;</span><br><span class="line">            (*this-&gt;_count)--;</span><br><span class="line">            if (this-&gt;_count == 0) &#123;</span><br><span class="line">                delete this-&gt;_ptr;</span><br><span class="line">                delete this-&gt;_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this-&gt;_ptr = ptr._ptr;</span><br><span class="line">        this-&gt;_count = ptr._count;</span><br><span class="line">        (*this-&gt;_count)++;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; operator*() &#123;</span><br><span class="line">        assert(this-&gt;_ptr == nullptr);</span><br><span class="line">        return *(this-&gt;_ptr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* operator-&gt;() &#123;</span><br><span class="line">        assert(this-&gt;_ptr == nullptr);</span><br><span class="line">        return this-&gt;_ptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~SmartPointer() &#123;</span><br><span class="line">        (*this-&gt;_count)--;</span><br><span class="line">        if (*this-&gt;_count == 0) &#123;</span><br><span class="line">            delete this-&gt;_ptr;</span><br><span class="line">            delete this-&gt;_count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t use_count()&#123;</span><br><span class="line">        return *this-&gt;_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="简述-C-右值引用与转移语义"><a href="#简述-C-右值引用与转移语义" class="headerlink" title="简述 C++ 右值引用与转移语义"></a>简述 C++ 右值引用与转移语义</h3><p>右值引用 (Rvalue Referene) 是 C++ 新标准 (C++11) 中引入的新特性 , 它实现了转移语义 (Move Sementics) 和完美转发 (Perfect Forwarding)。它的主要目的有两个方面： </p>
<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 </li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
<p>首先与左值不同，右值是非常短暂的，它要么是字面常量（如，42），要么是在表达式求值过程中创建的临时对象（如，i*2）。需要注意的是，所有的变量都是左值。 </p>
<p>左值的声明符号为&amp;， 为了和左值区分，右值的声明符号为&amp;&amp;。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void process_value(int&amp; i) &#123; </span><br><span class="line">std::cout &lt;&lt;  LValue processed:   &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void process_value(int&amp;&amp; i) &#123; </span><br><span class="line">std::cout &lt;&lt;  RValue processed:   &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() &#123; </span><br><span class="line">int a = 0; </span><br><span class="line">process_value(a); </span><br><span class="line">process_value(1); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LValue processed: 0 </span><br><span class="line">RValue processed: 1</span><br></pre></td></tr></table></figure>

<p>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。 </p>
<h3 id="C-的move-是什么"><a href="#C-的move-是什么" class="headerlink" title="C++的move()是什么"></a>C++的move()是什么</h3><p>转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。 转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。 </p>
<p>此外，这个函数可以以非常简单的方式将左值引用转换为右值引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void ProcessValue(int&amp; i) &#123; </span><br><span class="line">std::cout &lt;&lt; &quot;LValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void ProcessValue(int&amp;&amp; i) &#123; </span><br><span class="line">std::cout &lt;&lt; &quot;RValue processed: &quot; &lt;&lt; i &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">int main() &#123; </span><br><span class="line">int a = 0; </span><br><span class="line">ProcessValue(a); </span><br><span class="line">ProcessValue(std::move(a)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 结果</span><br><span class="line">LValue processed: 0 </span><br><span class="line">RValue processed: 0</span><br></pre></td></tr></table></figure>

<h3 id="C-的forward-，即完美转发是什么？"><a href="#C-的forward-，即完美转发是什么？" class="headerlink" title="C++的forward()，即完美转发是什么？"></a>C++的forward()，即完美转发是什么？</h3><p>所谓<a href="https://murphypei.github.io/blog/2018/08/cpp-right-reference">完美转发</a>，就是为了让我们在传递参数的时候，保持原来的参数类型（左引用保持左引用，右引用保持右引用）。 </p>
<h3 id="C-多态是如何实现的？"><a href="#C-多态是如何实现的？" class="headerlink" title="C++多态是如何实现的？"></a>C++多态是如何实现的？</h3><p>父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”。 </p>
<p>当类中存在虚函数时，编译器会在类中自动生成一个虚函数表，虚函数表是一个存储类成员函数指针的数据结构，由编译器自动生成和维护，virtual 修饰的成员函数会被编译器放入虚函数表中。当存在虚函数时，编译器会为对象自动生成一个指向虚函数表的指针（通常称之为 vptr 指针）<br>举例说明： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // 父类虚函数必须要有 virtual 关键字</span><br><span class="line">    virtual void fun()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;  父类  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Child : public Parent</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // 子类有没有 virtual 关键字都可以</span><br><span class="line">    void fun()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;  子类  &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Parent *p = NULL; // 创建一个父类的指针</span><br><span class="line">    Parent parent;</span><br><span class="line">    Child child;</span><br><span class="line">    p = &amp;parent; // 指向父类的对象</span><br><span class="line">    p-&gt;fun(); // 执行的是父类的 fun() 函数</span><br><span class="line">    p = &amp;child; // 指向子类的对象</span><br><span class="line">    p-&gt;fun(); // 执行的是子类的 fun() 函数</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-里什么是万能引用？"><a href="#C-里什么是万能引用？" class="headerlink" title="C++里什么是万能引用？"></a>C++里什么是万能引用？</h3><p>C++ 11中有<a href="https://theonegis.github.io/cxx/C-%E4%B8%AD%E7%9A%84%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/">万能引用</a>（Universal Reference）的概念：使用<code>T&amp;&amp;</code>类型的形参既能绑定右值，又能绑定左值。只有发生类型推导的时候，<code>T&amp;&amp;</code>才表示万能引用；否则，表示右值引用。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void func(T&amp;&amp; param) &#123;</span><br><span class="line">    cout &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int num = 2019;</span><br><span class="line">    func(num);</span><br><span class="line">    func(2019);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">volatile</a> 指出其修饰的变量是随时可能发生变化的，每次使用它的时候必须从变量的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而一般来说，由于编译器发现两次从变量 i 读数据的代码之间的代码没有对变量 i 进行过操作，它会自动把上次读的数据放在变量 b 中。而不是重新从 i 里面读：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile int i=10;</span><br><span class="line">int a = i;</span><br><span class="line">...</span><br><span class="line">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span><br><span class="line">int b = i;</span><br></pre></td></tr></table></figure>

<h3 id="C-项目中的extern-quot-C-quot-关键字"><a href="#C-项目中的extern-quot-C-quot-关键字" class="headerlink" title="C++项目中的extern &quot;C&quot;关键字"></a>C++项目中的<code>extern &quot;C&quot;</code>关键字</h3><p>extern是C&#x2F;C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。</p>
<p>与extern对应的关键字是 static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C”修饰。</p>
<h3 id="什么叫动态联编？"><a href="#什么叫动态联编？" class="headerlink" title="什么叫动态联编？"></a>什么叫动态联编？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        virtual void output()                        //将基类成员函数定义为虚函数</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt;  A\n ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        virtual void output()</span><br><span class="line">        &#123;</span><br><span class="line">                cout &lt;&lt;  B\n ;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        A a;</span><br><span class="line">        B b;</span><br><span class="line"></span><br><span class="line">        A *p1 = &amp;a;                                //如果是虚函数，则根据指针指向的对象的具体类型来确定要调用的函数版本</span><br><span class="line">        A *p2 = &amp;b;                                //如果不是虚函数，则根据指针类型确定要调用的函数版本，引用也是一样道理</span><br><span class="line"></span><br><span class="line">        p1-&gt;output();                        //输出A</span><br><span class="line">        p2-&gt;output();                        //输出B</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是虚函数，则根据指针类型确定要调用的函数版本，因此这在编译时就能知道，所以编译器对非虚函数使用静态联编。而对于虚函数，只能在程序运行时才能知道具体指向的对象的类型，所以编译器对虚方法使用的是动态联编。在基类中的虚函数，在派生类中也会自动为虚函数，而无论派生类中有没有添加关键字virtual。 </p>
<p>调用虚函数时，程序将首先查看对象的隐藏指针成员，根据它得到虚函数表，从而得到特定的要执行的函数的入口地址。 </p>
<p>从虚函数的工作原理可以看出，非虚函数的效率较高。虚函数有额外的开销（存储空间和查找地址的时间开销等）。 </p>
<h3 id="简述-new-与-malloc-的区别"><a href="#简述-new-与-malloc-的区别" class="headerlink" title="简述 new 与 malloc 的区别"></a>简述 new 与 malloc 的区别</h3><ul>
<li><p>返回类型安全性不同 </p>
<p>  new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故new是符合类型安全性的操作符。malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。 </p>
</li>
<li><p>内存分配失败时的返回值不同 </p>
<p>  new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL。malloc分配内存失败时返回NULL。 </p>
</li>
<li><p>是否需要指定内存大小不同 </p>
<p>  使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。malloc则需要显式地指出所需内存的尺寸。 </p>
</li>
<li><p>new中会调用了对象的构造函数。</p>
</li>
</ul>
<h3 id="C-中new能否被重载，如何在指定位置处分配内存空间？"><a href="#C-中new能否被重载，如何在指定位置处分配内存空间？" class="headerlink" title="C++中new能否被重载，如何在指定位置处分配内存空间？"></a>C++中new能否被重载，如何在指定位置处分配内存空间？</h3><ul>
<li>new operator和operator new的关系</li>
</ul>
<p>new operator：指我们在C++里通常用到的关键字，比如A* a &#x3D; new A;<br>operator new：它是一个操作符，并且可被重载(类似加减乘除的操作符重载)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A* a = new A；</span><br></pre></td></tr></table></figure>

<p>我们知道这里分为三步：1.分配内存，2.调用A()构造对象，3. 返回分配指针。事实上，分配内存这一操作就是由operator new(size_t)来完成的，如果类A重载了operator new，那么将调用A::operator new(size_t )，否则调用全局::operator new(size_t )，后者由C++默认提供。因此前面的步骤也就是： </p>
<ol>
<li>调用operator new (sizeof(A)) </li>
<li>调用A:A() </li>
<li>返回指针</li>
</ol>
<ul>
<li>operator new的三种形式 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throwing (1)    </span><br><span class="line">void* operator new (std::size_t size) throw (std::bad_alloc);</span><br><span class="line"></span><br><span class="line">nothrow (2) </span><br><span class="line">void* operator new (std::size_t size, const std::nothrow_t&amp; nothrow_value) throw();</span><br><span class="line"></span><br><span class="line">placement (3)   </span><br><span class="line">void* operator new (std::size_t size, void* ptr) throw();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>(1)(2)的区别仅是是否抛出异常，当分配失败时，前者会抛出bad_alloc异常，后者返回null，不会抛出异常。它们都分配一个固定大小的连续内存。 </p>
<p>（3）是placement new，它也是对operator new的一个重载，它多接收一个ptr参数，但它只是简单地返回ptr。事实上，它可以实现在ptr所指地址上构建一个对象(通过调用其构造函数)，这在内存池技术上有广泛应用。例如： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new(p) A(); //也可用A(5)等有参构造函数</span><br></pre></td></tr></table></figure>
<h3 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h3><ul>
<li><p>static </p>
<ul>
<li><p>隐藏</p>
<p>  未加static的全局变量和函数是全局可见的，当同时编译多个文件时，文件之间的变量或者函数可能会有命名冲突的情况，可以使用static来隐藏，使得变量或函数只能在该文件可见。</p>
</li>
<li><p>改变变量的存储方式和生命周期</p>
<p>  static关键字会使得它修饰的变量存储在静态存储区，在程序开始运行时就初始化，并且会一直存在直到程序结束，并且不会被再次初始化。</p>
</li>
<li><p>对类成员声明 static</p>
<p>  同样有上述的几种功能，对该成员函数or静态变量进行隐藏以及改变其生命周期，并且所有的对象共用一个静态成员函数或静态变量。</p>
<p>  另外静态内部类也是实现单例模式的一种方法，其优点在于外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化INSTANCE，故而不占内存，只有当<code>getlnstance()</code>方法第一次被调用时，才会去初始化INSTANCE。</p>
</li>
</ul>
</li>
<li><p>const </p>
<p>  const用来表示常量，即不允许他修饰的变量被修改，在进行参数传递的时候，也常常使用const修饰引用来传参，既保证了不复制参数，又防止对象被修改。</p>
<p>  C++中还可以用const修饰成员函数和数据成员来达到封装的目的，不允许使用const修饰的成员函数来修改数据成员。</p>
</li>
<li><p>extern </p>
<p>  extern是C&#x2F;C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用（只是声明，不分配内存）</p>
</li>
</ul>
<h3 id="C-类型转换的关键字，它们各自的特点是什么？"><a href="#C-类型转换的关键字，它们各自的特点是什么？" class="headerlink" title="C++类型转换的关键字，它们各自的特点是什么？"></a>C++类型转换的关键字，它们各自的特点是什么？</h3><p>（1）static_cast 静态转换 主要用于C++中内置的基本数据类型之间的转换，在编译期间处理。例如：<code>int m=10; double n=static_cast&lt;int&gt; m; </code></p>
<p>（2）reinterpret_cast 重解释类型转换 类似C中的强制类型转换，可以转化任何的内置数据类型为其他的类型。例如从整形到指针</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a=10; </span><br><span class="line">double* b=reinterpret_cast&lt;double*&gt;(a); //b的转换结果为0x0000000a</span><br></pre></td></tr></table></figure>

<p>（3）dynamic_cast 动态类型转换 在运行的时候执行，通常用于基类和派生类之间的转换.转换时会进行类型安全检查。dynamic_cast使用场景与static相似，在类层次结构中使用时，上行转换和static_cast没有区别，都是安全的；下行转换时，dynamic_cast会检查转换的类型，相比static_cast更安全。如果是，则能进行正确的转换，获得对应的值；否则返回NULL，如果是引用，则在运行时就会抛出异常； </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 实例一</span><br><span class="line">class A &#123; virtual void f()&#123;&#125;; &#125;;</span><br><span class="line">class B : public A&#123; &#125;;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    A* pA = new B;</span><br><span class="line">    B* pB = dynamic_cast&lt;B*&gt;(pA); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例二</span><br><span class="line">class B</span><br><span class="line">&#123;</span><br><span class="line">    virtual void f()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">class D : public B</span><br><span class="line">&#123;</span><br><span class="line">    virtual void f()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    B* pb = new D;   // unclear but ok</span><br><span class="line">    B* pb2 = new B;</span><br><span class="line">    D* pd = dynamic_cast&lt;D*&gt;(pb);   // ok: pb actually points to a D</span><br><span class="line">    D* pd2 = dynamic_cast&lt;D*&gt;(pb2);   // pb2 points to a B not a D, now pd2 is NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（4）const_cast 去常转换 编译时执行，它可以把一个不是常属性的转换成常属性的,同时它也可以对一个本是常属性的类型进行去常. </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const char *pc;</span><br><span class="line">char *p = const_cast&lt;char*&gt;(pc);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>reinterpret_cast和dynamic_cast的区别？ </p>
<p>  dynamic_cast: 动态类型转换，可以在父类与子类之间进行安全的类型转换，运行时类型检查，并且可以知道自己子类的类型 </p>
<p>  reinterpret_cast: 强制类型转换，可以在不同类型之间进行强制转换，很难保证移植性。</p>
</li>
</ul>
<h3 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h3><ul>
<li>Auto：用来进行类型推导 </li>
<li>Nullptr：传统的 C++ 无法区分 NULL 和 0，有的编译器会把 NULL 定义为 void*的指针，有的直接就定义为0了，这就会导致一系列的问题，比如在重载时会发生混乱，所以 C++11 引入了 nullptr 来区分空指针和0。 </li>
<li>基于范围的 for 循环：auto iter:arr </li>
<li>智能指针：C++11 引入智能指针主要是因为没有自动的内存回收机制。 </li>
<li>右值引用</li>
</ul>
<h3 id="C-STL的erase-陷阱"><a href="#C-STL的erase-陷阱" class="headerlink" title="C++STL的erase()陷阱"></a>C++STL的erase()陷阱</h3><ul>
<li>list,set,map容器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 正确写法1：通过erase方法的返回值来获取下一个元素的位置</span><br><span class="line">std::list&lt; int&gt; List;</span><br><span class="line">std::list&lt; int&gt;::iterator itList;</span><br><span class="line">for( itList = List.begin(); itList != List.end(); )</span><br><span class="line">&#123;</span><br><span class="line">    if( WillDelete( *itList) )</span><br><span class="line">    &#123;</span><br><span class="line">            itList = List.erase( itList);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">            itList++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正确写法2：在调用erase方法之前先使用 “++”来获取下一个元素的位置</span><br><span class="line">std::list&lt; int&gt; List;</span><br><span class="line">std::list&lt; int&gt;::iterator itList;</span><br><span class="line">for( itList = List.begin(); itList != List.end(); )</span><br><span class="line">&#123;</span><br><span class="line">    if( WillDelete( *itList) )</span><br><span class="line">    &#123;</span><br><span class="line">        List.erase( itList++);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        itList++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 错误写法：由于在调用erase方法以后，该元素的位置已经被删除，如果在根据这个旧的位置来获取下一个位置，则会出现异常</span><br><span class="line">std::list&lt; int&gt; List;</span><br><span class="line">std::list&lt; int&gt;::iterator itList;</span><br><span class="line">for( itList = List.begin(); itList != List.end(); itList++)</span><br><span class="line">&#123;</span><br><span class="line">    if( WillDelete( *itList) )</span><br><span class="line">    &#123;</span><br><span class="line">        List.erase( itList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>vector、deque容器 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::vector&lt; int&gt; Vec;</span><br><span class="line">std::vector&lt; int&gt;::iterator itVec;</span><br><span class="line">for( itVec = Vec.begin(); itVec != Vec.end(); )</span><br><span class="line">&#123;</span><br><span class="line">    if( WillDelete( *itVec) )</span><br><span class="line">    &#123;</span><br><span class="line">        itVec = Vec.erase(itVec);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        itList++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总结 :</p>
<ul>
<li>对于关联容器(如map, set, multimap,multiset)，删除当前的iterator，仅仅会使当前的iterator失效，只要在erase时，递增当前iterator即可。这是因为map之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。 </li>
<li>对于序列式容器(如vector,deque)，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。还好erase方法可以返回下一个有效的iterator。 </li>
<li>对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，因此上面两种方法都可以使用。</li>
</ul>
<h3 id="C-中虚函数与纯虚函数的区别"><a href="#C-中虚函数与纯虚函数的区别" class="headerlink" title="C++ 中虚函数与纯虚函数的区别"></a>C++ 中虚函数与纯虚函数的区别</h3><p>纯虚函数声明如下： <code>virtual void funtion1()=0;</code> 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。 </p>
<p>虚函数声明如下：<code>virtual ReturnType FunctionName(Parameter)</code> 虚函数必须实现。</p>
<h3 id="C-中为什么析构函数必须是虚函数？构造函数不能是虚的？"><a href="#C-中为什么析构函数必须是虚函数？构造函数不能是虚的？" class="headerlink" title="C++中为什么析构函数必须是虚函数？构造函数不能是虚的？"></a>C++中为什么析构函数必须是虚函数？构造函数不能是虚的？</h3><p>当基类的析构函数被定义成虚函数时，我们再来删除这个指针时，先调用派生类的析构函数，再调用基类的析构函数，很明显这才是我们想要的结果。因为指针指向的是一个派生类实例，我们销毁这个实例时，肯定是希望即清理派生类自己的资源，同时又清理从基类继承过来的资源。而当基类的析构函数为非虚函数时，删除一个基类指针指向的派生类实例时，只清理了派生类从基类继承过来的资源，而派生类自己独有的资源却没有被清理，这显然不是我们希望的。 </p>
<p>所以说，如果一个类会被其他类继承，那么我们有必要将被继承的类（基类）的析构函数定义成虚函数。这样，释放基类指针指向的派生类实例时，清理工作才能全面进行，才不会发生内存泄漏。<br>构造自己时，对象还不存在。虚函数需要有虚函数表，但这个表因为在构造阶段是不存在的，至少还没分配内存，无法实现定义要求。 </p>
<h3 id="简述-C-编译的过程"><a href="#简述-C-编译的过程" class="headerlink" title="简述 C++ 编译的过程"></a>简述 C++ 编译的过程</h3><ul>
<li><p>预处理 </p>
<p>  读取c源程序，对其中的伪指令（以# 开头的指令）和特殊符号进行处理。如： </p>
<p>  （1）宏定义指令，<code># define Name TokenString，# undef</code>等 </p>
<p>  （2）条件编译指令，如<code># ifdef，# ifndef，# else，# elif，# endif</code>等。 </p>
<p>  （3）头文件包含指令，如<code># include FileName</code> 或者<code># include &lt; FileName&gt; </code>等。 </p>
<p>  （4）特殊符号 </p>
</li>
<li><p>编译、优化阶段 </p>
<p>  通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。 </p>
</li>
<li><p>汇编 </p>
<p>  汇编过程实际上指把汇编语言代码翻译成目标机器指令的过程。对于被翻译系统处理的每一个C语言源程序，都将最终经过这一处理而得到相应的目标文件。 </p>
</li>
<li><p>链接 </p>
<p>  链接器利用编译器产生的目标文件，生成最终可执行程序。也即将在一个文件中引用的符号同该符号在另外一个文件中的定义连接起来，使得所有的这些目标文件成为一个能够被操作系统装入执行的统一整体。可以使用ldd或者readelf命令查看一个可执行文件链接了哪些目标文件。 </p>
<p>  根据开发人员指定的同库函数的链接方式的不同，链接处理可分为两种： </p>
<ol>
<li><p>静态链接 </p>
<p> 在这种链接方式下，函数的代码将从其所在的静态链接库中被拷贝到最终的可执行程序中。这样该程序在被执行时这些代码将被装入到该进程的虚拟地址空间中。静态链接库实际上是一个目标文件的集合，其中的每个文件含有库中的一个或者一组相关函数的代码。 </p>
</li>
<li><p>动态链接 </p>
<p> 在此种方式下，函数的代码被放到称作是动态链接库或共享对象的某个目标文件中。链接程序此时所做的只是在最终的可执行程序中记录下共享对象的名字以及其它少量的登记信息。在此可执行文件被执行时，动态链接库的全部内容将被映射到运行时相应进程的虚地址空间。动态链接程序将根据可执行程序中记录的信息找到相应的函数代码。 </p>
<p> 对于可执行文件中的函数调用，可分别采用动态链接或静态链接的方法。使用动态链接能够使最终的可执行文件比较短小，并且当共享对象被多个进程使用时能节约一些内存，因为在内存中只需要保存一份此共享对象的代码。但并不是使用动态链接就一定比使用静态链接要优越。在某些情况下动态链接可能带来一些性能上损害。</p>
</li>
</ol>
</li>
</ul>
<h3 id="C-中什么是菱形继承问题？"><a href="#C-中什么是菱形继承问题？" class="headerlink" title="C++ 中什么是菱形继承问题？"></a>C++ 中什么是菱形继承问题？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;using namespace std;</span><br><span class="line"></span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int iValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B :public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void bPrintf()&#123; cout &lt;&lt;  This is class B  &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class C :public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void cPrintf()&#123; cout &lt;&lt;  This is class C  &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D :public B, public C</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void dPrintf()&#123; cout &lt;&lt;  This is class D  &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">    D d;</span><br><span class="line">//    cout &lt;&lt; d.iValue &lt;&lt; endl; //错误，不明确的访问</span><br><span class="line">    cout &lt;&lt; d.A::iValue &lt;&lt; endl; //正确</span><br><span class="line">    cout &lt;&lt; d.B::iValue &lt;&lt; endl; //正确</span><br><span class="line">    cout &lt;&lt; d.C::iValue &lt;&lt; endl; //正确</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类B C都继承了类A的iValue成员,因此类B C都有一个成员变量iValue ，而类D又继承了B C，这样类D就有一个重名的成员 iValue(一个是从类B中继承过来的，一个是从类C中继承过来的).在主函数中调用d.iValue 因为类D有一个重名的成员iValue编译器不知道调用 从谁继承过来的iValue所以就产生的二义性的问题.正确的做法应该是加上作用域限定符 d.B::iValue 表示调用从B类继承过来的iValue。不过 类D的实例中就有多个iValue的实例，就会占用内存空间。所以C++中就引用了虚基类的概念，来解决这个问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A  </span><br><span class="line">&#123;  </span><br><span class="line">    public:  </span><br><span class="line">    int iValue;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">class B:virtual public A  </span><br><span class="line">&#123;  </span><br><span class="line">    public:  </span><br><span class="line">    void bPrintf()&#123;cout&lt;&lt; This is class B &lt;&lt;endl;&#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">class C:virtual public A  </span><br><span class="line">&#123;  </span><br><span class="line">    public:  </span><br><span class="line">    void cPrintf()&#123;cout&lt;&lt; This is class C &lt;&lt;endl;&#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">class D:public B,public C  </span><br><span class="line">&#123;  </span><br><span class="line">    public:  </span><br><span class="line">    void dPrintf()&#123;cout&lt;&lt; This is class D &lt;&lt;endl;&#125;;  </span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line">void main()  </span><br><span class="line">&#123;  </span><br><span class="line">    D d;  </span><br><span class="line">    cout&lt;&lt;d.iValue&lt;&lt;endl; //正确  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/17/interview-Cpp/diamond.png"></p>
<p>在继承的类的前面加上virtual关键字表示被继承的类是一个虚基类，它的被继承成员在派生类中只保留一个实例。例如iValue这个成员，从类 D这个角度上来看，它是从类B与类C继承过来的，而类B C又是从类A继承过来的，但它们只保留一个副本。因此在主函数中调用d.iValue时就不会产生错误。 </p>
<h3 id="C-中的RAII机制是什么？"><a href="#C-中的RAII机制是什么？" class="headerlink" title="C++中的RAII机制是什么？"></a>C++中的RAII机制是什么？</h3><p>RAII是Resource Acquisition Is Initialization（“资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。 </p>
<p>由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。</p>
<h3 id="C-中有没有垃圾回收机制（garbage-collection简称gc机制）？"><a href="#C-中有没有垃圾回收机制（garbage-collection简称gc机制）？" class="headerlink" title="C++中有没有垃圾回收机制（garbage collection简称gc机制）？"></a>C++中有没有垃圾回收机制（garbage collection简称gc机制）？</h3><p>  没有，依靠程序员自己手动进行无用内存的释放。 </p>
<h3 id="C-的伙伴系统是什么？"><a href="#C-的伙伴系统是什么？" class="headerlink" title="C++的伙伴系统是什么？"></a>C++的伙伴系统是什么？</h3><ul>
<li><a href="https://www.cnblogs.com/xkfz007/archive/2012/11/08/2760148.html">https://www.cnblogs.com/xkfz007/archive/2012/11/08/2760148.html</a></li>
</ul>
<h3 id="C-和Go语言的区别，各自的特性？"><a href="#C-和Go语言的区别，各自的特性？" class="headerlink" title="C++和Go语言的区别，各自的特性？"></a>C++和Go语言的区别，各自的特性？</h3><ul>
<li>Go语言 <ul>
<li><p>并发编程 </p>
<p>  Go支持协程(goroutine)并发（协程又称微线程，比线程更轻量、开销更小，性能更高），操作起来非常简单，语言级别提供关键字（go）用于启动协程，并且在同一台机器上可以启动成千上万个协程。协程经常被理解为轻量级线程，一个线程可以包含多个协程，共享堆不共享栈。协程间一般由应用程序显式实现调度，上下文切换无需下到内核层，高效不少。 </p>
</li>
<li><p>面向接口编程 </p>
<p>  Go是面向接口编程的，因为Go没有对象概念，更没有类型继承。 </p>
</li>
<li><p>函数返回多值 </p>
</li>
<li><p>延后执行 </p>
<p>  Go有一个专门的延迟调用栈，使用defer 语句会将其后面跟随的语句压入栈中进行延迟处理，当前函数结束时（不管何种原因结束，即使是崩溃），会将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。 </p>
</li>
<li><p>异常处理 </p>
<p>  Go不支持try…catch…finally这样的结构化的异常解决方式。Go内置error对象，使用defer…recover…panic机制来捕获处理。 </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func test() &#123;</span><br><span class="line">    //用defer + recover 来捕获和处理异常</span><br><span class="line">    defer func() &#123;</span><br><span class="line">        err := recover() //recover内置函数可以捕获到异常</span><br><span class="line">        if err != nil &#123;  //nil是err的零值</span><br><span class="line">            fmt.Println( err= , err)</span><br><span class="line">            //这里可以把信息发送给管理员</span><br><span class="line">            fmt.Println( 发送信息给管理员admin@steven.com )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;() //匿名函数的调用方式一：func()&#123;&#125;()</span><br><span class="line">    num1 := 10</span><br><span class="line">    num2 := 0</span><br><span class="line">    res := num1 / num2   //除0产生异常，会被defer延迟函数捕获</span><br><span class="line">    fmt.Println( res= , res) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>内存回收 </p>
<p>  java和C#等高级语言引入了GC机制，即程序员不需要再考虑内存的回收等，而是由语言特性提供垃圾回收器来回收内存。但是随之而来的可能是程序运行效率的降低。</p>
</li>
<li><p>代码跨平台以及交叉编译 </p>
<p>我们可以在运行 Linux 系统的计算机上开发运行 Windows 下运行的应用程序，反之亦然。</p>
</li>
<li><p>C++<br>面向对象编程、泛型编程和过程化编程</p>
</li>
</ul>
</li>
</ul>
<h3 id="C-的重载和重写是如何实现的？"><a href="#C-的重载和重写是如何实现的？" class="headerlink" title="C++ 的重载和重写是如何实现的？"></a>C++ 的重载和重写是如何实现的？</h3><ul>
<li><p>重载 </p>
<p>编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数。 </p>
</li>
<li><p>重写 </p>
<p>也叫做覆盖，一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。(override)</p>
</li>
</ul>
<h3 id="C-内存是如何分配的？"><a href="#C-内存是如何分配的？" class="headerlink" title="C++内存是如何分配的？"></a>C++内存是如何分配的？</h3>]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>interview-OOP</title>
    <url>/2022/03/20/interview-OOP/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 </p>
<h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。 </p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul>
<li><p>主要解决： </p>
<p>一个全局使用的类频繁地创建与销毁。保证一个类仅有一个实例，并提供一个访问它的全局访问点。 </p>
</li>
<li><p>场景 </p>
<p>日志类、配置类 </p>
</li>
<li><p>关键代码： </p>
<p>构造函数是私有的，且类中有一个私有的静态的全局实例对象。 </p>
</li>
<li><p>实现 </p>
<ul>
<li><p>懒汉式、线程不安全 </p>
<p>缺点：线程不安全</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>懒汉式，线程安全 </p>
<p>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。</p>
<p>优点：第一次调用才初始化，避免内存浪费。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;  </span><br><span class="line">    if (instance == null) &#123;  </span><br><span class="line">        instance = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    return instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>饿汉式 </p>
<p>优点：没有加锁，执行效率会提高。</p>
<p>缺点：类加载时就初始化，浪费内存，容易产生垃圾对象。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static Singleton instance = new Singleton();  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getInstance() &#123;  </span><br><span class="line">        return instance;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>双重校验锁 </p>
<p>优点：安全且在多线程情况下能保持高性能。</p>
<p>缺点：较复杂</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private volatile static Singleton singleton;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static Singleton getSingleton() &#123;  </span><br><span class="line">    if (singleton == null) &#123;  </span><br><span class="line">        synchronized (Singleton.class) &#123;  </span><br><span class="line">            if (singleton == null) &#123;  </span><br><span class="line">                singleton = new Singleton();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>静态内部类 </p>
<p>优点：线程安全，简单</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Singleton &#123;  </span><br><span class="line">    private static class SingletonHolder &#123;  </span><br><span class="line">        private static final Singleton INSTANCE = new Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    private Singleton ()&#123;&#125;  </span><br><span class="line">    public static final Singleton getInstance() &#123;  </span><br><span class="line">        return SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>枚举 </p>
<p>优点：防止反序列化重新创建新的对象，绝对防止多次实例化</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public enum Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    public void whateverMethod() &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>  一般而言我们采用 NewName的方式创建对象&#x2F;接口，当它返回的是接口的时候，其实就是简单工厂模式。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 功能：根据配置文件的后缀来创建不同的解析器</span><br><span class="line">// 首先我们创建一个名为IRuleConfigParser的接口， 其中将定义一个解析器所需具备的所有方法</span><br><span class="line">// 然后是定义两种具体的解析器：Json和Yaml，并实现了IRuleConfigParser的所有方法。</span><br><span class="line">// NewIRuleConfigParser扮演了工厂的角色，即通过传入参数构建所需要的解析器对象</span><br><span class="line"></span><br><span class="line">package factory</span><br><span class="line"></span><br><span class="line">// IRuleConfigParser IRuleConfigParser</span><br><span class="line">type IRuleConfigParser interface &#123;</span><br><span class="line">   Parse(data []byte)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// jsonRuleConfigParser jsonRuleConfigParser</span><br><span class="line">type jsonRuleConfigParser struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Parse Parse</span><br><span class="line">func (J jsonRuleConfigParser) Parse(data []byte) &#123;</span><br><span class="line">   panic( implement me )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// yamlRuleConfigParser yamlRuleConfigParser</span><br><span class="line">type yamlRuleConfigParser struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Parse Parse</span><br><span class="line">func (Y yamlRuleConfigParser) Parse(data []byte) &#123;</span><br><span class="line">   panic( implement me )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NewIRuleConfigParser NewIRuleConfigParser</span><br><span class="line">func NewIRuleConfigParser(t string) IRuleConfigParser &#123;</span><br><span class="line">   switch t &#123;</span><br><span class="line">   case  json :</span><br><span class="line">      return jsonRuleConfigParser&#123;&#125;</span><br><span class="line">   case  yaml :</span><br><span class="line">      return yamlRuleConfigParser&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>  在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// IRuleConfigParserFactory 工厂方法接口</span><br><span class="line">type IRuleConfigParserFactory interface &#123;</span><br><span class="line">   CreateParser() IRuleConfigParser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// yamlRuleConfigParserFactory yamlRuleConfigParser 的工厂类</span><br><span class="line">type yamlRuleConfigParserFactory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CreateParser CreateParser</span><br><span class="line">func (y yamlRuleConfigParserFactory) CreateParser() IRuleConfigParser &#123;</span><br><span class="line">   return yamlRuleConfigParser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// jsonRuleConfigParserFactory jsonRuleConfigParser 的工厂类</span><br><span class="line">type jsonRuleConfigParserFactory struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// CreateParser CreateParser</span><br><span class="line">func (j jsonRuleConfigParserFactory) CreateParser() IRuleConfigParser &#123;</span><br><span class="line">   return jsonRuleConfigParser&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NewIRuleConfigParserFactory 用一个简单工厂封装工厂方法</span><br><span class="line">func NewIRuleConfigParserFactory(t string) IRuleConfigParserFactory &#123;</span><br><span class="line">   switch t &#123;</span><br><span class="line">   case  json :</span><br><span class="line">      return jsonRuleConfigParserFactory&#123;&#125;</span><br><span class="line">   case  yaml :</span><br><span class="line">      return yamlRuleConfigParserFactory&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>  抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// iSportsFactory.go: 抽象工厂接口</span><br><span class="line">package main</span><br><span class="line">import  fmt </span><br><span class="line">type iSportsFactory interface &#123;</span><br><span class="line">    makeShoe() iShoe</span><br><span class="line">    makeShirt() iShirt</span><br><span class="line">&#125;</span><br><span class="line">func getSportsFactory(brand string) (iSportsFactory, error) &#123;</span><br><span class="line">    if brand ==  adidas  &#123;</span><br><span class="line">        return &amp;adidas&#123;&#125;, nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if brand ==  nike  &#123;</span><br><span class="line">        return &amp;nike&#123;&#125;, nil</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil, fmt.Errorf( Wrong brand type passed )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体工厂</span><br><span class="line"></span><br><span class="line">// adidas具体工厂</span><br><span class="line">type adidas struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">func (a *adidas) makeShoe() iShoe &#123;</span><br><span class="line">    return &amp;adidasShoe&#123;</span><br><span class="line">        shoe: shoe&#123;</span><br><span class="line">            logo:  adidas ,</span><br><span class="line">            size: 14,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func (a *adidas) makeShirt() iShirt &#123;</span><br><span class="line">    return &amp;adidasShirt&#123;</span><br><span class="line">        shirt: shirt&#123;</span><br><span class="line">            logo:  adidas ,</span><br><span class="line">            size: 14,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// nike具体工厂</span><br><span class="line">type nike struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">func (n *nike) makeShoe() iShoe &#123;</span><br><span class="line">    return &amp;nikeShoe&#123;</span><br><span class="line">        shoe: shoe&#123;</span><br><span class="line">            logo:  nike ,</span><br><span class="line">            size: 14,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">func (n *nike) makeShirt() iShirt &#123;</span><br><span class="line">    return &amp;nikeShirt&#123;</span><br><span class="line">        shirt: shirt&#123;</span><br><span class="line">            logo:  nike ,</span><br><span class="line">            size: 14,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 抽象产品</span><br><span class="line">type iShoe interface &#123;</span><br><span class="line">    setLogo(logo string)</span><br><span class="line">    setSize(size int)</span><br><span class="line">    getLogo() string</span><br><span class="line">    getSize() int</span><br><span class="line">&#125;</span><br><span class="line">type shoe struct &#123;</span><br><span class="line">    logo string</span><br><span class="line">    size int</span><br><span class="line">&#125;</span><br><span class="line">func (s *shoe) setLogo(logo string) &#123;</span><br><span class="line">    s.logo = logo</span><br><span class="line">&#125;</span><br><span class="line">func (s *shoe) getLogo() string &#123;</span><br><span class="line">    return s.logo</span><br><span class="line">&#125;</span><br><span class="line">func (s *shoe) setSize(size int) &#123;</span><br><span class="line">    s.size = size</span><br><span class="line">&#125;</span><br><span class="line">func (s *shoe) getSize() int &#123;</span><br><span class="line">    return s.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品</span><br><span class="line">type adidasShoe struct &#123;</span><br><span class="line">    shoe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type nikeShoe struct &#123;</span><br><span class="line">    shoe</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// iShirt.go: 抽象产品</span><br><span class="line">type iShirt interface &#123;</span><br><span class="line">    setLogo(logo string)</span><br><span class="line">    setSize(size int)</span><br><span class="line">    getLogo() string</span><br><span class="line">    getSize() int</span><br><span class="line">&#125;</span><br><span class="line">type shirt struct &#123;</span><br><span class="line">    logo string</span><br><span class="line">    size int</span><br><span class="line">&#125;</span><br><span class="line">func (s *shirt) setLogo(logo string) &#123;</span><br><span class="line">    s.logo = logo</span><br><span class="line">&#125;</span><br><span class="line">func (s *shirt) getLogo() string &#123;</span><br><span class="line">    return s.logo</span><br><span class="line">&#125;</span><br><span class="line">func (s *shirt) setSize(size int) &#123;</span><br><span class="line">    s.size = size</span><br><span class="line">&#125;</span><br><span class="line">func (s *shirt) getSize() int &#123;</span><br><span class="line">    return s.size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体产品</span><br><span class="line">type adidasShirt struct &#123;</span><br><span class="line">    shirt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type nikeShirt struct &#123;</span><br><span class="line">    shirt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">package main</span><br><span class="line">import  fmt </span><br><span class="line">func main() &#123;</span><br><span class="line">    adidasFactory, _ := getSportsFactory( adidas )</span><br><span class="line">    nikeFactory, _ := getSportsFactory( nike )</span><br><span class="line"></span><br><span class="line">    nikeShoe := nikeFactory.makeShoe()</span><br><span class="line">    nikeShirt := nikeFactory.makeShirt()</span><br><span class="line"></span><br><span class="line">    adidasShoe := adidasFactory.makeShoe()</span><br><span class="line">    adidasShirt := adidasFactory.makeShirt()</span><br><span class="line"></span><br><span class="line">    printShoeDetails(nikeShoe)</span><br><span class="line">    printShirtDetails(nikeShirt)</span><br><span class="line"></span><br><span class="line">    printShoeDetails(adidasShoe)</span><br><span class="line">    printShirtDetails(adidasShirt)</span><br><span class="line">&#125;</span><br><span class="line">func printShoeDetails(s iShoe) &#123;</span><br><span class="line">    fmt.Printf( Logo: %s , s.getLogo())</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Printf( Size: %d , s.getSize())</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">func printShirtDetails(s iShirt) &#123;</span><br><span class="line">    fmt.Printf( Logo: %s , s.getLogo())</span><br><span class="line">    fmt.Println()</span><br><span class="line">    fmt.Printf( Size: %d , s.getSize())</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h3><p>  例如，我们来思考如何创建一辆汽车对象。创造一辆简单的汽车，首先需要创建车的框架和车轱辘，然后安装汽车门、汽车玻璃，最后再安装上发动机。但是如果你想要一个性能更好的汽车的话，那么还需要给汽车加上一些其他的设施，这个时候咱们需要怎么去做呢？ </p>
<p>  生成器模式的主要功能是构建复杂的产品，而且是细化的，分步骤的构建产品，也就是生成器模式重在一步一步解决构造复杂对象的问题。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Pizza &#123;</span><br><span class="line">    Pizza(int size) &#123; ... &#125;</span><br><span class="line">    Pizza(int size, boolean cheese) &#123; ... &#125;</span><br><span class="line">    Pizza(int size, boolean cheese, boolean pepperoni) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  代码实例：<a href="https://refactoringguru.cn/design-patterns/builder/go/example">https://refactoringguru.cn/design-patterns/builder/go/example</a> </p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>  原型是一种创建型设计模式， 使你能够复制对象， 甚至是复杂对象， 而又无需使代码依赖它们所属的类。 </p>
<p>  关键：实现clone()接口 </p>
<h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><p>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。</p>
<h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>  使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。 </p>
<p>  关键代码：接口中包含它自己，形成链表，或者使用接口数组，使得一组对象可以顺序执行请求。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Package chain 职责链模式</span><br><span class="line">// 🌰 假设我们现在有个校园论坛，由于社区规章制度、广告、法律法规的原因需要对用户的发言进行敏感词过滤</span><br><span class="line">//    如果被判定为敏感词，那么这篇帖子将会被封禁</span><br><span class="line">package chain</span><br><span class="line"></span><br><span class="line">// SensitiveWordFilter 敏感词过滤器，判定是否是敏感词</span><br><span class="line">type SensitiveWordFilter interface &#123;</span><br><span class="line">        Filter(content string) bool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// SensitiveWordFilterChain 职责链</span><br><span class="line">type SensitiveWordFilterChain struct &#123;</span><br><span class="line">        filters []SensitiveWordFilter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AddFilter 添加一个过滤器</span><br><span class="line">func (c *SensitiveWordFilterChain) AddFilter(filter SensitiveWordFilter) &#123;</span><br><span class="line">        c.filters = append(c.filters, filter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Filter 执行过滤</span><br><span class="line">func (c *SensitiveWordFilterChain) Filter(content string) bool &#123;</span><br><span class="line">        for _, filter := range c.filters &#123;</span><br><span class="line">                // 如果发现敏感直接返回结果</span><br><span class="line">                if filter.Filter(content) &#123;</span><br><span class="line">                        return true</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// AdSensitiveWordFilter 广告</span><br><span class="line">type AdSensitiveWordFilter struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Filter 实现过滤算法</span><br><span class="line">func (f *AdSensitiveWordFilter) Filter(content string) bool &#123;</span><br><span class="line">        // TODO: 实现算法</span><br><span class="line">        return false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// PoliticalWordFilter 政治敏感</span><br><span class="line">type PoliticalWordFilter struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Filter 实现过滤算法</span><br><span class="line">func (f *PoliticalWordFilter) Filter(content string) bool &#123;</span><br><span class="line">        // TODO: 实现算法</span><br><span class="line">        return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><ul>
<li><p>解决问题： </p>
<p>  在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 </p>
</li>
<li><p>关键代码，定义三个角色</p>
<ol>
<li>received 真正的命令执行对象 </li>
<li>Command </li>
<li>invoker 使用命令对象的入口 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 示例说明:</span><br><span class="line">// 假设现在有一个游戏服务，我们正在实现一个游戏后端</span><br><span class="line">// 使用一个 goroutine 不断接收来自客户端请求的命令，并且将它放置到一个队列当中</span><br><span class="line">// 然后我们在另外一个 goroutine 中来执行它</span><br><span class="line">package command</span><br><span class="line"></span><br><span class="line">import  fmt </span><br><span class="line"></span><br><span class="line">// ICommand 命令</span><br><span class="line">type ICommand interface &#123;</span><br><span class="line">        Execute() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// StartCommand 游戏开始运行</span><br><span class="line">type StartCommand struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// NewStartCommand NewStartCommand</span><br><span class="line">func NewStartCommand( /*正常情况下这里会有一些参数*/ ) *StartCommand &#123;</span><br><span class="line">        return &amp;StartCommand&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Execute Execute</span><br><span class="line">func (c *StartCommand) Execute() error &#123;</span><br><span class="line">        fmt.Println( game start )</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ArchiveCommand 游戏存档</span><br><span class="line">type ArchiveCommand struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// NewArchiveCommand NewArchiveCommand</span><br><span class="line">func NewArchiveCommand( /*正常情况下这里会有一些参数*/ ) *ArchiveCommand &#123;</span><br><span class="line">        return &amp;ArchiveCommand&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Execute Execute</span><br><span class="line">func (c *ArchiveCommand) Execute() error &#123;</span><br><span class="line">        fmt.Println( game archive )</span><br><span class="line">        return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>  意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。 </p>
<p>  关键代码：定义接口：hasNext, next。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">   public boolean hasNext();</span><br><span class="line">   public Object next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Container &#123;</span><br><span class="line">   public Iterator getIterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class NameRepository implements Container &#123;</span><br><span class="line">   public String[] names = &#123; Robert  ,  John  , Julie  ,  Lora &#125;;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public Iterator getIterator() &#123;</span><br><span class="line">      return new NameIterator();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   private class NameIterator implements Iterator &#123;</span><br><span class="line"> </span><br><span class="line">      int index;</span><br><span class="line"> </span><br><span class="line">      @Override</span><br><span class="line">      public boolean hasNext() &#123;</span><br><span class="line">         if(index &lt; names.length)&#123;</span><br><span class="line">            return true;</span><br><span class="line">         &#125;</span><br><span class="line">         return false;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      @Override</span><br><span class="line">      public Object next() &#123;</span><br><span class="line">         if(this.hasNext())&#123;</span><br><span class="line">            return names[index++];</span><br><span class="line">         &#125;</span><br><span class="line">         return null;</span><br><span class="line">      &#125;     </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class IteratorPatternDemo &#123;</span><br><span class="line">  </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      NameRepository namesRepository = new NameRepository();</span><br><span class="line"> </span><br><span class="line">      for(Iterator iter = namesRepository.getIterator(); iter.hasNext();)&#123;</span><br><span class="line">         String name = (String)iter.next();</span><br><span class="line">         System.out.println( Name :   + name);</span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>  解决问题：对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂。想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。 </p>
<p>  关键代码：对象 Colleague 之间的通信封装到一个类中单独处理。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.Date;</span><br><span class="line"> </span><br><span class="line">public class ChatRoom &#123;</span><br><span class="line">   public static void showMessage(User user, String message)&#123;</span><br><span class="line">      System.out.println(new Date().toString()</span><br><span class="line">         +   [  + user.getName() + ] :   + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">   private String name;</span><br><span class="line"> </span><br><span class="line">   public String getName() &#123;</span><br><span class="line">      return name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setName(String name) &#123;</span><br><span class="line">      this.name = name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public User(String name)&#123;</span><br><span class="line">      this.name  = name;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void sendMessage(String message)&#123;</span><br><span class="line">      ChatRoom.showMessage(this,message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MediatorPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      User robert = new User( Robert );</span><br><span class="line">      User john = new User( John );</span><br><span class="line"> </span><br><span class="line">      robert.sendMessage( Hi! John! );</span><br><span class="line">      john.sendMessage( Hello! Robert! );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><p>  解决问题：允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Memento &#123;</span><br><span class="line">   private String state;</span><br><span class="line"> </span><br><span class="line">   public Memento(String state)&#123;</span><br><span class="line">      this.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getState()&#123;</span><br><span class="line">      return state;</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Originator &#123;</span><br><span class="line">   private String state;</span><br><span class="line"> </span><br><span class="line">   public void setState(String state)&#123;</span><br><span class="line">      this.state = state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String getState()&#123;</span><br><span class="line">      return state;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public Memento saveStateToMemento()&#123;</span><br><span class="line">      return new Memento(state);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void getStateFromMemento(Memento Memento)&#123;</span><br><span class="line">      state = Memento.getState();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line">public class CareTaker &#123;</span><br><span class="line">   private List&lt;Memento&gt; mementoList = new ArrayList&lt;Memento&gt;();</span><br><span class="line"> </span><br><span class="line">   public void add(Memento state)&#123;</span><br><span class="line">      mementoList.add(state);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public Memento get(int index)&#123;</span><br><span class="line">      return mementoList.get(index);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MementoPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Originator originator = new Originator();</span><br><span class="line">      CareTaker careTaker = new CareTaker();</span><br><span class="line">      originator.setState( State #1 );</span><br><span class="line">      originator.setState( State #2 );</span><br><span class="line">      careTaker.add(originator.saveStateToMemento());</span><br><span class="line">      originator.setState( State #3 );</span><br><span class="line">      careTaker.add(originator.saveStateToMemento());</span><br><span class="line">      originator.setState( State #4 );</span><br><span class="line"> </span><br><span class="line">      System.out.println( Current State:   + originator.getState());    </span><br><span class="line">      originator.getStateFromMemento(careTaker.get(0));</span><br><span class="line">      System.out.println( First saved State:   + originator.getState());</span><br><span class="line">      originator.getStateFromMemento(careTaker.get(1));</span><br><span class="line">      System.out.println( Second saved State:   + originator.getState());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>  解决问题：一个对象状态改变给其他对象通知的问题，即订阅机制， </p>
<p>  关键代码：在抽象类里有一个 数组存放观察者们。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package observer</span><br><span class="line"></span><br><span class="line">import  fmt </span><br><span class="line"></span><br><span class="line">// ISubject subject</span><br><span class="line">type ISubject interface &#123;</span><br><span class="line">        Register(observer IObserver)</span><br><span class="line">        Remove(observer IObserver)</span><br><span class="line">        Notify(msg string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IObserver 观察者</span><br><span class="line">type IObserver interface &#123;</span><br><span class="line">        Update(msg string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Subject Subject</span><br><span class="line">type Subject struct &#123;</span><br><span class="line">        observers []IObserver</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Register 注册</span><br><span class="line">func (sub *Subject) Register(observer IObserver) &#123;</span><br><span class="line">        sub.observers = append(sub.observers, observer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Remove 移除观察者</span><br><span class="line">func (sub *Subject) Remove(observer IObserver) &#123;</span><br><span class="line">        for i, ob := range sub.observers &#123;</span><br><span class="line">                if ob == observer &#123;</span><br><span class="line">                        sub.observers = append(sub.observers[:i], sub.observers[i+1:]...)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Notify 通知</span><br><span class="line">func (sub *Subject) Notify(msg string) &#123;</span><br><span class="line">        for _, o := range sub.observers &#123;</span><br><span class="line">                o.Update(msg)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Observer1 Observer1</span><br><span class="line">type Observer1 struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Update 实现观察者接口</span><br><span class="line">func (Observer1) Update(msg string) &#123;</span><br><span class="line">        fmt.Printf( Observer1: %s , msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Observer2 Observer2</span><br><span class="line">type Observer2 struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Update 实现观察者接口</span><br><span class="line">func (Observer2) Update(msg string) &#123;</span><br><span class="line">        fmt.Printf( Observer2: %s , msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- 状态模式 </span><br><span class="line">  主要解决：对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。 </span><br><span class="line">public interface State &#123;</span><br><span class="line">   public void doAction(Context context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StartState implements State &#123;</span><br><span class="line"> </span><br><span class="line">   public void doAction(Context context) &#123;</span><br><span class="line">      System.out.println( Player is in start state );</span><br><span class="line">      context.setState(this); </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return  Start State ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StopState implements State &#123;</span><br><span class="line"> </span><br><span class="line">   public void doAction(Context context) &#123;</span><br><span class="line">      System.out.println( Player is in stop state );</span><br><span class="line">      context.setState(this); </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public String toString()&#123;</span><br><span class="line">      return  Stop State ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Context &#123;</span><br><span class="line">   private State state;</span><br><span class="line"> </span><br><span class="line">   public Context()&#123;</span><br><span class="line">      state = null;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void setState(State state)&#123;</span><br><span class="line">      this.state = state;     </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public State getState()&#123;</span><br><span class="line">      return state;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class StatePatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Context context = new Context();</span><br><span class="line"> </span><br><span class="line">      StartState startState = new StartState();</span><br><span class="line">      startState.doAction(context);</span><br><span class="line"> </span><br><span class="line">      System.out.println(context.getState().toString());</span><br><span class="line"> </span><br><span class="line">      StopState stopState = new StopState();</span><br><span class="line">      stopState.doAction(context);</span><br><span class="line"> </span><br><span class="line">      System.out.println(context.getState().toString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>  完成一项任务，往往可以有多种不同的方式，每一种方式被称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package strategy</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> fmt </span><br><span class="line"> io/ioutil </span><br><span class="line"> os </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// StorageStrategy 存储策略接口</span><br><span class="line">type StorageStrategy interface &#123;</span><br><span class="line">   Save(name string, data []byte) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var strategys = map[string]StorageStrategy&#123;</span><br><span class="line">    file :         &amp;fileStorage&#123;&#125;,</span><br><span class="line">    encrypt_file : &amp;encryptFileStorage&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NewStorageStrategy NewStorageStrategy</span><br><span class="line">func NewStorageStrategy(t string) (StorageStrategy, error) &#123;</span><br><span class="line">   s, ok := strategys[t]</span><br><span class="line">   if !ok &#123;</span><br><span class="line">      return nil, fmt.Errorf( not found StorageStrategy: %s , t)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return s, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略：普通存储</span><br><span class="line">type fileStorage struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Save Save</span><br><span class="line">func (s *fileStorage) Save(name string, data []byte) error &#123;</span><br><span class="line">   return ioutil.WriteFile(name, data, os.ModeAppend)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 具体策略：加密存储</span><br><span class="line">type encryptFileStorage struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Save Save</span><br><span class="line">func (s *encryptFileStorage) Save(name string, data []byte) error &#123;</span><br><span class="line">   // 加密</span><br><span class="line">   data, err := encrypt(data)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      return err</span><br><span class="line">   &#125;</span><br><span class="line">   return ioutil.WriteFile(name, data, os.ModeAppend)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func encrypt(data []byte) ([]byte, error) &#123;</span><br><span class="line">   // 这里实现加密算法</span><br><span class="line">   return data, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 单元测试</span><br><span class="line">package strategy</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> testing </span><br><span class="line"></span><br><span class="line"> github.com/stretchr/testify/assert </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Test_demo(t *testing.T) &#123;</span><br><span class="line">   // 假设这里获取数据，以及数据是否敏感</span><br><span class="line">   data, sensitive := getData()</span><br><span class="line">   strategyType :=  file </span><br><span class="line">   if sensitive &#123;</span><br><span class="line">      strategyType =  encrypt_file </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   storage, err := NewStorageStrategy(strategyType)</span><br><span class="line">   assert.NoError(t, err)</span><br><span class="line">   assert.NoError(t, storage.Save( ./test.txt , data))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// getData 获取数据的方法</span><br><span class="line">// 返回数据，以及数据是否敏感</span><br><span class="line">func getData() ([]byte, bool) &#123;</span><br><span class="line">   return []byte( test data ), false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>  定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 </p>
<p>  应用实例: </p>
<p>  做饭，打开煤气，开火，（做饭）， 关火，关闭煤气。除了做饭其他步骤都是相同的，抽到抽象类中实现。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package template</span><br><span class="line"></span><br><span class="line">import  fmt </span><br><span class="line"></span><br><span class="line">type Cooker interface &#123;</span><br><span class="line">    open()</span><br><span class="line">    fire()</span><br><span class="line">    cooke()</span><br><span class="line">    outfire()</span><br><span class="line">    close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类似于一个抽象类</span><br><span class="line">type CookMenu struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (CookMenu) open() &#123;</span><br><span class="line">    fmt.Println( 打开开关 )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (CookMenu) fire() &#123;</span><br><span class="line">    fmt.Println( 开火 )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 做菜，交给具体的子类实现</span><br><span class="line">func (CookMenu) cooke() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (CookMenu) outfire() &#123;</span><br><span class="line">    fmt.Println( 关火 )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (CookMenu) close() &#123;</span><br><span class="line">    fmt.Println( 关闭开关 )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 封装具体步骤</span><br><span class="line">func doCook(cook Cooker) &#123;</span><br><span class="line">    cook.open()</span><br><span class="line">    cook.fire()</span><br><span class="line">    cook.cooke()</span><br><span class="line">    cook.outfire()</span><br><span class="line">    cook.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 内嵌匿名结构体，实现字段、方法的复用——继承</span><br><span class="line">type XiHongShi struct &#123;</span><br><span class="line">    CookMenu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*XiHongShi) cooke() &#123;</span><br><span class="line">    fmt.Println( 做西红柿 )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ChaoJiDan struct &#123;</span><br><span class="line">    CookMenu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ChaoJiDan) cooke() &#123;</span><br><span class="line">    fmt.Println( 做炒鸡蛋 )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 测试用例</span><br><span class="line">package template</span><br><span class="line">import  testing </span><br><span class="line"></span><br><span class="line">func TestTemplate(t *testing.T) &#123;</span><br><span class="line"></span><br><span class="line">    // 做西红柿</span><br><span class="line">    xihongshi := &amp;XiHongShi&#123;&#125;</span><br><span class="line">    doCook(xihongshi)</span><br><span class="line"></span><br><span class="line">    // 做炒鸡蛋</span><br><span class="line">    chaojidan := &amp;ChaoJiDan&#123;&#125;</span><br><span class="line">    doCook(chaojidan)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><p>主要将数据结构与数据操作分离。允许你在不修改已有代码的情况下向已有类层次结构中增加新的行为 </p>
<p>关键代码： </p>
<ul>
<li><p>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。 </p>
</li>
<li><p>func accept(v visitor) </p>
</li>
<li><p>定义访问者接口，添加新的行为。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ComputerPart &#123;</span><br><span class="line">   public void accept(ComputerPartVisitor computerPartVisitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Keyboard  implements ComputerPart &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</span><br><span class="line">      computerPartVisitor.visit(this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Monitor  implements ComputerPart &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</span><br><span class="line">      computerPartVisitor.visit(this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mouse  implements ComputerPart &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</span><br><span class="line">      computerPartVisitor.visit(this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Computer implements ComputerPart &#123;</span><br><span class="line">   </span><br><span class="line">   ComputerPart[] parts;</span><br><span class="line"> </span><br><span class="line">   public Computer()&#123;</span><br><span class="line">      parts = new ComputerPart[] &#123;new Mouse(), new Keyboard(), new Monitor()&#125;;      </span><br><span class="line">   &#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void accept(ComputerPartVisitor computerPartVisitor) &#123;</span><br><span class="line">      for (int i = 0; i &lt; parts.length; i++) &#123;</span><br><span class="line">         parts[i].accept(computerPartVisitor);</span><br><span class="line">      &#125;</span><br><span class="line">      computerPartVisitor.visit(this);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface ComputerPartVisitor &#123;</span><br><span class="line">   public void visit(Computer computer);</span><br><span class="line">   public void visit(Mouse mouse);</span><br><span class="line">   public void visit(Keyboard keyboard);</span><br><span class="line">   public void visit(Monitor monitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ComputerPartDisplayVisitor implements ComputerPartVisitor &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void visit(Computer computer) &#123;</span><br><span class="line">      System.out.println( Displaying Computer. );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void visit(Mouse mouse) &#123;</span><br><span class="line">      System.out.println( Displaying Mouse. );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void visit(Keyboard keyboard) &#123;</span><br><span class="line">      System.out.println( Displaying Keyboard. );</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void visit(Monitor monitor) &#123;</span><br><span class="line">      System.out.println( Displaying Monitor. );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VisitorPatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">      ComputerPart computer = new Computer();</span><br><span class="line">      computer.accept(new ComputerPartDisplayVisitor());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>  解决问题：适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 </p>
<p>  举例：这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，Mac电脑可以插入Lightning 接口，Windows可以插入USB接口，如果想Windows也插入Lightning接口，便需要一个适配器，将Lightning接口信号转化为USB信号。 </p>
<p>  关键代码：适配器继承或依赖已有的对象，实现想要的目标接口。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">// 电脑接口</span><br><span class="line">type computer interface &#123;</span><br><span class="line">    insertIntoLightningPort()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// mac</span><br><span class="line">type mac struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">func (m *mac) insertIntoLightningPort() &#123;</span><br><span class="line">    fmt.Println( Lightning connector is plugged into mac machine. )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// windows</span><br><span class="line">type windows struct&#123;</span><br><span class="line">&#125;</span><br><span class="line">func (w *windows) insertIntoUSBPort() &#123;</span><br><span class="line">    fmt.Println( USB connector is plugged into windows machine. )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// windowsAdapter</span><br><span class="line">type windowsAdapter struct &#123;</span><br><span class="line">    windowMachine *windows</span><br><span class="line">&#125;</span><br><span class="line">func (w *windowsAdapter) insertIntoLightningPort() &#123;</span><br><span class="line">    fmt.Println( Adapter converts Lightning signal to USB. )</span><br><span class="line">    w.windowMachine.insertIntoUSBPort()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端</span><br><span class="line">type client struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">func (c *client) insertLightningConnectorIntoComputer(com computer) &#123;</span><br><span class="line">    fmt.Println( Client inserts Lightning connector into computer. )</span><br><span class="line">    com.insertIntoLightningPort()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// main函数</span><br><span class="line">func main() &#123;</span><br><span class="line">    client := &amp;client&#123;&#125;</span><br><span class="line">    mac := &amp;mac&#123;&#125;</span><br><span class="line"></span><br><span class="line">    client.insertLightningConnectorIntoComputer(mac)</span><br><span class="line"></span><br><span class="line">    windowsMachine := &amp;windows&#123;&#125;</span><br><span class="line">    windowsMachineAdapter := &amp;windowsAdapter&#123;</span><br><span class="line">        windowMachine: windowsMachine,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    client.insertLightningConnectorIntoComputer(windowsMachineAdapter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>  解决问题：将抽象部分与实现部分分离，使它们都可以独立的变化。 </p>
<p>  关键代码：层次结构中的第一层 （通常称为抽象部分） 将包含对第二层 （实现部分） 对象的引用。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">type computer interface &#123;</span><br><span class="line">    print()</span><br><span class="line">    setPrinter(printer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">import  fmt </span><br><span class="line"></span><br><span class="line">type mac struct &#123;</span><br><span class="line">    printer printer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *mac) print() &#123;</span><br><span class="line">    fmt.Println( Print request for mac )</span><br><span class="line">    m.printer.printFile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (m *mac) setPrinter(p printer) &#123;</span><br><span class="line">    m.printer = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type windows struct &#123;</span><br><span class="line">    printer printer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *windows) print() &#123;</span><br><span class="line">    fmt.Println( Print request for windows )</span><br><span class="line">    w.printer.printFile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (w *windows) setPrinter(p printer) &#123;</span><br><span class="line">    w.printer = p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type printer interface &#123;</span><br><span class="line">    printFile()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type epson struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *epson) printFile() &#123;</span><br><span class="line">    fmt.Println( Printing by a EPSON Printer )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type hp struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *hp) printFile() &#123;</span><br><span class="line">    fmt.Println( Printing by a HP Printer )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    hpPrinter := &amp;hp&#123;&#125;</span><br><span class="line">    epsonPrinter := &amp;epson&#123;&#125;</span><br><span class="line"></span><br><span class="line">    macComputer := &amp;mac&#123;&#125;</span><br><span class="line"></span><br><span class="line">    macComputer.setPrinter(hpPrinter)</span><br><span class="line">    macComputer.print()</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    macComputer.setPrinter(epsonPrinter)</span><br><span class="line">    macComputer.print()</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    winComputer := &amp;windows&#123;&#125;</span><br><span class="line"></span><br><span class="line">    winComputer.setPrinter(hpPrinter)</span><br><span class="line">    winComputer.print()</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    winComputer.setPrinter(epsonPrinter)</span><br><span class="line">    winComputer.print()</span><br><span class="line">    fmt.Println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>  解决问题：使用组合模式将对象组合成树状结构， 并且能像使用独立对象一样使用它们。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line">import  fmt </span><br><span class="line">type file struct &#123;</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *file) search(keyword string) &#123;</span><br><span class="line">    fmt.Printf( Searching for keyword %s in file %s\n , keyword, f.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *file) getName() string &#123;</span><br><span class="line">    return f.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type folder struct &#123;</span><br><span class="line">    components []component</span><br><span class="line">    name       string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *folder) search(keyword string) &#123;</span><br><span class="line">    fmt.Printf( Serching recursively for keyword %s in folder %s\n , keyword, f.name)</span><br><span class="line">    for _, composite := range f.components &#123;</span><br><span class="line">        composite.search(keyword)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (f *folder) add(c component) &#123;</span><br><span class="line">    f.components = append(f.components, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type component interface &#123;</span><br><span class="line">    search(string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    file1 := &amp;file&#123;name:  File1 &#125;</span><br><span class="line">    file2 := &amp;file&#123;name:  File2 &#125;</span><br><span class="line">    file3 := &amp;file&#123;name:  File3 &#125;</span><br><span class="line"></span><br><span class="line">    folder1 := &amp;folder&#123;</span><br><span class="line">        name:  Folder1 ,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    folder1.add(file1)</span><br><span class="line"></span><br><span class="line">    folder2 := &amp;folder&#123;</span><br><span class="line">        name:  Folder2 ,</span><br><span class="line">    &#125;</span><br><span class="line">    folder2.add(file2)</span><br><span class="line">    folder2.add(file3)</span><br><span class="line">    folder2.add(folder1)</span><br><span class="line"></span><br><span class="line">    folder2.search( rose )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>  一般有两种方式可以实现给一个类或对象增加行为： </p>
<ul>
<li><p>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。（Go语言中没有继承） </p>
</li>
<li><p>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package decorator</span><br><span class="line"></span><br><span class="line">// IDraw IDraw</span><br><span class="line">type IDraw interface &#123;</span><br><span class="line">   Draw() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Square 正方形</span><br><span class="line">type Square struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">// Draw Draw</span><br><span class="line">func (s Square) Draw() string &#123;</span><br><span class="line">   return  this is a square </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ColorSquare 有颜色的正方形</span><br><span class="line">type ColorSquare struct &#123;</span><br><span class="line">   square IDraw</span><br><span class="line">   color  string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// NewColorSquare NewColorSquare</span><br><span class="line">func NewColorSquare(square IDraw, color string) ColorSquare &#123;</span><br><span class="line">   return ColorSquare&#123;color: color, square: square&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Draw Draw</span><br><span class="line">func (c ColorSquare) Draw() string &#123;</span><br><span class="line">   return c.square.Draw() +  , color is   + c.color</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 单元测试</span><br><span class="line">func TestColorSquare_Draw(t *testing.T) &#123;</span><br><span class="line">   sq := Square&#123;&#125;</span><br><span class="line">   csq := NewColorSquare(sq,  red )</span><br><span class="line">   got := csq.Draw()</span><br><span class="line">   assert.Equal(t,  this is a square, color is red , got)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- 外观模式 </span><br><span class="line">  提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用 </span><br><span class="line">public interface Shape &#123;</span><br><span class="line">   void draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println( Rectangle::draw() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Square implements Shape &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println( Square::draw() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Circle implements Shape &#123;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   public void draw() &#123;</span><br><span class="line">      System.out.println( Circle::draw() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ShapeMaker &#123;</span><br><span class="line">   private Shape circle;</span><br><span class="line">   private Shape rectangle;</span><br><span class="line">   private Shape square;</span><br><span class="line"> </span><br><span class="line">   public ShapeMaker() &#123;</span><br><span class="line">      circle = new Circle();</span><br><span class="line">      rectangle = new Rectangle();</span><br><span class="line">      square = new Square();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void drawCircle()&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   public void drawRectangle()&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   public void drawSquare()&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FacadePatternDemo &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      ShapeMaker shapeMaker = new ShapeMaker();</span><br><span class="line"> </span><br><span class="line">      shapeMaker.drawCircle();</span><br><span class="line">      shapeMaker.drawRectangle();</span><br><span class="line">      shapeMaker.drawSquare();      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>问题：下面是反恐精英玩家的结构体。 我们可以看到， 服装对象是嵌入在玩家结构体之中的： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type player struct &#123;</span><br><span class="line">    dress      dress</span><br><span class="line">    playerType string // 可为 T 或 CT</span><br><span class="line">    lat        int</span><br><span class="line">    long       int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设目前有 5 名恐怖分子和 5 名反恐精英， 一共是 10 名玩家。 那么关于服装， 我们就有两个选项了。</p>
<p>10 个玩家对象各自创建不同的服装对象， 并将其嵌入。 总共会创建 10 个服装对象。</p>
<p>我们创建两个服装对象：</p>
<p>单一恐怖分子服装对象： 其将在 5 名恐怖分子之间共享。</p>
<p>单一反恐精英服装对象： 其将在 5 名反恐精英之间共享。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package maintype player struct &#123;</span><br><span class="line">    dress      dress</span><br><span class="line">    playerType string</span><br><span class="line">    lat        int</span><br><span class="line">    long       int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建玩家对象时，享元由一个工厂得到。</span><br><span class="line">func newPlayer(playerType, dressType string) *player &#123;</span><br><span class="line">    dress, _ := getDressFactorySingleInstance().getDressByType(dressType)</span><br><span class="line">    return &amp;player&#123;</span><br><span class="line">        playerType: playerType,</span><br><span class="line">        dress:      dress,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *player) newLocation(lat, long int) &#123;</span><br><span class="line">    p.lat = lat</span><br><span class="line">    p.long = long</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>  能提供真实服务对象的替代品给客户端使用。 代理接收客户端的请求并进行一些处理 （访问控制和缓存等）， 然后再将请求传递给服务对象。 </p>
<p>  关键代码：实现与被代理类组合，代理类实现了被代理对象的接口。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type server interface &#123;</span><br><span class="line">    handleRequest(string, string) (int, string)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type nginx struct &#123;</span><br><span class="line">    application       *application</span><br><span class="line">    maxAllowedRequest int</span><br><span class="line">    rateLimiter       map[string]int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newNginxServer() *nginx &#123;</span><br><span class="line">    return &amp;nginx&#123;</span><br><span class="line">        application:       &amp;application&#123;&#125;,</span><br><span class="line">        maxAllowedRequest: 2,</span><br><span class="line">        rateLimiter:       make(map[string]int),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n *nginx) handleRequest(url, method string) (int, string) &#123;</span><br><span class="line">    allowed := n.checkRateLimiting(url)</span><br><span class="line">    if !allowed &#123;</span><br><span class="line">        return 403,  Not Allowed </span><br><span class="line">    &#125;</span><br><span class="line">    return n.application.handleRequest(url, method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (n *nginx) checkRateLimiting(url string) bool &#123;</span><br><span class="line">    if n.rateLimiter[url] == 0 &#123;</span><br><span class="line">        n.rateLimiter[url] = 1</span><br><span class="line">    &#125;</span><br><span class="line">    if n.rateLimiter[url] &gt; n.maxAllowedRequest &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    n.rateLimiter[url] = n.rateLimiter[url] + 1</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type application struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a *application) handleRequest(url, method string) (int, string) &#123;</span><br><span class="line">    if url ==  /app/status  &amp;&amp; method ==  GET  &#123;</span><br><span class="line">        return 200,  Ok </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if url ==  /create/user  &amp;&amp; method ==  POST  &#123;</span><br><span class="line">        return 201,  User Created </span><br><span class="line">    &#125;</span><br><span class="line">    return 404,  Not Ok </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    nginxServer := newNginxServer()</span><br><span class="line">    appStatusURL :=  /app/status </span><br><span class="line">    createuserURL :=  /create/user </span><br><span class="line"></span><br><span class="line">    httpCode, body := nginxServer.handleRequest(appStatusURL,  GET )</span><br><span class="line">    fmt.Printf( \nUrl: %s\nHttpCode: %d\nBody: %s\n , appStatusURL, httpCode, body)</span><br><span class="line"></span><br><span class="line">    httpCode, body = nginxServer.handleRequest(appStatusURL,  GET )</span><br><span class="line">    fmt.Printf( \nUrl: %s\nHttpCode: %d\nBody: %s\n , appStatusURL, httpCode, body)</span><br><span class="line"></span><br><span class="line">    httpCode, body = nginxServer.handleRequest(appStatusURL,  GET )</span><br><span class="line">    fmt.Printf( \nUrl: %s\nHttpCode: %d\nBody: %s\n , appStatusURL, httpCode, body)</span><br><span class="line"></span><br><span class="line">    httpCode, body = nginxServer.handleRequest(createuserURL,  POST )</span><br><span class="line">    fmt.Printf( \nUrl: %s\nHttpCode: %d\nBody: %s\n , appStatusURL, httpCode, body)</span><br><span class="line"></span><br><span class="line">    httpCode, body = nginxServer.handleRequest(createuserURL,  GET )</span><br><span class="line">    fmt.Printf( \nUrl: %s\nHttpCode: %d\nBody: %s\n , appStatusURL, httpCode, body)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h1><h2 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h2><ul>
<li><p>封装 </p>
<p>数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。 </p>
</li>
<li><p>继承 </p>
<p>继承实现了IS-A关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非private 的属性和方法。 </p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为向上转型 </p>
</li>
<li><p>多态 </p>
<p>多态分为编译时多态和运行时多态： </p>
<ul>
<li><p>编译时多态主要指方法的重载 </p>
</li>
<li><p>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</p>
</li>
</ul>
</li>
</ul>
<h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>  简单地说就是一个类只做一件事。在软件系统中，一个类(一个模块、或者一个方法)承担的职责越多，那么其被复用的可能性就会越低。当这个类需要做过多事情的时候，就需要分解这个类。 </p>
<h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><p>  扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。在软件的生命周期内，因为变化、升级和维护等原因，需要对软件原有的代码进行修改时，可能会给旧代码引入错误。因此，当软件需要变化时，我们应该尽量通过扩展的方式来实现变化，而不是通过修改已有的代码来实现。<br>  符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。 </p>
<h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p>  继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>  如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。 </p>
<h3 id="接口分离原则"><a href="#接口分离原则" class="headerlink" title="接口分离原则"></a>接口分离原则</h3><p>  客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。简单来说就是建立单一的接口，不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的方法尽量少。 </p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>  程序要依赖于抽象接口，不要依赖于具体实现。 </p>
<p>  简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<p>  依赖倒置原则的核心就是要我们面向接口编程 </p>
<h3 id="合成-x2F-聚合复用原则"><a href="#合成-x2F-聚合复用原则" class="headerlink" title="合成&#x2F;聚合复用原则"></a>合成&#x2F;聚合复用原则</h3><p>  一般也叫合成复用原则(Composite Reuse Principle, CRP)，定义是：尽量使用合成&#x2F;聚合，而不是通过继承达到复用的目的。</p>
<p>  合成&#x2F;聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向内部持有的这些对象的委派达到复用已有功能的目的，而不是通过继承来获得已有的功能。 </p>
<p>  继承复用破坏包装，因为继承将基类的实现细节暴露给派生类，基类的内部细节通常对子类来说是可见的，这种复用也称为 白箱复用 。这里有一个明显的问题是：派生类继承自基类，如果基类的实现发生改变，将会影响到所有派生类的实现；如果从基类继承而来的实现是静态的，不可能在运行时发生改变，不够灵活。 </p>
]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>interview-Golang</title>
    <url>/2022/03/28/interview-Golang/</url>
    <content><![CDATA[<h2 id="简述-slice-的底层原理，slice-和数组的区别是什么"><a href="#简述-slice-的底层原理，slice-和数组的区别是什么" class="headerlink" title="简述 slice 的底层原理，slice 和数组的区别是什么"></a>简述 slice 的底层原理，slice 和数组的区别是什么</h2><ul>
<li><p>数组</p>
<p>  数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。</p>
</li>
<li><p>slice</p>
<p>  Slice(切片)代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作 []T，其中T代表slice中元素的类型;slice的语法和数组很像，只是没有固定长度而已。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>slice复制的坑</p>
<p>  不能像这样直接复制s2 :&#x3D; s1[:]，如果这样操作，在改变s1的时候s2的值也会被相应改变，因为他们的底层数据结构也就是数组指向相同的地址。如果要进行深拷贝，可以使用<code>copy</code>函数。</p>
</li>
<li><p>slice判空</p>
<p>  正确方法：<code>len(slice) == 0</code>，不能使用<code>slice == nil</code>，因为<code>slice!=nil</code>也有可能元素数量为0；</p>
</li>
<li><p>slice做函数参数</p>
<p>  从slice的结构可以看到，做参数时会复制一份结构体进行传递。此时参数切片跟外部切片都共同指向同一块内存区域，如果函数内部修改了内存值，修改也会传递到外部。但是如果对参数切片进行append操作，不会影响外部，外部切片的size还是原来大小。</p>
<p>  简而言之，当对切片进行 append 操作，导致长度超出容量时，就会创建新的数组，这会导致和原有切片的分离。</p>
<p>  举例如下：</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">b := a[<span class="number">0</span>:<span class="number">4</span>]</span><br><span class="line">a = <span class="built_in">append</span>(a, <span class="number">1</span>)</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"><span class="comment">// [0 0 0 0]</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="comment">// [0 5 0 0 0 1]&lt;/pre&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="简单介绍-GMP-模型以及该模型的优点"><a href="#简单介绍-GMP-模型以及该模型的优点" class="headerlink" title="简单介绍 GMP 模型以及该模型的优点"></a>简单介绍 GMP 模型以及该模型的优点</h2><h3 id="goroutine协程的产生"><a href="#goroutine协程的产生" class="headerlink" title="goroutine协程的产生"></a>goroutine协程的产生</h3><p>在多进程&#x2F;多线程的操作系统中，进程或者线程的切换都会浪费时间，同时还需要面对线程间通信，同步互斥等问题，于是引入了协程。可以理解为简化的用户态线程。</p>
<p>具体实现是将N个用户态协程绑定到M个内核态的线程上，优点就是协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。</p>
<p><img src="/2022/03/28/interview-Golang/goroutine.png" alt="image"></p>
<p>协程跟线程是有区别的，线程由CPU调度是抢占式的，协程由用户态调度是协作式的，一个协程让出CPU后，才执行下一个协程。</p>
<p>Go中，协程被称为goroutine，它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。</p>
<p>Goroutine特点：</p>
<ul>
<li>占用内存更小（几kb）</li>
<li>调度更灵活(runtime调度)</li>
</ul>
<h3 id="Golang调度器的产生"><a href="#Golang调度器的产生" class="headerlink" title="Golang调度器的产生"></a><a href="https://segmentfault.com/a/1190000021951119">Golang调度器的产生</a></h3><h4 id="GM模型介绍"><a href="#GM模型介绍" class="headerlink" title="GM模型介绍"></a>GM模型介绍</h4><p>最初Golang使用的是GM模型，现在已经被废弃，它的原理图如下：<br><img src="/2022/03/28/interview-Golang/GM.webp" alt="image"></p>
<p>M想要执行、放回G都必须访问全局G队列，并且M有多个，即多线程访问同一资源需要加锁进行保证互斥&#x2F;同步，所以全局G队列是有互斥锁进行保护的。</p>
<p>老调度器有几个缺点：</p>
<ol>
<li>创建、销毁、调度G都需要每个M获取锁，这就形成了激烈的锁竞争。</li>
<li>M转移G会造成延迟和额外的系统负载。比如当G中包含创建新协程的时候，M创建了G’，为了继续执行G，需要把G’交给M’执行，也造成了很差的局部性，因为G’和G是相关的，最好放在M上执行，而不是其他M’。</li>
<li>系统调用(CPU在M之间的切换)导致频繁的线程阻塞和取消阻塞操作增加了系统开销。</li>
</ol>
<h4 id="GMP分别的含义"><a href="#GMP分别的含义" class="headerlink" title="GMP分别的含义"></a>GMP分别的含义</h4><p><img src="/2022/03/28/interview-Golang/GMP.webp" alt="image"></p>
<ul>
<li><p>G(代表一个gr) : 存储有gr的栈信息, gr的状态, 以及gr需要执行的函数</p>
</li>
<li><p>P: Processor的简称，即调度器</p>
</li>
<li><p>M: 代表一个线程</p>
</li>
</ul>
<h4 id="GMP模型具体实现"><a href="#GMP模型具体实现" class="headerlink" title="GMP模型具体实现"></a>GMP模型具体实现</h4><p>面对之前GM模型的问题，Go设计了新的调度器。在Go中，线程是运行goroutine的实体，调度器的功能是把可运行的goroutine分配到工作线程上。</p>
<p><img src="/2022/03/28/interview-Golang/GMP1.webp" alt="image"></p>
<p>调度流程为：</p>
<p><img src="/2022/03/28/interview-Golang/GMP2.webp" alt="image"></p>
<p>总结：Go调度本质是把大量的goroutine分配到少量线程上去执行，并利用多核并行，实现更强大的并发。</p>
<h2 id="简述-Golang-垃圾回收的机制"><a href="#简述-Golang-垃圾回收的机制" class="headerlink" title="简述 Golang 垃圾回收的机制"></a><a href="https://developer.aliyun.com/article/861507">简述 Golang 垃圾回收的机制</a></h2><h3 id="常见的垃圾回收算法"><a href="#常见的垃圾回收算法" class="headerlink" title="常见的垃圾回收算法"></a>常见的垃圾回收算法</h3><p>目前比较常见的垃圾回收算法有三种：</p>
<ol>
<li><p>引用计数：为每个对象维护一个引用计数，当引用该对象的对象销毁时，引用计数 -1，当对象引用计数为 0 时回收该对象。</p>
<p> 代表语言：Python、PHP、Swift</p>
<p> 优点：对象回收快，不会出现内存耗尽或达到某个阈值时才回收。</p>
<p> 缺点：不能很好的处理循环引用，而实时维护引用计数也是有损耗的。</p>
</li>
<li><p>标记-清除：从根变量开始遍历所有引用的对象，标记引用的对象，没有被标记的进行回收。</p>
<p> 代表语言：Golang（三色标记法）</p>
<p> 优点：解决了引用计数的缺点。</p>
<p> 缺点：需要 STW，暂时停掉程序运行。</p>
</li>
<li><p>分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。</p>
<p> 代表语言：Java</p>
<p> 优点：回收性能好</p>
<p> 缺点：算法复杂</p>
</li>
</ol>
<h3 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h3><p>原始的标记清楚法分为两个步骤：</p>
<ol>
<li><p>标记。先STP(Stop The World)，暂停整个程序的全部运行线程，将被引用的对象打上标记。</p>
</li>
<li><p>清除没有被打标机的对象，即回收内存资源，然后恢复运行线程。</p>
</li>
</ol>
<p>这样做有个很大的问题就是要通过STW保证GC期间标记对象的状态不能变化，整个程序都要暂停掉，在外部看来程序就会卡顿。</p>
<h3 id="三色标记原理"><a href="#三色标记原理" class="headerlink" title="三色标记原理"></a>三色标记原理</h3><p>三色标记法是对标记阶段的改进，原理如下：</p>
<ol>
<li>首先把所有的对象都放到白色的集合中</li>
<li>从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中</li>
<li>遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色的集合中</li>
<li>循环步骤3，知道灰色集合中没有对象</li>
<li>步骤4结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收</li>
</ol>
<p><img src="/2022/03/28/interview-Golang/GC.webp" alt="image"></p>
<p>Root 区域主要是程序运行到当前时刻的栈和全局数据区域，是实时正在使用到的内存.</p>
<h3 id="没有STW的三色标记法"><a href="#没有STW的三色标记法" class="headerlink" title="没有STW的三色标记法"></a>没有STW的三色标记法</h3><p><img src="/2022/03/28/interview-Golang/STW1.jpeg" alt="image"><br><img src="/2022/03/28/interview-Golang/STW2.jpeg" alt="image"><br><img src="/2022/03/28/interview-Golang/STW3.jpeg" alt="image"></p>
<p>可以看出，有两种情况，在三色标记法中，是不希望被发生的。</p>
<ul>
<li>条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)</li>
<li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)<br>如果当以上两个条件同时满足时，就会出现对象丢失现象!</li>
</ul>
<p>为了解决这个问题，在保证对象不丢失的情况下合理地尽可能地提高GC效率，减少STW时间，Golang引入了屏障机制</p>
<h3 id="屏障机制"><a href="#屏障机制" class="headerlink" title="屏障机制"></a>屏障机制</h3><h4 id="强-弱”-三色不变式"><a href="#强-弱”-三色不变式" class="headerlink" title="强-弱” 三色不变式"></a>强-弱” 三色不变式</h4><ul>
<li><p>强三色不变式</p>
<p>  不存在黑色对象引用到白色对象的指针。<br>  <img src="/2022/03/28/interview-Golang/3color1.jpeg" alt="image"></p>
</li>
<li><p>弱三色不变式</p>
<p>  所有被黑色对象引用的白色对象都处于灰色保护状态。<br>  <img src="/2022/03/28/interview-Golang/3color2.jpeg" alt="image"></p>
</li>
</ul>
<p>为了遵循上述的两个方式，GC算法演进到两种屏障方式，他们“插入屏障”, “删除屏障”。</p>
<h4 id="插入屏障"><a href="#插入屏障" class="headerlink" title="插入屏障"></a>插入屏障</h4><p>具体操作: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p>
<p>满足: 强三色不变式. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)<br><img src="/2022/03/28/interview-Golang/3color3.jpeg" alt="image"></p>
<p><img src="/2022/03/28/interview-Golang/3color4.jpeg" alt="image"></p>
<p><img src="/2022/03/28/interview-Golang/3color5.jpeg" alt="image"></p>
<p>当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9). 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p>
<p><img src="/2022/03/28/interview-Golang/3color6.jpeg" alt="image"></p>
<h4 id="删除屏障"><a href="#删除屏障" class="headerlink" title="删除屏障"></a>删除屏障</h4><p>具体操作: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p>
<p>满足: 弱三色不变式. (保护灰色对象到白色对象的路径不会断)</p>
<p><img src="/2022/03/28/interview-Golang/3color7.jpeg" alt="image"><br><img src="/2022/03/28/interview-Golang/3color8.jpeg" alt="image"></p>
<p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p>
<h3 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h3><p>插入写屏障和删除写屏障的短板：</p>
<ul>
<li>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；</li>
<li>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</li>
</ul>
<p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p>
<h4 id="混合写屏障规则"><a href="#混合写屏障规则" class="headerlink" title="混合写屏障规则"></a>混合写屏障规则</h4><p>具体操作:</p>
<ol>
<li><p>GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p>
</li>
<li><p>GC期间，任何在栈上创建的新对象，均为黑色。</p>
</li>
<li><p>被删除的对象标记为灰色。</p>
</li>
<li><p>被添加的对象标记为灰色。</p>
</li>
</ol>
<p>满足: 变形的弱三色不变式.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p>
</li>
<li><p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通。</p>
</li>
<li><p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p>
</li>
</ul>
<h3 id="垃圾回收触发机制"><a href="#垃圾回收触发机制" class="headerlink" title="垃圾回收触发机制"></a>垃圾回收触发机制</h3><ol>
<li>阈值：默认内存扩大一倍，启动gc</li>
<li>定期：默认2min触发一次gc</li>
<li>手动：调用runtime.gc()</li>
</ol>
<h2 id="协程与进程，线程的区别是什么？协程有什么优势？"><a href="#协程与进程，线程的区别是什么？协程有什么优势？" class="headerlink" title="协程与进程，线程的区别是什么？协程有什么优势？"></a>协程与进程，线程的区别是什么？协程有什么优势？</h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ol>
<li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li>
<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>
<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；</li>
<li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li>
</ol>
<p>　　线程与进程关系的示意图：<br><img src="/2022/03/28/interview-Golang/process.png" alt="image"></p>
<h3 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h3><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。从技术的角度来说，“协程就是你可以暂停执行的函数”。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<h3 id="线程和协程的区别"><a href="#线程和协程的区别" class="headerlink" title="线程和协程的区别"></a>线程和协程的区别</h3><ol>
<li><p>线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。</p>
</li>
<li><p>线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。</p>
</li>
<li><p>由于在同一个线程上，因此可以避免竞争关系而使用锁。</p>
</li>
</ol>
<h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><ol>
<li>节省 CPU：避免系统内核级的线程频繁切换，造成的 CPU 资源浪费。好钢用在刀刃上。而协程是用户态的线程，用户可以自行控制协程的创建于销毁，极大程度避免了系统级线程上下文切换造成的资源浪费。</li>
<li>节约内存：在 64 位的Linux中，一个线程需要分配 8MB 栈内存和 64MB 堆内存，系统内存的制约导致我们无法开启更多线程实现高并发。而在协程编程模式下，可以轻松有十几万协程，这是线程无法比拟的。</li>
<li>开发效率：使用协程在开发程序之中，可以很方便的将一些耗时的IO操作异步化，例如写文件、耗时 IO 请求等。</li>
</ol>
<h2 id="简述-defer-的执行顺序"><a href="#简述-defer-的执行顺序" class="headerlink" title="简述 defer 的执行顺序"></a>简述 defer 的执行顺序</h2><h3 id="多个defer的执行顺序"><a href="#多个defer的执行顺序" class="headerlink" title="多个defer的执行顺序"></a>多个defer的执行顺序</h3><p>通过下面这个个例子，我们看下defer的执行顺序：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;main defer1&quot;</span>)</span><br><span class="line">    test()</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;main defer2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> () &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;test defer1&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;test defer2&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">test defer2</span><br><span class="line">test defer1</span><br><span class="line">main defer2</span><br><span class="line">main defer1</span><br></pre></td></tr></table></figure>

<p>我们发现defer就像一个LIFO的栈，后defer的会先执行，且在函数退出时才会执行。</p>
<h3 id="defer与return的执行顺序"><a href="#defer与return的执行顺序" class="headerlink" title="defer与return的执行顺序"></a>defer与return的执行顺序</h3><p>defer、return、返回值三者的执行逻辑应该是：</p>
<ol>
<li>return最先执行，return负责将结果写入返回值中；</li>
<li>接着defer开始执行一些收尾工作；</li>
<li>最后函数携带当前返回值退出。</li>
</ol>
<p>例子1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ret := test()</span><br><span class="line">    fmt.Println(<span class="string">&quot;test return:&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> ( <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i++        <span class="comment">//defer里面对i增1</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;test defer, i = &quot;</span>, i)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">test defer, i =  1</span><br><span class="line">test return: 0</span><br></pre></td></tr></table></figure>

<p>函数的返回值没有被提前声名，其值来自于其他变量的赋值，而defer中修改的也是其他变量，而非返回值本身，因此函数退出时返回值并没有被改变。</p>
<p>例子2</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ret := test()</span><br><span class="line">    fmt.Println(<span class="string">&quot;test return:&quot;</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回值改为命名返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (i <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">//var i int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        fmt.Println(<span class="string">&quot;test defer, i = &quot;</span>, i)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">test defer, i =  1</span><br><span class="line">test return: 1</span><br></pre></td></tr></table></figure>

<p>函数的返回值被提前声明，也就意味着defer中是可以调用到真实返回值的，因此defer在return赋值返回值 i 之后，再一次地修改了 i 的值，最终函数退出后的返回值才会是defer修改过的值。</p>
<h2 id="Golang-有哪些优缺点、错误处理有什么优缺点？"><a href="#Golang-有哪些优缺点、错误处理有什么优缺点？" class="headerlink" title="Golang 有哪些优缺点、错误处理有什么优缺点？"></a>Golang 有哪些优缺点、错误处理有什么优缺点？</h2><h3 id="go的优点"><a href="#go的优点" class="headerlink" title="go的优点"></a>go的优点</h3><ul>
<li>go语言是一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言</li>
<li>Go 极其地快。其性能与 C++相似。</li>
<li>它的自动垃圾回收降低了开发难度</li>
<li>并发性&amp;通道：其唯一的创新之处是 goroutines 和通道。Goroutines 是 Go 面向线程的轻量级方法，而通道是 goroutines 之间通信的优先方式。</li>
<li>编译时间很快</li>
</ul>
<h3 id="go的缺点"><a href="#go的缺点" class="headerlink" title="go的缺点"></a>go的缺点</h3><ul>
<li>错误处理。没有python的try expect,只能用error来返回</li>
<li>不支持类型继承</li>
<li>不支持任何方法或运算符重载</li>
</ul>
<h3 id="Go的错误处理机制"><a href="#Go的错误处理机制" class="headerlink" title="Go的错误处理机制"></a>Go的错误处理机制</h3><p>对于预期的错误函数可以返回内置的接口error类型，对于未知的异常panic，可以通过defer和revover协作进行捕获。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDeferAndRecover</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> err:=<span class="built_in">recover</span>(); err != <span class="literal">nil</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;异常信息为:&quot;</span>,err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()    </span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;发生恐慌了&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// 异常信息为: 发生恐慌了</span></span><br></pre></td></tr></table></figure>

<p>我们可以在 defer 中通过 recover 关键字恢复我们的恐慌，将之处理，转化为一个错误并打印，否则将导致整个 go 程序终止。</p>
<h2 id="协程间的通信"><a href="#协程间的通信" class="headerlink" title="协程间的通信"></a>协程间的通信</h2><ol>
<li><p>共享变量</p>
<p> 在Go中并不提倡这样做，因为这种方式给所有的共享内存的多线程都带来了困难。</p>
</li>
<li><p><a href="https://zengweigang.gitbooks.io/core-go/content/eBook/14.2.html">通道</a></p>
<p> 通道实际上是类型化消息的队列：使数据得以传输。它是先进先出的结构所以可以保证发送给他们的元素的顺序。</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">identifier := <span class="built_in">make</span>(<span class="keyword">chan</span> datatype)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Golang-是如何实现-Map-的？"><a href="#Golang-是如何实现-Map-的？" class="headerlink" title="Golang 是如何实现 Map 的？"></a>Golang 是如何实现 Map 的？</h2><h3 id="一般的Map是如何实现的"><a href="#一般的Map是如何实现的" class="headerlink" title="一般的Map是如何实现的"></a>一般的Map是如何实现的</h3><p>一般的Map会包含两个主要结构：</p>
<ul>
<li>数组：数组里的值指向一个链表</li>
<li>链表：目的解决hash冲突的问题，并存放键值<br>大致结构如下：</li>
</ul>
<p><img src="/2022/03/28/interview-Golang/map.webp" alt="image"></p>
<p>读取一个key值的过程大致如下：</p>
<ul>
<li>key通过hash函数得到key的hash值</li>
<li>key的hash值通过取模或者位操作得到key在数组上的索引</li>
<li>通过索引找到对应的链表</li>
<li>遍历链表对比key和目标key</li>
<li>相等则返回value</li>
</ul>
<h3 id="Go语言里Map的实现思路"><a href="#Go语言里Map的实现思路" class="headerlink" title="Go语言里Map的实现思路"></a>Go语言里Map的实现思路</h3><p>哈希表的数据结构中一些关键字段如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Hmap</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8</span>   B;    <span class="comment">// 可以容纳2^B个项</span></span><br><span class="line">    <span class="type">uint16</span>  bucketsize;   <span class="comment">// 每个桶的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>    *buckets;     <span class="comment">// 2^B个Buckets的数组</span></span><br><span class="line">    <span class="type">byte</span>    *oldbuckets;  <span class="comment">// 前一个buckets，只有当正在扩容时才不为空</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>具体的Bucket结构如下所示：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Bucket</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8</span>  tophash[BUCKETSIZE]; <span class="comment">// hash值的高8位....低位从bucket的array定位到bucket</span></span><br><span class="line">    Bucket *overflow;           <span class="comment">// 溢出桶链表，如果有</span></span><br><span class="line">    <span class="type">byte</span>   data[<span class="number">1</span>];             <span class="comment">// BUCKETSIZE keys followed by BUCKETSIZE values</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中BUCKETSIZE是用宏定义的8，每个bucket中存放最多8个key&#x2F;value对, 如果多于8个，那么会申请一个新的bucket，并将它与之前的bucket链起来。</p>
<p>此外，溢出指针是为了解决哈希冲突，每一个bucket 里面的溢出指针 会指向另外一个 bucket ，每一个bucket 里面存放的是 8 个 key 和 8 个 value ，bucket 里面的溢出指针又指向另外一个bucket，用类似链表的方式将他们连接起来。</p>
<p>map具体查询的过程为：</p>
<ol>
<li>按key的类型采用相应的hash算法得到key的hash值。</li>
<li>将hash值的低位当作Hmap结构体中buckets数组的index，找到key所在的bucket。</li>
<li>将hash的高8位存储在了bucket的tophash中。注意，这里高8位不是用来当作key&#x2F;value在bucket内部的offset的，而是作为一个主键，在查找时对tophash数组的每一项进行顺序匹配的。</li>
<li>先比较hash值高位与bucket的tophash[i]是否相等，如果相等则再比较bucket的第i个的key与所给的key是否相等。如果相等，则返回其对应的value.</li>
<li>反之，在overflow buckets中按照上述方法继续寻找</li>
</ol>
<h2 id="Map-是线程安全的吗？怎么解决它的并发安全问题？"><a href="#Map-是线程安全的吗？怎么解决它的并发安全问题？" class="headerlink" title="Map 是线程安全的吗？怎么解决它的并发安全问题？"></a>Map 是线程安全的吗？怎么解决它的并发安全问题？</h2><p>首先，Map不是线程安全的，在同一时间段内，让不同 goroutine 中的代码，对同一个字典进行读写操作是不安全的。字典值本身可能会因这些操作而产生混乱，相关的程序也可能会因此发生不可预知的问题。</p>
<p>有一些安全使用Map的方法：</p>
<h3 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h3><p>它的存、取、删等操作都可以基本保证在常数时间内执行完毕。换句话说，它们的算法复杂度与map类型一样都是O(1)的。与单纯使用原生map和互斥锁的方案相比，使用sync.Map可以显著地减少锁的争用。sync.Map本身虽然也用到了锁，但是，它其实在尽可能地避免使用锁。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ma sync.Map<span class="comment">// 该类型是开箱即用，只需要声明既可</span></span><br><span class="line">ma.Store(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>) <span class="comment">// 存储值</span></span><br><span class="line">ma.Delete(<span class="string">&quot;key&quot;</span>) <span class="comment">//删除值</span></span><br><span class="line">ma.LoadOrStore(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>)<span class="comment">// 获取值，如果没有则存储</span></span><br><span class="line">fmt.Println(ma.Load(<span class="string">&quot;key&quot;</span>))<span class="comment">//获取值</span></span><br></pre></td></tr></table></figure>

<h3 id="增加同步机制"><a href="#增加同步机制" class="headerlink" title="增加同步机制"></a>增加同步机制</h3><p>可以使用<code>sync.RWMutex</code>来保证访问数据的安全性，举例如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过匿名结构体声明了一个变量counter，变量中包含了map和sync.RWMutex</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"><span class="comment">// 读取数据的时候使用读锁</span></span><br><span class="line">counter.RLock()</span><br><span class="line">n := counter.m[<span class="string">&quot;Tony&quot;</span>]</span><br><span class="line">counter.RUnlock()</span><br><span class="line"><span class="comment">// 写数据的使用使用写锁</span></span><br><span class="line">counter.Lock()</span><br><span class="line">counter.m[<span class="string">&quot;Tony&quot;</span>]++</span><br><span class="line">counter.Unlock()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>interview-OperatorSystem</title>
    <url>/2022/03/18/interview-OperatorSystem/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="线程间同步方式"><a href="#线程间同步方式" class="headerlink" title="线程间同步方式"></a>线程间同步方式</h3><p>  互斥量、信号量、条件变量 </p>
<h3 id="进程与线程的本质区别、以及各自的使用场景。"><a href="#进程与线程的本质区别、以及各自的使用场景。" class="headerlink" title="进程与线程的本质区别、以及各自的使用场景。"></a>进程与线程的本质区别、以及各自的使用场景。</h3><ul>
<li>需要频繁创建销毁的优先用线程（进程的创建和销毁开销过大） 这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的。 </li>
<li>需要稳定性，则考虑进程。比如可能存在一些网页不符合编程规范，容易崩溃，采用多进程一个网页崩溃不会影响其他网页；而采用多线程会。</li>
</ul>
<h3 id="进程调度算法的特点以及使用场景"><a href="#进程调度算法的特点以及使用场景" class="headerlink" title="进程调度算法的特点以及使用场景"></a>进程调度算法的特点以及使用场景</h3><ul>
<li><p>批处理系统 </p>
<p>先来先服务：利于长作业</p>
<p>短作业优先：长作业可能饿死 </p>
<p>最短剩余时间优先：可抢占、每个进程包含优先级和要求运行时间。 </p>
<p>高响应比优先调度算法：R&#x3D;（等待时间+需要时间）&#x2F;需要时间 </p>
</li>
<li><p>交互式系统 </p>
<p>时间片轮转：时间片小，进程切换消耗大；时间片大，实时性无法保证。 </p>
<p>优先级调度：防止低优先级饿死，随时间增加等待进程的优先级。 </p>
<p>多级反馈队列：不同队列优先级不同、时间片大小不同。 </p>
</li>
<li><p>实时系统 </p>
<p>软实时：请求允许一定超时 </p>
<p>硬实时：请求必须满足绝对的截止时间</p>
</li>
</ul>
<h3 id="操作系统页面置换算法"><a href="#操作系统页面置换算法" class="headerlink" title="操作系统页面置换算法"></a>操作系统页面置换算法</h3><ul>
<li><p>最佳置换算法 </p>
<p>要换出的页面为最长时间不再被访问的页面，可保证最低缺页率。 </p>
</li>
<li><p>最近最久未使用（LRU） </p>
<p>要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。 </p>
</li>
<li><p>最近未使用（NRU）或时钟算法 </p>
<p>每个页面都有两个状态位：R与M，当页面被访问时设置页面的R＝1，当页面被修改时设置M＝1。其中R位会定时被清零。可以将页面分成以下四类：</p>
<p>R&#x3D;0,M&#x3D;0</p>
<p>R&#x3D;0,M&#x3D;1</p>
<p>R&#x3D;1,M&#x3D;0</p>
<p>R&#x3D;1,M&#x3D;1</p>
<p>当发生缺页中断时，NRU算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p>
<p>NRU优先换出已经被修改的脏页面（R＝0，M＝1），而不是被频繁使用的干净页面（R＝1，M＝0）。</p>
</li>
<li><p>先进先出FIFO</p>
</li>
</ul>
<h3 id="进程间有哪些通信方式？"><a href="#进程间有哪些通信方式？" class="headerlink" title="进程间有哪些通信方式？"></a>进程间有哪些通信方式？</h3><ul>
<li><p>管道 </p>
<p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序地将数据写入缓冲区，另一端的进程则顺序地读出数据。</p>
<p>管道的用法： </p>
<ol>
<li><p>父进程创建管道，得到两个文件描述符指向管道的两端。使用函数 <code>int pipe(int fd[2])</code> </p>
</li>
<li><p>利用fork函数创建出子进程，则子进程也得到两个文件描述符指向同一管道</p>
</li>
<li><p>父进程关闭读端<code>pipe[0]</code>,子进程关闭写端<code>pipe[1]</code>，则此时父进程可以往管道中进行写操作，子进程可以从管道中读，从而实现了通过管道的进程间通信。</p>
</li>
</ol>
<p><img src="/2022/03/18/interview-OperatorSystem/pipe.png"></p>
</li>
<li><p>FIFO命名管道 </p>
<p>命名管道以文件的形式存在，由于有一个路径名，使用没有亲缘关系的进程间也可以使用命名管道。去除了只能在父子进程中使用的限制 </p>
</li>
<li><p>消息队列 </p>
<p>消息队列可以独立于读写进程存在，从而避免了FIFO 中同步管道的打开和关闭时可能产生的困难；避免了FIFO 的同步阻塞问题，不需要进程自己提供同步方法；读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 </p>
</li>
<li><p>信号量 </p>
</li>
<li><p>共享内存 </p>
<p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。需要使用信号量用来同步对共享存储的访问。 </p>
</li>
<li><p>套接字 </p>
<p>它可用于不同机器间的进程通信</p>
</li>
</ul>
<h3 id="死锁必要条件、解决死锁策略"><a href="#死锁必要条件、解决死锁策略" class="headerlink" title="死锁必要条件、解决死锁策略"></a>死锁必要条件、解决死锁策略</h3><p>  死锁必要条件：互斥、占用并保持、不可剥夺、环路等待。 </p>
<p>  处理方法： </p>
<ul>
<li><p>鸵鸟策略 </p>
<p>Linux、Windows都是选择忽略死锁。 </p>
</li>
<li><p>死锁检测和死锁恢复 </p>
<p>每种类型一个资源的死锁检测：在资源分配图中检测有向图是否存在环。 </p>
<p>每种类型多个资源的死锁检测：类似死锁避免。 </p>
</li>
<li><p>死锁预防——破坏死锁的必要条件 </p>
<p>破坏互斥条件：例如SPOOLing技术将独占设备改为共享设备 </p>
<p>破坏占用并保持：规定所有进程在开始执行前请求所需要的全部资源 </p>
<p>破坏不可抢占 </p>
<p>破坏环路等待：给资源统一编号，进程只能按编号顺序来请求资源 </p>
</li>
<li><p>死锁避免 </p>
<p>银行家算法</p>
</li>
</ul>
<h3 id="简述操作系统中-malloc-的实现原理"><a href="#简述操作系统中-malloc-的实现原理" class="headerlink" title="简述操作系统中 malloc 的实现原理"></a>简述操作系统中 malloc 的实现原理</h3><ul>
<li><p>当开辟的空间小于 128K 时，调用 <code>brk()</code>函数，malloc 的底层实现是系统调用函数<code>brk()</code>，其主要移动指针 <code>_enddata</code>(此时的 <code>_enddata</code> 指的是 Linux 地址空间中堆段的末尾地址，不是数据段的末尾地址) </p>
</li>
<li><p>当开辟的空间大于 128K 时，<code>mmap()</code>系统调用函数来在虚拟地址空间中（堆和栈中间，称为“文件映射区域”的地方）找一块空间来开辟。 </p>
<p>这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系，之后再重新执行发生中断时的指令。</p>
</li>
<li><p>具体分配过程： </p>
<ul>
<li><p>情况一：malloc 小于 128K 的内存，使用 brk 分配 </p>
<p><img src="/2022/03/18/interview-OperatorSystem/brk.png"></p>
<p>malloc函数会调用brk系统调用，将_edata指针往高地址推30K，就完成虚拟内存分配。事实是：_edata+30K只是完成虚拟地址的分配，A这块内存现在还是没有物理页与之对应的，等到进程第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页。也就是说，如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的。 </p>
<p>由于<code>brk/sbrk/mmap</code>属于系统调用，如果每次申请内存，都调用这三个函数中的一个，那么每次都要产生系统调用开销（即cpu从用户态切换到内核态的上下文切换，这里要保存用户态数据，等会还要切换回用户态），这是非常影响性能的；其次，这样申请的内存容易产生碎片，因为堆是从低地址到高地址，如果低地址的内存没有被释放，高地址的内存就不能被回收。</p>
<p>鉴于此，malloc采用的是内存池的实现方式，malloc内存池实现方式更类似于STL分配器和memcached的内存池，先申请一大块内存，然后将内存分成不同大小的内存块，然后用户申请内存时，直接从内存池中选择一块相近的内存块即可。 </p>
<p><img src="/2022/03/18/interview-OperatorSystem/malloc.png"></p>
</li>
<li><p>情况二：malloc 大于 128K 的内存，使用 mmap 分配 </p>
<p>  <img src="/2022/03/18/interview-OperatorSystem/mmap.png"></p>
<p>brk分配的内存需要等到高地址内存释放以后才能释放，而mmap分配的内存可以单独释放。</p>
</li>
</ul>
</li>
</ul>
<h3 id="线程有多少种状态，状态之间如何转换"><a href="#线程有多少种状态，状态之间如何转换" class="headerlink" title="线程有多少种状态，状态之间如何转换"></a>线程有多少种状态，状态之间如何转换</h3><p>Java中线程的状态分为6种。</p>
<ol>
<li><p>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法</p>
</li>
<li><p>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</p>
</li>
<li><p>阻塞(BLOCKED)：表示线程阻塞于锁。</p>
</li>
<li><p>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p>
</li>
<li><p>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</p>
</li>
<li><p>终止(TERMINATED)：表示该线程已经执行完毕。</p>
</li>
</ol>
<p>状态详细说明：</p>
<ol>
<li><p>初始状态(NEW)</p>
<p> 实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p>
</li>
<li><p>就绪状态(RUNNABLE之READY)</p>
<ul>
<li><p>就绪状态只是说你资格运行，调度程序(Cpu)没有挑选到你，你就永远是就绪状态。</p>
</li>
<li><p>调用线程的start()方法，此线程进入就绪状态。</p>
</li>
<li><p>当前线程sleep()方法结束、其他线程join()结束、等待用户输入完毕、某个线程拿到对象锁时，将进入就绪状态。</p>
</li>
<li><p>当前线程时间片用完了、调用当前线程的yield()方法，当前线程进入就绪状态。</p>
</li>
<li><p>锁池里的线程拿到对象锁后，进入就绪状态。</p>
</li>
</ul>
</li>
<li><p>运行中状态(RUNNABLE之RUNNING)</p>
<p> 线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</p>
</li>
<li><p>阻塞状态(BLOCKED)</p>
<p> 阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p>
</li>
<li><p>等待(WAITING)</p>
<p> 处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p>
</li>
<li><p>终止状态(TERMINATED)</p>
<p> 当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。</p>
<p> 在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p>
</li>
</ol>
<h3 id="简述创建进程的流程"><a href="#简述创建进程的流程" class="headerlink" title="简述创建进程的流程"></a>简述创建进程的流程</h3><ul>
<li><p>fork() </p>
<p>在系统中表示一个进程的实体是进程控制块，创建新进程的主要工作就是要创建一个新控制块，而创建一个新控制块最简单的方法就是复制。 </p>
<p><img src="/2022/03/18/interview-OperatorSystem/fork.png"></p>
<p>父进程和子进程运行的是同一个程序，也正是这个理由，系统并未在内存中给子进程配置独立的程序运行空间，而只是简单地将程序指针指向父进程的代码； </p>
<p>两个进程具有各自的数据区和用户堆栈，在函数fork()生成子进程时，将父进程数据区和用户堆栈的内容分别复制给了子进程。 </p>
</li>
<li><p>exec() </p>
<p>如果一个进程调用了execv()，那么该函数便会把函数参数path所指定的可执行文件加载到进程的用户内存空间，并覆盖掉原文件，然后便运行这个新加载的可执行文件。通常调用execv()的都是子进程。调用execv()后，父进程与子进程存储结构的示意图如下： </p>
<p><img src="/2022/03/18/interview-OperatorSystem/exec.png"></p>
</li>
<li><p>wait() </p>
<p>由于子进程毕竟由父进程所创建，父进程需要在子进程结束之后释放子进程所占用的系统资源。那么为了保证完成为子进程释放资源的任务，父进程应该调用系统调用wait()。</p>
<p>如果父进程先于子进程结束进程，则子进程会因为失去父进程而成为“孤儿进程”。如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程</p>
</li>
</ul>
<h3 id="如何设计一个线程池？"><a href="#如何设计一个线程池？" class="headerlink" title="如何设计一个线程池？"></a>如何设计一个线程池？</h3><ul>
<li><p>是什么 </p>
<p>线程池使用了池化技术，将线程存储起来放在一个 池子 （容器）里面，来了任务可以用已有的空闲的线程进行处理， 处理完成之后，归还到容器，可以复用。如果线程不够，还可以根据规则动态增加，线程多余的时候，亦可以让多余的线程死亡。 </p>
</li>
<li><p>为什么 </p>
<ul>
<li>降低资源消耗：池化技术可以重复利用已经创建的线程，降低线程创建和销毁的损耗。 </li>
<li>提高响应速度：利用已经存在的线程进行处理，少去了创建线程的时间 </li>
<li>管理线程可控：线程是稀缺资源，不能无限创建，线程池可以做到统一分配和监控 </li>
<li>拓展其他功能：比如定时线程池，可以定时执行任务</li>
</ul>
</li>
<li><p>设计以及需要考虑的点 </p>
<ul>
<li>线程池状态： <ul>
<li>有哪些状态？如何维护状态？</li>
</ul>
</li>
<li>线程 <ul>
<li>线程怎么封装？线程放在哪个池子里？ </li>
<li>线程怎么取得任务？ </li>
<li>线程有哪些状态？ </li>
<li>线程的数量怎么限制？动态变化？自动伸缩？ </li>
<li>线程怎么消亡？如何重复利用？</li>
</ul>
</li>
<li>任务 <ul>
<li>任务少可以直接处理，多的时候，放在哪里？ </li>
<li>任务队列满了，怎么办？ </li>
<li>用什么队列？</li>
</ul>
</li>
</ul>
</li>
<li><p>如何做</p>
</li>
</ul>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>awk </p>
</li>
<li><p>sed </p>
</li>
<li><p>grep </p>
</li>
<li><p>head </p>
<p>用法：<code>head [-n lines | -c bytes] [file ...] </code></p>
<p>例子：<br>显示文件的前n行  <code>head -n 10 file.txt</code></p>
</li>
<li><p>wc </p>
<p>用途：可以计算文件的Byte数、行数、或是列数(单词数) </p>
<p>用法：<code>wc [-clw][文件...]</code></p>
</li>
<li><p>tr </p>
<p>用途：用于转换或删除文件中的字符。 </p>
<p>用法：<code>tr [-cdst][第一字符集][第二字符集]</code></p>
<p>例子：输入字符小写转大写 <code>echo HELLO WORLD | tr &#39;A-Z&#39; &#39;a-z&#39;</code></p>
</li>
<li><p>sort </p>
<p>用途：将文本文件内容加以排序。 </p>
</li>
<li><p>uniq </p>
<p>用途：用于检查及删除文本文件中重复出现的行列 </p>
</li>
<li><p>top </p>
<p>实时显示系统中各个进程的资源占用状况 </p>
<p><img src="/2022/03/18/interview-OperatorSystem/top.png"></p>
</li>
<li><p>lsof </p>
<p>(list open file) </p>
<p><code>lsof -i:端口号</code> 用于查看当前端口号被占用情况 </p>
</li>
<li><p>tail </p>
<p><code>tail -f 文件名</code> 用于实时显示xxx文件更新的内容</p>
</li>
</ul>
<h3 id="开发工具gdb"><a href="#开发工具gdb" class="headerlink" title="开发工具gdb"></a>开发工具gdb</h3><ul>
<li><p>准备 </p>
<p>gdb调试时，首先要在编译时将调试信息加到可执行文件中。</p>
<p>使用编译器（cc&#x2F;gcc&#x2F;g++）的 -g 参数可以做到这一点。如：<code>gcc -g hello.c -o hello </code></p>
</li>
<li><p>启动 </p>
<ul>
<li>gdb program<br>直接加可执行程序即可 </li>
<li>gdb program core </li>
<li>gdb program pid_num<br>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他</li>
</ul>
</li>
<li><p>运行 </p>
<p><img src="/2022/03/18/interview-OperatorSystem/gdb_run.png"></p>
</li>
<li><p>断点 </p>
<p><img src="/2022/03/18/interview-OperatorSystem/gdb_bp.png"></p>
</li>
<li><p>查看源代码 </p>
<p><img src="/2022/03/18/interview-OperatorSystem/gdb_list.png"></p>
</li>
<li><p>打印表达式 </p>
<p><img src="/2022/03/18/interview-OperatorSystem/gdb_print.png"></p>
</li>
<li><p>查询运行信息 </p>
<p><img src="/2022/03/18/interview-OperatorSystem/gdb_runing.png"></p>
</li>
</ul>
<h3 id="开发工具makefile"><a href="#开发工具makefile" class="headerlink" title="开发工具makefile"></a>开发工具makefile</h3><p>  待补充</p>
<h3 id="开发工具cmake"><a href="#开发工具cmake" class="headerlink" title="开发工具cmake"></a>开发工具cmake</h3><p>  待补充</p>
<h3 id="开发工具gcc"><a href="#开发工具gcc" class="headerlink" title="开发工具gcc"></a>开发工具gcc</h3><p>  待补充</p>
<h3 id="简述-Linux-零拷贝的原理"><a href="#简述-Linux-零拷贝的原理" class="headerlink" title="简述 Linux 零拷贝的原理"></a>简述 Linux 零拷贝的原理</h3><p>  所谓的零拷贝（Zero-Copy）是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手 。零拷贝大大提高了应用程序的性能，减少了内核和用户模式之间的上下文切换。 </p>
<p>  考虑这样一种常用的情形：你需要将静态内容(类似图片、文件)展示给用户。这个情形就意味着需要先将静态内容从磁盘中复制出来放到一个内存 buf 中，然后将这个 buf 通过套接字（Socket）传输给用户，进而用户获得静态内容。流程图如下： </p>
<p>  <img src="/2022/03/18/interview-OperatorSystem/zero_copy1.png"></p>
<p>  如果采用了零拷贝技术，那么应用程序可以直接请求内核把磁盘中的数据传输给 Socket, 如下图所示。</p>
<p>  <img src="/2022/03/18/interview-OperatorSystem/zero_copy2.png"></p>
<p>  改进的地方：我们将上下文切换的次数从四次减少到了两次，将数据复制的次数从四次减少到了三次。但是这种方案尚未达到我们的零拷贝要求。真正的零拷贝如下： </p>
<ul>
<li><code>transferTo()</code> 方法引发 DMA 引擎将文件内容拷贝到内核缓冲区。 </li>
<li>数据未被拷贝到套接字缓冲区。取而代之的是，只有包含关于数据的位置和长度的信息的描述符被追加到了套接字缓冲区。DMA 引擎直接把数据从内核缓冲区传输到协议引擎，从而消除了剩下的最后一次 CPU 拷贝。<br>  <img src="/2022/03/18/interview-OperatorSystem/zero_copy3.png"></li>
</ul>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a><a href="https://leetcode-cn.com/problemset/shell/">Shell</a></h2>]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Operator System</tag>
      </tags>
  </entry>
  <entry>
    <title>interview_algorithm</title>
    <url>/2022/03/18/interview-algorithm/</url>
    <content><![CDATA[<h3 id="随机快速排序"><a href="#随机快速排序" class="headerlink" title="随机快速排序"></a>随机快速排序</h3><p>注意，获取阀分元素的索引时，使用下面的方式可能会遇到阀分元素和其它元素一样的情况，导致错误。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int quickSortCore(vector&lt;int&gt;&amp; nums, int value, int left, int right)&#123;</span><br><span class="line">    while(left&lt;right)&#123;</span><br><span class="line">        if(nums[left]&lt;value)&#123;</span><br><span class="line">            left++;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[right]&gt;value)&#123;</span><br><span class="line">            right--;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(nums[left] == nums[right])&#123;</span><br><span class="line">            return left</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            swap(nums[left],nums[right]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确的写法 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//快速排序</span><br><span class="line">public static void QuickSort(int[] a, int left, int right) &#123;</span><br><span class="line">    if (left &lt; right) &#123;</span><br><span class="line">        int p = partition(a, left, right);</span><br><span class="line">        QuickSort(a, left, p - 1);</span><br><span class="line">        QuickSort(a, p + 1, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速排序数组划分</span><br><span class="line">private static int partition(int[] a, int left, int right) &#123;</span><br><span class="line">    int x = a[right];</span><br><span class="line">    int p = left - 1;</span><br><span class="line">    for (int i = left; i &lt; right; i++) &#123;</span><br><span class="line">        if (a[i] &lt;= x) &#123;</span><br><span class="line">            p++;</span><br><span class="line">            swap(a, p, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, p+1, right);</span><br><span class="line">    return p+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></h3><p>思路：第一维升序排序，第二维求最长严格递增子序列</p>
<h3 id="单调栈和单调队列的应用"><a href="#单调栈和单调队列的应用" class="headerlink" title="单调栈和单调队列的应用"></a>单调栈和单调队列的应用</h3><ul>
<li><p>单调栈 </p>
<p>以O(n)时间复杂度求出某个数的左边或右边第一个比它大或小的元素。</p>
</li>
<li><p>单调队列 </p>
<p>区间最小（最大）值问题</p>
</li>
</ul>
<h3 id="求滑动窗口的最大值"><a href="#求滑动窗口的最大值" class="headerlink" title="求滑动窗口的最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">求滑动窗口的最大值</a></h3><h3 id="10亿个数中如何高效地找到最大的一个数、最大的第K个数或者频率最大的第k个数？"><a href="#10亿个数中如何高效地找到最大的一个数、最大的第K个数或者频率最大的第k个数？" class="headerlink" title="10亿个数中如何高效地找到最大的一个数、最大的第K个数或者频率最大的第k个数？"></a>10亿个数中如何高效地找到最大的一个数、最大的第K个数或者频率最大的第k个数？</h3><p>高效指的是：最小的时间复杂度和最小的空间复杂度 </p>
<p>首先10亿个数如果全部保存在内存中，需要的空间大小为10^9*4B ≈ 4GB，内存中是无法完全存放的，所以这些数据首先应该都在外存上，我们分批次读进内存，得到每个批次的最大值，之后再比较所有批次的最大值即可。可以将1000份，每份的大小约为4MB。 </p>
<p>如果是TopK，则在内存中维护一个小根堆，分批次读进内存之后，依次遍历与小根堆的顶元素进行比较即可。<br>如果是TopK词频问题，有如下的思路： </p>
<ul>
<li>先将数据集按照Hash方法分解成多个小数据集（保证两个数据集不会出现相同的单词） </li>
<li>然后使用Trie树或者Hash统计每个小数据集中的query词频 </li>
<li>之后用小顶堆求出每个数据集中出频率最高的前K个数 </li>
<li>最后在所有top K中求出最终的top K。</li>
</ul>
<h3 id="rand7-实现rand10"><a href="#rand7-实现rand10" class="headerlink" title="rand7()实现rand10()"></a>rand7()实现rand10()</h3><p>  使用拒绝采样。 </p>
<p>  我们可以调用两次 Rand7()，那么可以生成 [1,49] 之间的随机整数，我们只用到其中的前 40 个用来实现 Rand10()，而拒绝剩下的 9 个数 </p>
<h3 id="rand65535-实现30万人中抽奖1万人"><a href="#rand65535-实现30万人中抽奖1万人" class="headerlink" title="rand65535()实现30万人中抽奖1万人"></a>rand65535()实现30万人中抽奖1万人</h3><p>同上</p>
<h3 id="10亿条数据包括-id，上线时间，下线时间，请绘制每一秒在线人数的曲线图"><a href="#10亿条数据包括-id，上线时间，下线时间，请绘制每一秒在线人数的曲线图" class="headerlink" title="10亿条数据包括 id，上线时间，下线时间，请绘制每一秒在线人数的曲线图"></a>10亿条数据包括 id，上线时间，下线时间，请绘制每一秒在线人数的曲线图</h3><p>  定义一个24<em>60</em>60的数组，来存放每一秒的上线人数 遍历数据，根据上线时间和下线时间，获取数组范围，并将数组中间所有元素+1 时间复杂度：O(MN) </p>
<h3 id="给定一个包含-40-亿个无符号整数的大型文件，使用最多-1G-内存，对此文件进行去重排序"><a href="#给定一个包含-40-亿个无符号整数的大型文件，使用最多-1G-内存，对此文件进行去重排序" class="headerlink" title="给定一个包含 40 亿个无符号整数的大型文件，使用最多 1G 内存，对此文件进行去重排序"></a>给定一个包含 40 亿个无符号整数的大型文件，使用最多 1G 内存，对此文件进行去重排序</h3><p>  40亿 * 4B ≈ 16G，利用位图法。</p>
<h3 id="海量数据面试题"><a href="#海量数据面试题" class="headerlink" title="海量数据面试题"></a>海量数据面试题</h3><p>  <a href="https://blog.csdn.net/v_JULY_v/article/details/6279498">https://blog.csdn.net/v_JULY_v/article/details/6279498</a> </p>
<h3 id="最长递增子序列（要求时间复杂度为O-nlgn"><a href="#最长递增子序列（要求时间复杂度为O-nlgn" class="headerlink" title="最长递增子序列（要求时间复杂度为O(nlgn)"></a>最长递增子序列（要求时间复杂度为O(nlgn)</h3><p>一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。 </p>
<p>基于上面的贪心思路，我们维护一个数组 d[i] ，表示长度为 i 的最长上升子序列的末尾元素的最小值。我们依次遍历数组 nums 中的每个元素，并更新数组 d 和 len 的值。如果 nums[i] &gt; d[len] 则更新 len&#x3D;len+1，否则在 d[1…len]中找满足 d[i - 1] &lt; nums[j] &lt; d[i] 的下标 i，并更新d[i]&#x3D;nums[j]。<br>举例说明： </p>
<p><img src="/2022/03/18/interview-algorithm/LIS-example.png"></p>
]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>interview-SystemDesign</title>
    <url>/2022/03/20/interview-SystemDesign/</url>
    <content><![CDATA[<h2 id="系统设计基础"><a href="#系统设计基础" class="headerlink" title="系统设计基础"></a>系统设计基础</h2><h3 id="如何对系统的性能进行优化？"><a href="#如何对系统的性能进行优化？" class="headerlink" title="如何对系统的性能进行优化？"></a>如何对系统的性能进行优化？</h3><ul>
<li><p>集群 </p>
<p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。 </p>
</li>
<li><p>缓存 </p>
</li>
<li><p>异步</p>
</li>
</ul>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p><img src="/2022/03/20/interview-SystemDesign/DL.png"></p>
<h4 id="分布式锁的三种常用实现"><a href="#分布式锁的三种常用实现" class="headerlink" title="分布式锁的三种常用实现"></a>分布式锁的三种常用实现</h4><ul>
<li><p>数据库的唯一索引 </p>
<p>  创建一张锁表，定义方法或者资源名、失效时间等字段，同时针对加锁的信息添加唯一索引，比如方法名，当要锁住某个方法或资源时，就在该表中插入对应方法的一条记录，插入成功表示获取了锁，想要释放锁的时候就删除这条记录。 </p>
<p>但是这种方案有一些问题： </p>
<ul>
<li><p>存在单点故障风险 </p>
<p>一旦数据库挂掉，则会导致业务系统不可用，为了解决这个问题，需要配置数据库主从机器，防止单点故障。 </p>
</li>
<li><p>超时无法失效 </p>
<p>如果一旦解锁操作失败，则会导致锁记录一直在数据库中，其他线程无法再获得锁，解决这个问题，可以添加独立的定时任务，通过时间戳对比等方式，删除超时数据。 </p>
</li>
<li><p>不可重入 </p>
<p>可重入性是锁的一个重要特性。同一个线程在没有释放锁之前无法再次获得该锁，因为数据已经存在，再次插入会失败。实现可重入，需要改造加锁方法，额外存储和判断线程信息，不阻塞获得锁的线程再次请求加锁。 </p>
</li>
<li><p>无法实现阻塞 </p>
<p>其他线程在请求对应方法时，插入数据失败会直接返回，不会阻塞线程，如果需要阻塞其他线程，需要不断的重试 insert 操作，直到数据插入成功，这个操作是服务器和数据库资源的极大浪费。</p>
</li>
</ul>
</li>
<li><p>Redis缓存 </p>
<p>相比基于数据库实现分布式锁，缓存的性能更好，并且各种缓存组件也提供了多种集群方案，可以解决单点问题。 </p>
<p>在 Redis 中，setnx 是<code>「set if not exists」</code>如果不存在，则 SET 的意思，当一个线程执行 setnx 返回 1，说明 key 不存在，该线程获得锁；当一个线程执行 setnx 返回 0，说明 key 已经存在，那么获取锁失败，expire 就是给锁加一个过期时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(setnx(key,value)==1)&#123;</span><br><span class="line">    expire(key,expireTime)</span><br><span class="line">    try&#123;</span><br><span class="line">        //业务处理</span><br><span class="line">    &#125;finally&#123;</span><br><span class="line">        //释放锁</span><br><span class="line">        del(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 setnx 和 expire 有一个问题，这两条命令可能不会同时失败，不具备原子性，如果一个线程在执行完 setnx 之后突然崩溃，导致锁没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取。可以使用SETEX 命令，SETEX 支持 setnx 和 expire 指令组合的原子操作，解决了加锁过程中失败的问题。 </p>
</li>
<li><p>Zookeeper </p>
<p>ZooKeeper 有四种节点类型，包括持久节点、持久顺序节点、临时节点和临时顺序节点，利用 ZooKeeper 支持临时顺序节点的特性，可以实现分布式锁。 </p>
<p>当客户端对某个方法加锁时，在 ZooKeeper 中该方法对应的指定节点目录下，生成一个唯一的临时有序节点。 </p>
<ul>
<li>使用zk的临时节点和有序节点，每个线程获取锁就是在zk创建一个临时有序的节点，比如在&#x2F;lock&#x2F;目录下。 </li>
<li>创建节点成功后，获取&#x2F;lock目录下的所有临时节点，再判断当前线程创建的节点是否是所有的节点的序号最小的节点 </li>
<li>如果当前线程创建的节点是所有节点序号最小的节点，则认为获取锁成功。 </li>
<li>如果当前线程创建的节点不是所有节点序号最小的节点，则对节点序号的前一个节点添加一个事件监听。</li>
</ul>
<p>优点：ZooKeeper分布式锁（如InterProcessMutex），能有效的解决分布式问题，不可重入问题，使用起来也较为简单。 </p>
<p>缺点：ZooKeeper实现的分布式锁，性能并不太高。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。大家知道，ZK中创建和删除节点只能通过Leader服务器来执行，然后Leader服务器还需要将数据同步到所有的Follower机器上，这样频繁的网络通信，性能的短板是非常突出的。总之，在高性能，高并发的场景下，不建议使用ZooKeeper的分布式锁。 </p>
</li>
<li><p>如何选择？ </p>
<p>（1）基于ZooKeeper的分布式锁，适用于高可靠（高可用）而并发量不是太大的场景； </p>
<p>（2）基于Redis的分布式锁，适用于并发量很大、性能要求很高的、而可靠性问题可以通过其他方案去弥补的场景。 </p>
</li>
<li><p>参考：<a href="https://www.cnblogs.com/crazymakercircle/p/14504520.html">https://www.cnblogs.com/crazymakercircle/p/14504520.html</a></p>
</li>
</ul>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ul>
<li><p>实例 </p>
<p>例如，在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。库存和订单要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。 </p>
</li>
<li><p>如何实现分布式事务？ </p>
<p>多个服务同时访问多个数据源的事务处理机制 </p>
<ul>
<li><p>本地消息表 </p>
<p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。 </p>
<ol>
<li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。 </li>
<li>之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。 </li>
<li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li>
</ol>
<p><img src="/2022/03/20/interview-SystemDesign/local.png"></p>
</li>
<li><p>2PC </p>
<p>两阶段提交协议的目标在于为分布式系统保证数据的一致性，该协议将一个分布式的事务过程拆分成两个阶段： 投票 和 事务提交 。为了让整个数据库集群能够正常的运行，该协议指定了一个 协调者 单点，用于协调整个数据库集群各节点的运行。 </p>
<ul>
<li><p>运行过程 </p>
<p>1、第一阶段——投票 </p>
<p>该阶段的主要目的在于打探数据库集群中的各个参与者是否能够正常的执行事务，具体步骤如下： </p>
<ul>
<li>协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果； </li>
<li>事务参与者收到请求之后，执行事务但不提交，并记录事务日志； </li>
<li>参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。</li>
</ul>
<p>2、第二阶段——事务提交 </p>
<p>在经过第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在 3 种可能性： </p>
<ul>
<li><p>所有的参与者都回复能够正常执行事务。 </p>
<p><img src="/2022/03/20/interview-SystemDesign/2PC1.png"></p>
</li>
<li><p>一个或多个参与者回复事务执行失败。</p>
</li>
</ul>
<p><img src="/2022/03/20/interview-SystemDesign/2PC2.png"></p>
<ul>
<li>协调者等待超时。<br>同上。</li>
</ul>
</li>
<li><p>存在的问题 </p>
<ul>
<li><p>同步阻塞 </p>
<p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。 </p>
</li>
<li><p>单点问题 </p>
<p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响 </p>
</li>
<li><p>数据不一致 </p>
<p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>  分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：PartitionTolerance），最多只能同时满足其中两项。 </p>
<ul>
<li><p>一致性： </p>
<p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。 </p>
</li>
<li><p>可用性： </p>
<p>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。 </p>
</li>
<li><p>分区容忍性： </p>
<p>一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。</p>
</li>
</ul>
<p>  在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时： </p>
<ul>
<li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性； </li>
<li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li>
</ul>
<h3 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h3><p>  BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。 </p>
<p>  BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 </p>
<ul>
<li><p>基本可用 </p>
<p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。 </p>
</li>
<li><p>软状态 </p>
<p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延 </p>
</li>
<li><p>最终一致性 </p>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p>
</li>
</ul>
<h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><ul>
<li><p>简述 Zookeeper 基础原理以及使用场景 </p>
<p>略</p>
</li>
</ul>
<h3 id="Paxos协议"><a href="#Paxos协议" class="headerlink" title="Paxos协议"></a>Paxos协议</h3><ul>
<li><p>要解决的问题 </p>
<p>paxos的工作, 就是把一堆运行的机器协同起来, 让多个机器成为一个整体系统. 在这个系统中, 每个机器都必须让系统中的状态达成一致, 例如三副本集群如果一个机器上上传了一张图片, 那么另外2台机器上也必须复制这张图片过来, 整个系统才处于一个一致的状态. </p>
</li>
<li><p>不太完美的复制策略 </p>
<p>在paxos之前有一些复制策略用来同步不同副本集群的数据： </p>
<ul>
<li><p>主从异步复制 </p>
<p>例如，MySQL的主从复制，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主库已经提交的事务可能并没有传到从库上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。 </p>
</li>
<li><p>主从同步复制 </p>
<p>当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会受到严重的影响。而且，如果整个系统中有任何一个机器宕机, 写入就进行不下去了. 相当于系统的可用性随着副本数量指数降低. </p>
</li>
<li><p>半同步复制 </p>
<p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP&#x2F;IP往返的时间。所以，半同步复制最好在低延时的网络中使用。 </p>
<p>而且，半同步复制也会导致数据不一致情况发生，例如数据a复制到slave-1, 但没有到达slave-2; 数据b复制达到了slave-2但没有到达slave-1, 这时如果master挂掉了需要从某个slave恢复出数据, 任何一个slave都不能提供完整的数据. </p>
</li>
<li><p>多数派读写 </p>
<p>每条数据必须写入到半数以上的机器上. 每次读取数据都必须检查半数以上的机器上是否有这条数据。这种策略下, 数据可靠性足够, 宕机容忍足够, 任一机器故障也能读到全部数据。<br>举个例子, 如果有5个存储节点{a, b, c, d, e}, 一笔操作给x赋值为3(x&#x3D;3) 成功写入了abc 3个节点, 那么另外一个读, 只要联系到任意3个节点, 就一定能读到x&#x3D;3 这就是安全的.<br>然而，多数派读写也可能导致不一致的状态。<br>例如: </p>
<ul>
<li>node-1, node-2都写入了a&#x3D;x, </li>
<li>下一次更新时，node-2, node-3写入了a&#x3D;y.<br>这时, 一个要进行读取a的客户端如果联系到了node-1和node-2, 它将看到2条不同的数据.</li>
</ul>
</li>
</ul>
</li>
<li><p>paxos协议 </p>
<p>paxos可以认为是多数派读写的进一步升级, paxos中通过2次原本并不严谨的多数派读写, 实现了严谨的强一致consensus算法。于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值<br><a href="https://blog.openacid.com/algo/paxos/">https://blog.openacid.com/algo/paxos/</a></p>
</li>
</ul>
<h3 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h3><p>待补充</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h3><ul>
<li><p>轮询 </p>
<p>把每个请求轮流发送到每个服务器上。适用于每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载。 </p>
</li>
<li><p>加权轮询 </p>
<p>在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。 </p>
</li>
<li><p>最少连接 </p>
<p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。<br>最少连接算法就是将请求发送给当前最少连接数的服务器上。 </p>
</li>
<li><p>加权最少连接 </p>
<p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。 </p>
</li>
<li><p>随机算法 </p>
<p>把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。 </p>
</li>
<li><p>源地址哈希法 </p>
<p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞。</p>
</li>
</ul>
<h3 id="负载均衡器是如何实现转发的？"><a href="#负载均衡器是如何实现转发的？" class="headerlink" title="负载均衡器是如何实现转发的？"></a>负载均衡器是如何实现转发的？</h3><ul>
<li><p>http重定向 </p>
<p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。 </p>
<p>缺点： </p>
<ul>
<li><p>需要两次请求，因此访问延迟比较高； </p>
</li>
<li><p>HTTP 负载均衡器处理能力有限，会限制集群的规模。</p>
</li>
</ul>
</li>
<li><p>DNS域名解析 </p>
<p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。<br>优点：DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。<br>缺点：由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。 </p>
</li>
<li><p>反向代理服务器 </p>
<p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。<br>反向代理可以用来进行缓存、日志记录等，同时也可以用来作为负载均衡服务器。在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。 </p>
<p>优点：与其它功能集成在一起，部署简单。</p>
<p>缺点：所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。 </p>
</li>
<li><p>IP负载均衡 </p>
<p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。 </p>
<p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。 </p>
<p>优点：在内核进程中进行处理，性能比较高。</p>
<p>缺点：和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。 </p>
</li>
<li><p>数据链路层负载均衡 </p>
<p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。 </p>
<p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。 </p>
<p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p>
</li>
</ul>
<h3 id="集群下如何进行session管理的？"><a href="#集群下如何进行session管理的？" class="headerlink" title="集群下如何进行session管理的？"></a>集群下如何进行session管理的？</h3><p>  一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。 </p>
<ul>
<li><p>Sticky Session </p>
<p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。<br>缺点：当服务器宕机时，将丢失该服务器上的所有 Session。 </p>
</li>
<li><p>Session Replication </p>
<p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。<br>缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。 </p>
</li>
<li><p>Session Server </p>
<p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。 </p>
<p>优点：为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。 </p>
<p>缺点：需要去实现存取 Session 的代码。</p>
</li>
</ul>
<h2 id="攻击技术"><a href="#攻击技术" class="headerlink" title="攻击技术"></a>攻击技术</h2><h3 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h3><h3 id="跨站请求伪造"><a href="#跨站请求伪造" class="headerlink" title="跨站请求伪造"></a>跨站请求伪造</h3><h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h3><ul>
<li><p>命中率 </p>
<p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。 </p>
<p>缓存命中率越高，缓存的利用率也就越高。 </p>
</li>
<li><p>最大空间 </p>
<p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p>
</li>
</ul>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><ul>
<li><p>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用FIFO，使得最先进入的数据（最晚的数据）被淘汰。 </p>
</li>
<li><p>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。<br>实现：双向链表+哈希表 </p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/lfu-cache/">LFU</a>（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。 </p>
<p>实现：两个map</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unordered_map&lt;int,list&lt;node&gt;::iterator&gt; key_mp;</span><br><span class="line"></span><br><span class="line">unordered_map&lt;int,list&lt;node&gt;&gt; freq_mp;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><ul>
<li><p>浏览器 </p>
<p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。 </p>
</li>
<li><p>ISP </p>
<p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。 </p>
</li>
<li><p>反向代理 </p>
<p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。 </p>
</li>
<li><p>本地缓存 </p>
<p>将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。 </p>
</li>
<li><p>分布式缓存 </p>
<p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。 </p>
</li>
<li><p>数据库缓存 </p>
<p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p>
</li>
</ul>
<h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><ul>
<li><p>缓存穿透 </p>
<ul>
<li>含义：指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。 </li>
<li>危害：如果存在海量请求查询压根就不存在的数据，那么这些海量请求都会落到数据库中，数据库压力剧增，可能会导致系统崩溃 </li>
<li>解决方案： <ul>
<li>对这些不存在的数据缓存一个空数据； </li>
<li>对这类请求进行过滤。 </li>
<li>使用布隆过滤器。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存雪崩 </p>
<ul>
<li>含义：指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。 </li>
<li>危害：当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃 </li>
<li>解决方案： <ul>
<li>进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。 </li>
<li>防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。 </li>
<li>观察用户行为，合理设置缓存过期时间来实现。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存击穿 </p>
<ul>
<li>含义：指数据库原本有数据，但是缓存中没有，一般是缓存突然失效了，导致请求到达数据库。 </li>
<li>危害：如果有大量用户请求该数据，缓存没有则会去数据库请求，会引发数据库压力增大，可能会瞬间打垮。 </li>
<li>解决方案： <ul>
<li>如果是热点数据，那么可以考虑设置永远不过期。 </li>
<li>如果数据一定会过期，那么就需要在数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，要不其他线程会一直拿不到锁。</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存一致性 </p>
<p><a href="https://link.juejin.cn/?target=https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside">Cache Aside Pattern</a>思路： </p>
<ul>
<li>失效：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中 </li>
<li>命中：程序先从缓存中读取数据，如果命中，则直接返回 </li>
<li>更新：程序先更新数据库，再删除缓存</li>
</ul>
<p>关键问题在于第三点，也就是数据更新流程，为什么要先更新数据库？为什么之后要删除缓存而不是更新？ </p>
<ul>
<li><p>先更新缓存，再更新数据库 </p>
<p>从数据持久化的角度来说，数据库当然要比缓存做的好，我们也应当以数据库中的数据为主，所以需要更新数据的时候我们应当首先更新数据库，而不是缓存。 </p>
</li>
<li><p>先更新数据库，再更新缓存 </p>
<p>可能会出现两种问题： </p>
<ul>
<li><p>并发导致的不一致，例如下面的执行顺序： </p>
<ol>
<li>线程A更新了数据库 </li>
<li>线程B更新了数据库 </li>
<li>线程B更新了缓存 </li>
<li>线程A更新了缓存</li>
</ol>
</li>
<li><p>资源浪费 </p>
<p>我们不确定要更新的这个缓存项是否会被经常读取。</p>
</li>
</ul>
</li>
<li><p>先删除缓存，再更新数据库 </p>
<p>也会出现并发导致的不一致，例如下面的执行顺序： </p>
<ul>
<li>请求A删除缓存 </li>
<li>请求B读取缓存，发现不存在，从数据库中读取到旧值 </li>
<li>请求A将新值写入数据库 </li>
<li>请求B将旧值写入缓存</li>
</ul>
</li>
<li><p>先更新数据库，再删除缓存 </p>
<p>也可能出现问题，但概率很低。</p>
</li>
</ul>
<p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p>
</li>
</ul>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>一致性哈希解决了简单哈希算法在分布式哈希表（Distributed Hash Table，DHT）中存在的动态伸缩等问题 。例如：服务器数量从3增加到4，原先的key将会被导致节点映射错误。对于分布式缓存这种的系统而言，映射规则失效就意味着之前缓存的失效，若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。 </p>
<p><img src="/2022/03/20/interview-SystemDesign/hash_add.png"></p>
<ul>
<li><p>基本原理 </p>
<p>将哈希空间 [0, 2^n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上（可以选择服务器的 IP 或主机名作为键进行哈希）。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。 </p>
<p>  <img src="/2022/03/20/interview-SystemDesign/hash_ring.png"></p>
<p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如上图中新增节点cs4，只需要对t2和t4之间的数据重新进行分布即可，对于其他的对象都没有影响。 </p>
</li>
<li><p>虚拟节点 </p>
<p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。 </p>
<p>针对这个问题，我们可以通过引入虚拟节点来解决负载不均衡的问题。即将每台物理服务器虚拟为一组虚拟服务器，将虚拟服务器放置到哈希环上，如果要确定对象的服务器，需先确定对象的虚拟服务器，再由虚拟服务器确定物理服务器。</p>
</li>
</ul>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><ul>
<li><p>点对点 </p>
<p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。 </p>
</li>
<li><p>发布-订阅 </p>
<p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p>
</li>
</ul>
<h3 id="推拉模式"><a href="#推拉模式" class="headerlink" title="推拉模式"></a>推拉模式</h3><p>对于消息队列的消费者来说，主要有两种模式从消息队列获取消息，分别是push&#x2F;pull模式。push模式就是消息队列主动推送消息，pull模式就是consumer轮询拉取消息。 </p>
<ul>
<li><p>push模式的实时性非常好，因为队列收到消息以后就立即push给消费者，push模式的主要缺点是消息的消费速度取决于消费者，如果消费者的处理能力有限，push太多消息会导致消费者进程内存占满，甚至崩溃。而且消息队列服务器的负担比较重。push模式还有一个缺点是没有反馈机制，消息是否成功消费无从得知。 </p>
</li>
<li><p>pull模式正好相反，缺乏实时性，但是消息队列服务器的负担轻，消费者可以根据自己的处理速度拿消息，而且有反馈机制，如果消息消费失败会重新进入队列。目前流行的大吞吐量的消息队列比如kafka就是pull模式 </p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3></li>
<li><p>异步 </p>
<p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。 </p>
</li>
<li><p>解耦 </p>
<p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。 </p>
</li>
<li><p>削峰 </p>
<p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p>
</li>
</ul>
<h3 id="kafaka"><a href="#kafaka" class="headerlink" title="kafaka"></a>kafaka</h3><ul>
<li><p>简述 Kafka 的基本架构，如何用 Kafka 保证消息的有序性？ </p>
</li>
<li><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3></li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何实现百度搜索功能？"><a href="#如何实现百度搜索功能？" class="headerlink" title="如何实现百度搜索功能？"></a>如何实现百度搜索功能？</h3><h3 id="设计一个阻塞队列"><a href="#设计一个阻塞队列" class="headerlink" title="设计一个阻塞队列"></a>设计一个阻塞队列</h3><h3 id="容器化了解吗？它的基本原理是什么？"><a href="#容器化了解吗？它的基本原理是什么？" class="headerlink" title="容器化了解吗？它的基本原理是什么？"></a>容器化了解吗？它的基本原理是什么？</h3><h3 id="电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？"><a href="#电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？" class="headerlink" title="电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？"></a>电商系统中，如何实现秒杀功能？如何解决商品的超卖问题？</h3><ul>
<li>抢订单环节一般会带来两个问题： <ul>
<li><p>高并发 </p>
<p>比较火热的秒杀在线人数都是10w起的，如此之高的在线人数对于网站架构从前到后都是一种考验。</p>
</li>
<li><p>超卖 </p>
<p>任何商品都会有数量上限，如何避免成功下订单买到商品的人数不超过商品数量的上限，这是每个抢购活动都要面临的难题。</p>
</li>
</ul>
</li>
<li>如何解决 <ul>
<li>超卖问题 <ul>
<li><p>悲观锁 </p>
<p>处理性能不高，当一件商品有多位客户同时下单的时候，每个请求需要等待排他锁，也要较长才知道是否下单成功。 </p>
</li>
<li><p>乐观锁 </p>
<p>乐观锁因为并不需要等待锁，所以在事务竞争较少的情况下比悲观锁有更好的性能，缺点是事务竞争较多的情况下，由于经常需要回滚事务导致性能反而较差。 </p>
</li>
<li><p>分布式锁 </p>
<p>如果有多个服务器，需要加分布式锁。但是也有一些缺点：分布式锁的正确实现并不简单，错误的实现方式容易引起其他一致性的问题。2）分布式锁在高并发下也会产生锁竞争的问题，性能不佳。 </p>
</li>
<li><p>消息队列 </p>
<p>确保每个商品每个时刻只有一个请求。消息队列的优点对业务进行了解耦，除了数据库之外，其他对下单请求感兴趣的业务系统，例如数据分析，日志记录等都可以订阅下单请求的消息。缺点在于 1）因为消息队列可能会崩溃，消息发送也可能失败，所以要考虑消息只消费一次，不会因为重复消费导致重复下单。2）由于引入了新的组件，要考虑消息队列的可靠性，以及崩溃之后的恢复机制。</p>
</li>
</ul>
</li>
<li>高并发 <ul>
<li><p>流量控制 </p>
<ul>
<li><p>CDN </p>
<p>大量的客户端在下单前同时请求同一个商品的秒杀页面，导致服务器压力骤升。可以将秒杀页面使用 CDN 缓存起来，客户端就可以直接从 CDN 获取到秒杀页面，不需要重复请求服务器。 </p>
</li>
<li><p>限流器</p>
<ol>
<li>前端限流包括验证答题，防止重复点击按钮等常见机制。 </li>
<li>后端限流使用限流算法进行流量限制，简单情况下可以使用固定限流算法，例如秒杀商品的库存是 10 件，只要限流器接收到 10 * k（k 可以根据业务进行调整）个请求之后，就停止接受该商品的所有请求。</li>
</ol>
</li>
<li><p>负载均衡 </p>
<p>负载均衡负责将下单请求通过负载均衡算法转发到最合适的服务器。 </p>
</li>
<li><p>安全验证 </p>
<ol>
<li>前端安全验证包括：客户端账户验证（确保客户有资格参考秒杀活动），客户端版本安全验证（防止反编译以及修改客户端代码），秒杀接口动态生成（防止使用刷单脚本） </li>
<li>后端安全验证包括黑名单校验，IP 地址校验等机制。</li>
</ol>
</li>
</ul>
</li>
<li><p>热门资源隔离 </p>
<p>首先识别出热门商品，我们可以将热门商品的资源进行隔离，并且设置独立的策略。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何实现唯一的分布式-ID"><a href="#如何实现唯一的分布式-ID" class="headerlink" title="如何实现唯一的分布式 ID"></a>如何实现唯一的分布式 ID</h3><ul>
<li><p>为什么需要全局唯一ID？ </p>
<p>传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的ID一般我们都是从1增，通过AUTO_INCREMENT&#x3D;1设置自增起始值，但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。 </p>
<p><img src="/2022/03/20/interview-SystemDesign/ID.png"></p>
</li>
<li><p>方式 </p>
<ul>
<li><p>UUID </p>
<p>Universally Unique Identifier，通用唯一识别码的缩写。UUID是由一组32位数的16进制数字所构成。有一些不同的uuid产生方式： </p>
<ul>
<li>基于时间的uuid </li>
<li>基于名字的uuid </li>
<li>随机uuid</li>
</ul>
<p>但是uuid也有一些缺点： </p>
<ul>
<li>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。 </li>
<li>对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能</li>
</ul>
</li>
<li><p>数据库生成 </p>
<p>我们可以在分布式数据库的基础上获取我们需要的ID，由于分布式数据库的起始自增值一样所以才会有冲突的情况发生，那么我们将分布式系统中数据库的同一个业务表的自增ID设计成不一样的起始值，然后设置固定的步长，步长的值即为分库的数量或分表的数量。</p>
<p><img src="/2022/03/20/interview-SystemDesign/db_id.png"> </p>
<p>这种方式明显的优势就是依赖于数据库自身不需要其他资源，并且ID号单调自增，可以实现一些对ID有特殊要求的业务。<br>但是缺点也很明显，首先它强依赖DB，当DB异常时整个系统不可用。虽然配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。 </p>
</li>
<li><p>Redis </p>
<p>通过提供像 INCR 和 INCRBY 这样的自增原子命令，由于Redis自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的。<br>但是单机存在性能瓶颈，无法满足高并发的业务需求，所以可以采用集群的方式来实现。集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。 </p>
</li>
<li><p>雪花算法 </p>
<p>  <img src="/2022/03/20/interview-SystemDesign/snowflow.png"></p>
<p>雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的，而且可以根据自身业务特性分配bit位，非常灵活。但是雪花算法强依赖机器时钟。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>System Design</tag>
      </tags>
  </entry>
  <entry>
    <title>interview-database</title>
    <url>/2022/03/19/interview-database/</url>
    <content><![CDATA[<h1 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h1><h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系型数据库和非关系型数据库的区别？"><a href="#关系型数据库和非关系型数据库的区别？" class="headerlink" title="关系型数据库和非关系型数据库的区别？"></a>关系型数据库和非关系型数据库的区别？</h3><ul>
<li>关系型数据库<br>是指采用了关系模型来组织数据的数据库，简单来说，关系模式就是二维表格模型。关系型数据库的最大优点就是事务的一致性，这个特性，使得关系型数据库中可以适用于一切要求一致性比较高的系统中。 </li>
<li>非关系型数据库<br>指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统</li>
</ul>
<h3 id="函数依赖和三范式"><a href="#函数依赖和三范式" class="headerlink" title="函数依赖和三范式"></a>函数依赖和三范式</h3><ul>
<li><p>函数依赖</p>
<ul>
<li>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。 </li>
<li>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。 </li>
<li>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖</li>
</ul>
</li>
<li><p>三范式</p>
<ul>
<li>第一范式<br>  每个属性（表的一列）都不可再分，比如某个字段是json数据，就不符合第一范式。 </li>
<li>第二范式<br>  在1NF的基础上，非主属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）举例如下：虽然成绩完全依赖于学号和课程号，但是姓名部分函数依赖于（学号+课程号），即只需要学号即可确定姓名。</li>
</ul>
<p>  <img src="/2022/03/19/interview-database/2NF.png"></p>
<ul>
<li>第三范式<br>  在2NF基础上消除传递依赖。比如，课程号-&gt;授课老师-&gt;教师姓名，所以教师姓名传递依赖课程号。</li>
</ul>
<p>  <img src="/2022/03/19/interview-database/3NF.png"></p>
</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务的ACID特性"><a href="#什么是事务的ACID特性" class="headerlink" title="什么是事务的ACID特性"></a>什么是事务的ACID特性</h3><p>略</p>
<h2 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h2><ul>
<li><p>丢失修改 </p>
</li>
<li><p>脏读 </p>
</li>
<li><p>不可重复读 </p>
</li>
<li><p>幻读 </p>
<ul>
<li><p>概念 </p>
<p>是指在同一个事务中，前后两次查询相同范围时，得到的结果不一致，后一次查询到新插入的行。</p>
<p><img src="/2022/03/19/interview-database/Phantom_read.png"> </p>
<p>对于 <code>select * from t where d=5 for update;</code> 来说，锁住d&#x3D;5对应的行或者锁住扫描过程中所有的行都是没有用的, 因为插入并不影响之前行的操作，所以 InnoDB 为了解决幻读，引入了新的锁 - 间隙锁。 </p>
<p>当再执行select * from t where d&#x3D;5 for update;时，不但会将全表的数据行锁住，还会将间隙锁住。由于间隙锁解决的是幻读插入的问题，所以间隙锁仅仅对插入操作本身互斥，不同事务之间的间隙锁并不互斥。 </p>
</li>
<li><p>缺点</p>
<p>间隙锁的引入导致同样的语句锁住更大的范围，降低了并发度。</p>
</li>
</ul>
</li>
</ul>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="数据库锁的类型有哪些？"><a href="#数据库锁的类型有哪些？" class="headerlink" title="数据库锁的类型有哪些？"></a>数据库锁的类型有哪些？</h3><ul>
<li>共享锁：允许事务对一条行数据进行读取，其他事务只能加读锁，即并行读。 </li>
<li>排他锁：允许事务对一条行数据进行删除或更新，其他事务不能加任何锁，即无法读和写.</li>
</ul>
<p>  共享锁之间是兼容的，而互斥锁与其他任意锁都不兼容，因为可以并行读，但是只能串行写。 </p>
<p>  <img src="/2022/03/19/interview-database/lock.png"></p>
<h3 id="乐观锁和悲观锁的区别，以及各自的使用场景"><a href="#乐观锁和悲观锁的区别，以及各自的使用场景" class="headerlink" title="乐观锁和悲观锁的区别，以及各自的使用场景"></a>乐观锁和悲观锁的区别，以及各自的使用场景</h3><ul>
<li><p>悲观锁 </p>
<p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。 </p>
<p>多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。 </p>
</li>
<li><p>乐观锁 </p>
<ul>
<li><p>理解 </p>
<p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。 </p>
</li>
<li><p>场景 </p>
<p>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。 </p>
</li>
<li><p>乐观锁常见的两种实现方式： </p>
<ul>
<li><p>版本号机制 </p>
<p>   一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</p>
<p>   假设数据库中账户信息表中有一个 version 字段，当前值为 1 ；而当前账户余额字段（ balance ）为 $100 。 </p>
<ol>
<li>操作员 A 此时将其读出（ version&#x3D;1 ），并从其账户余额中扣除 $50（ $100-$50 ）。 </li>
<li>在操作员 A 操作的过程中，操作员B 也读入此用户信息（ version&#x3D;1 ），并从其账户余额中扣除 $20 （ $100-$20 ）。 </li>
<li>操作员 A 完成了修改工作，将数据版本号加一（ version&#x3D;2 ），连同帐户扣除后余额（ balance&#x3D;$50 ），提交至数据库更新，此时由于提交数据版本大于数据库记录当前版本，数据被更新，数据库记录 version 更新为 2 。 </li>
<li>操作员 B 完成了操作，也将版本号加一（ version&#x3D;2 ）试图向数据库提交数据（ balance&#x3D;$80 ），但此时比对数据库记录版本时发现，操作员 B 提交的数据版本号为 2 ，数据库记录当前版本也为 2 ，不满足 “ 提交版本必须大于记录当前版本才能执行更新 “ 的乐观锁策略，因此，操作员 B 的提交被驳回。<br>   这样，就避免了操作员 B 用基于 version&#x3D;1 的旧数据修改的结果覆盖操作员A 的操作结果的可能。</li>
</ol>
</li>
<li><p>CAS </p>
<p>compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数 </p>
<ul>
<li>需要读写的内存值 V </li>
<li>进行比较的值 A </li>
<li>拟写入的新值 B</li>
</ul>
<p>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</p>
</li>
</ul>
</li>
<li><p>乐观锁的缺点： </p>
<ul>
<li><p>ABA问题 </p>
<p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的  ABA 问题。 </p>
</li>
<li><p>循环时间大 </p>
<p>自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 </p>
</li>
<li><p>只能保证一个共享变量的原子操作 </p>
<p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><ul>
<li><p>行锁：例如，共享锁和排他锁 </p>
</li>
<li><p>表锁：例如，意向锁 </p>
<p>意向锁分为两种： </p>
<ul>
<li>意向共享锁：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁； </li>
<li>意向互斥锁：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁；</li>
</ul>
<p>为什么需要意向锁？ </p>
<p>如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。 </p>
<p><img src="/2022/03/19/interview-database/ILock.png"></p>
</li>
</ul>
<h3 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h3><ul>
<li><p>Record Lock </p>
<p>例如：<code>SELECT * FROM users WHERE id = 1</code> 时，如果id为主键，则会锁住对应的记录，否则全变扫描时会锁住整个表。 </p>
</li>
<li><p>Gap Lock </p>
<p>间隙锁是对索引记录中的一段连续区域的锁。当使用类似 <code>SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE;</code> 的 SQL 语句时，就会阻止其他事务向表中插入 id &#x3D; 15 的记录，因为整个范围都被间隙锁锁定了。 </p>
</li>
<li><p>Next-Key Lock </p>
<p>Next-Key 锁相比前两者就稍微有一些复杂，它是记录锁和记录前的间隙锁的结合。</p>
<p><img src="/2022/03/19/interview-database/next_lock.png"> </p>
<p>当我们更新一条记录，比如 <code>SELECT * FROM users WHERE age = 30 FOR UPDATE;</code>，InnoDB 不仅会在范围 (21, 30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30, 40] 加间隙锁，所以插入 (21, 40] 范围内的记录都会被锁定。</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>  InnoDB 中实现的锁是悲观的，那么不同事务之间就可能会互相等待对方释放锁造成死锁，最终导致事务发生错误；<br>  <img src="/2022/03/19/interview-database/dead_lock.png"></p>
<h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><p>  运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放 </p>
<ul>
<li><p>三级封锁协议</p>
<ul>
<li><p>一级封锁协议 </p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。 </p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。它不能保证可重复读和不读“脏”数据。 </p>
</li>
<li><p>二级封锁协议 </p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。还可以进一步防止读“脏”数据 </p>
</li>
<li><p>三级封锁协议 </p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。可以解决不可重复读的问题</p>
</li>
</ul>
</li>
<li><p>两段锁协议</p>
<p>所有的事务必须分两个阶段对数据项加锁和解锁。</p>
<p>可以证明：若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。 </p>
<p>可串行化：多个事务的并发执行是正确的，当且仅当其结果与某一次序串行地执行它们时的结果相同，称这种调度策略是可串行化调度。 </p>
<p>两阶段锁的使用却引入了另一个严重的问题，死锁；不同的事务等待对方已经锁定的资源就会造成死锁</p>
</li>
</ul>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><h3 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h3><ul>
<li><p>未提交读 </p>
<p>  事务中的修改，即使没有提交，对其它事务也是可见的。 </p>
</li>
<li><p>提交读 </p>
<p>  一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 </p>
</li>
<li><p>可重复读 </p>
<p>  保证在同一个事务中多次读取同样数据的结果是一样的。 </p>
</li>
<li><p>可串行化 </p>
<p>  强制事务串行执行。</p>
</li>
</ul>
<h3 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h3><p>常见的三种并发控制机制：分别是悲观并发控制、乐观并发控制和多版本并发控制，其中悲观并发控制其实是最常见的并发控制机制，也就是锁；而乐观并发控制其实也有另一个名字：乐观锁，乐观锁其实并不是一种真实存在的锁。 </p>
<p>MVCC是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<p>同一行数据平时发生读写请求时，会上锁阻塞住。但mvcc用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。</p>
<p>当前读是指读取的是最新的数据，需要加锁。 </p>
<p>快照读是指使用 MVCC 读取历史快照中的数据，不需要加锁，提升性能。</p>
<p>具体原理： </p>
<ul>
<li><p>事务版本号：每次事务开启前都会从数据库获得一个自增长的事务ID </p>
</li>
<li><p>数据库记录隐藏的列： </p>
<p>  <code>DB_TRX_ID</code>: 记录操作该数据事务的事务ID；</p>
<p>  <code>DB_ROLL_PTR</code>：指向上一个版本数据在undo log 里的位置指针； </p>
</li>
<li><p>undo log：当事务进行回滚需要用到 </p>
<p>  <img src="/2022/03/19/interview-database/undo_log.png"></p>
</li>
<li><p>ReadView </p>
<p>  <code>trx_ids</code>: 当前系统活跃(未提交)事务版本号集合。</p>
<p>  <code>low_limit_id</code>: 创建当前read view 时“当前系统最大事务版本号+1”。 </p>
<p>  <code>up_limit_id</code>: 创建当前read view 时“系统正处于活跃事务最小版本号” </p>
<p>  <code>creator_trx_id</code>: 创建当前read view的事务版本号；</p>
</li>
</ul>
<p>是否从undo log版本链中读数据，依据下面的算法： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Check whether the changes by id are visible.</span><br><span class="line">@param[in]   id    transaction id to check against the view</span><br><span class="line">@param[in]  name   able name</span><br><span class="line">@return     whether the view sees the modifications of id. */</span><br><span class="line"></span><br><span class="line">bool changes_visible(</span><br><span class="line">    trx_id_t                id,</span><br><span class="line">    const table_name_t&amp;    name) const</span><br><span class="line">    MY_ATTRIBUTE((warn_unused_result))</span><br><span class="line">&#123;</span><br><span class="line">    ut_ad(id&gt;0);</span><br><span class="line">    if (id &lt; m_up_limit_id || id==m_creator_trx_id)&#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line">    check_trx_id_sanity(id, name);</span><br><span class="line">    if(id&gt;=m_low_limit_id)&#123;</span><br><span class="line">        return(false); </span><br><span class="line">    &#125; else if(m_ids.empty())&#123;</span><br><span class="line">        return(true);</span><br><span class="line">    &#125;</span><br><span class="line">    const ids_t::value_type* p=m_ids.data();</span><br><span class="line">    return(!std::binary_search(p, P + m_ids.size(), id));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个例子： </p>
<p><img src="/2022/03/19/interview-database/mvcc_example.png"></p>
<p>RC(read commit) 级别下同一个事务里面的每一次查询都会获得一个新的read view副本。这样就可能造成同一个事务里前后读取数据可能不一致的问题（重复读）<br><img src="/2022/03/19/interview-database/mvcc_rc.png"></p>
<p>RR(重复读)级别下的一个事务里只会获取一次read view副本，从而保证每次查询的数据都是一样的。<br><img src="/2022/03/19/interview-database/mvcc_rr.png"></p>
<h1 id="Sql"><a href="#Sql" class="headerlink" title="Sql"></a>Sql</h1><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="union和union-all的区别"><a href="#union和union-all的区别" class="headerlink" title="union和union all的区别"></a>union和union all的区别</h3><p>  首先，union和union all关键字都是将两个结果集合并为一个显示出来。但是它们的区别是：union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 </p>
<p>  union 在运行时先取出两个表的结果，再用排序空间进行排序删除重复的记录，最后返回结果集，如果表数据量大的话可能会导致用磁盘进行排序。</p>
<p>  从效率上说，UNION ALL 要比UNION快很多，所以，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用UNION ALL </p>
<h3 id="MySQL-中-join-与-left-join-的区别是什么？"><a href="#MySQL-中-join-与-left-join-的区别是什么？" class="headerlink" title="MySQL 中 join 与 left join 的区别是什么？"></a>MySQL 中 join 与 left join 的区别是什么？</h3><p>  “内连接”join，其实就是“inner join”，为了简写才写成join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来。 </p>
<p>  <img src="/2022/03/19/interview-database/join.png"></p>
<h3 id="SQL优化的方案有哪些，如何定位问题并解决问题？？"><a href="#SQL优化的方案有哪些，如何定位问题并解决问题？？" class="headerlink" title="SQL优化的方案有哪些，如何定位问题并解决问题？？"></a>SQL优化的方案有哪些，如何定位问题并解决问题？？</h3><ul>
<li>定位问题：使用explain </li>
<li>优化思路 <ul>
<li><p>尽量用union all代替union </p>
<p>union的排序去重操作，增加大量的CPU运算，加大资源消耗及延迟。使用union all的前提是两个结果集没有重复数据。 </p>
</li>
<li><p>SELECT语句务必指明字段名称 </p>
<p>SELECT* 增加很多不必要的消耗（cpu、io、内存、网络带宽）；增加了使用覆盖索引的可能性； </p>
</li>
<li><p>避免在where子句中对字段进行表达式操作 </p>
<p>会导致索引失效 </p>
</li>
<li><p>对于联合索引来说，要遵守最左前缀法则 </p>
<p>查询从索引的最左列开始，并且不跳过索引中的列。也就是说查询的条件当中要包含索引最左侧的列，并且不能跳过索引当中的列。 </p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index idx_seller_name_sta_addr on tb_seller(name, status, address);</span><br><span class="line">// 测试1</span><br><span class="line">explain select * from tb_seller where status = &#x27;1&#x27; and address = &#x27;北京市&#x27; //这样走索引吗？不走，因为没从索引最左边的列开始</span><br><span class="line">// 测试2</span><br><span class="line">explain select * from tb_seller where status = &#x27;1&#x27; and address = &#x27;北京市&#x27; //这样走索引吗？不走，因为没从索引最左边的列开始</span><br><span class="line">// 测试3</span><br><span class="line">explain select * from tb_seller where status = &#x27;1&#x27; and address = &#x27;北京市&#x27; and name = &#x27;小米科技&#x27; //走索引，顺序并不影响，只看查询条件有没有包含最左列</span><br><span class="line">// 测试4</span><br><span class="line">explain select * from tb_seller where name = &#x27;小米科技&#x27; and address = &#x27;北京市&#x27; //走索引，只用到了name字段的索引，没用到address字段的索引</span><br></pre></td></tr></table></figure></li>
<li><p>注意范围查询语句 </p>
<p>对于联合索引来说，如果存在范围查询，比如 between,&gt;,&lt;等条件时，会造成后面的索引字段失效。 </p>
</li>
<li><p>关于JOIN优化 </p>
<p>join的实现是采用Nested Loop Join算法，就是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果有多个join，则将前面的结果集作为循环数据，再一次作为循环条件到后一个表中查询数据。 </p>
<ul>
<li>用小结果集驱动大结果集，将筛选结果小的表首先连接，再去连接结果集比较大的表，尽量减少join语句中的Nested Loop的循环总次数；举例：假设A表10000行，B表100行；也就是说如果用A表做驱动表会伴随着10000次随机读，而如果是B表作为驱动表，会伴随着100次随机读。 </li>
<li>对被驱动表的join字段上建立索引；使得对内表的查询走索引提高效率。这种做法最高效的就是外表是一张小表，而内表的连接谓词刚好是内表的主键。</li>
</ul>
</li>
<li><p>不建议使用%前缀模糊查询 </p>
<p>可以建立全文索引 </p>
</li>
<li><p>避免在 where 子句中对字段进行 null 值判断</p>
<p>对于 null的判断会导致引擎放弃使用索引而进行全表扫描</p>
</li>
</ul>
</li>
</ul>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="主键索引和辅助索引的区别？"><a href="#主键索引和辅助索引的区别？" class="headerlink" title="主键索引和辅助索引的区别？"></a>主键索引和辅助索引的区别？</h3><p>主键索引中存放着一条行记录的全部信息，而辅助索引中只包含索引列和一个用于查找对应行记录的『书签』，一般是主键。<br><img src="/2022/03/19/interview-database/mysql_index.png"></p>
<h3 id="聚簇索引和非聚簇索引的区别？"><a href="#聚簇索引和非聚簇索引的区别？" class="headerlink" title="聚簇索引和非聚簇索引的区别？"></a>聚簇索引和非聚簇索引的区别？</h3><p>  聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据，一个表只有一个聚簇索引。</p>
<p>  非聚簇索引：将数据存储与索引分开，索引结构的叶子节点指向了数据的对应行 </p>
<p>  innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值。 </p>
<h3 id="利用索引如何进行优化？"><a href="#利用索引如何进行优化？" class="headerlink" title="利用索引如何进行优化？"></a>利用索引如何进行优化？</h3><ul>
<li><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引<br>  例如，SELECT actor_id FROM actor WHERE actor_id + 1 &#x3D; 5; </p>
</li>
<li><p>多列索引 </p>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。</p>
</li>
</ul>
<p>  例如：SELECT film_id, actor_ id FROM film_actor WHERE actor_id &#x3D; 1 AND film_id &#x3D; 1; </p>
<ul>
<li><p>索引列的顺序 </p>
<p>让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。</p>
</li>
<li><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 </p>
<p>对于前缀长度的选取需要根据索引选择性来确定。例如下面的表，使用前1-5位字符做前缀索引就会出现大量索引值重复的情况，导致查询效率低。<br><img src="/2022/03/19/interview-database/prefix_index.png"></p>
</li>
<li><p>覆盖索引 </p>
<p>索引包含所有需要查询的字段。即从辅助索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。 </p>
</li>
<li><p>如何优化查询的性能？ </p>
<ul>
<li>使用explain进行分析<br>Explain 用来分析 SELECT 查询语句，结果如下<br><img src="/2022/03/19/interview-database/explain.png"></li>
</ul>
</li>
<li><p>什么是全文索引？ </p>
<p>通过倒排的方式，得到分词到全文的一个映射关系。</p>
</li>
</ul>
<h3 id="MySQL为什么用B-树做索引？"><a href="#MySQL为什么用B-树做索引？" class="headerlink" title="MySQL为什么用B+树做索引？"></a>MySQL为什么用B+树做索引？</h3><p>相比于二叉树、AVL树、红黑树来说，使用B+树有更少的查询次数，树节点出度越多，树高越矮，需要的查询次数越少，磁盘加载的次数也越少。 </p>
<p>相比于B树来说，由于B+树叶节点保存有所有的数据，内节点保存的是索引，使得对于每个数据，查询都比较稳定。此外，B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况。 </p>
<h3 id="MySQL为什么要有最左匹配原则？"><a href="#MySQL为什么要有最左匹配原则？" class="headerlink" title="MySQL为什么要有最左匹配原则？"></a>MySQL为什么要有最左匹配原则？</h3><p>最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被索引用到。</p>
<p>要想理解联合索引的最左匹配原则，先来理解下索引的底层原理。索引的底层是一颗B+树，那么联合索引的底层也就是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p>
<p>举例：创建一个（a,b）的联合索引，那么它的索引树就是下图的样子。</p>
<p><img src="/2022/03/19/interview-database/leftIndex.png"></p>
<p>可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b&#x3D;2这种查询条件没有办法利用索引。</p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="InnoDB和MyISAM的区别"><a href="#InnoDB和MyISAM的区别" class="headerlink" title="InnoDB和MyISAM的区别"></a>InnoDB和MyISAM的区别</h3><ul>
<li><p>事务： </p>
<p>InnoDB是事务型存储引擎，实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ），在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。<br>MyISAM不支持事务。 </p>
</li>
<li><p>并发： </p>
<p>InNoDB支持行级锁和表级锁，MyISAM只支持表级锁。 </p>
</li>
<li><p>索引： </p>
<p>InnoDB的索引是聚簇索引，MyISAM是非聚簇索引。</p>
<p>InnoDB支持不支持全文索引，MyISAM支持。 </p>
</li>
<li><p>场景： </p>
<p>MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</p>
</li>
</ul>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><ul>
<li><p>好处 </p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用； </li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； </li>
<li>增加冗余，提高可用性。</li>
</ul>
</li>
<li><p>原理 </p>
<p>MySQL主从复制涉及到三个线程，一个运行在主节点，其余两个运行在从节点： </p>
<ul>
<li><p>binlog 线程：负责将主服务器上的数据更改写入二进制日志（Binary log）中。 </p>
</li>
<li><p>I&#x2F;O 线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。 </p>
</li>
<li><p>SQL 线程：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中执行。</p>
</li>
</ul>
<p>  <img src="/2022/03/19/interview-database/mysql_syc.png"></p>
</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h3><p>  单库太大：数据库里面的表太多，所在服务器磁盘空间装不下，IO次数多，即IO瓶颈<br>  单表太大：一张表的字段太多，数据太多。查询起来困难，查询时扫描的行太多，SQl效率低，CPU瓶颈 </p>
<h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>  水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈。<br>  <img src="/2022/03/19/interview-database/horizontal_sharding.png"> </p>
<h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>  按照一定业务逻辑进行垂直切，此时不同的数据库应该存放在不同的服务器上，此时磁盘空间、内存、TPS等等都会得到解决。<br>  <img src="/2022/03/19/interview-database/vertical_sharding.png"></p>
<h3 id="分库分表可能带来的问题？"><a href="#分库分表可能带来的问题？" class="headerlink" title="分库分表可能带来的问题？"></a>分库分表可能带来的问题？</h3><ul>
<li><p>事务 </p>
<p>分库分表后，就需要支持分布式事务了。 </p>
</li>
<li><p>联合查询 </p>
<p>两个相关联的表可能会分布在不同的数据库。</p>
</li>
</ul>
<h2 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h2><p><a href="https://zhuanlan.zhihu.com/p/25960208">https://zhuanlan.zhihu.com/p/25960208</a> </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="mysql如何进行故障恢复的？"><a href="#mysql如何进行故障恢复的？" class="headerlink" title="mysql如何进行故障恢复的？"></a>mysql如何进行故障恢复的？</h3><h3 id="简述-undo-log-和-redo-log-的作用"><a href="#简述-undo-log-和-redo-log-的作用" class="headerlink" title="简述 undo log 和 redo log 的作用"></a>简述 undo log 和 redo log 的作用</h3><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>string </p>
</li>
<li><p>list </p>
</li>
<li><p>set<br>set是一个无序的、自动去重的集合数据类型，Set底层用两种数据结构存储，一个是hashtable，一个是inset。 </p>
<p>inset为可以理解为数组，使用inset数据结构需要满足下述两个条件： </p>
<ul>
<li>元素个数不少于默认值512 </li>
<li>元素可以用整型表示</li>
</ul>
<p>查询方式一般采用二分查找法，实际查询复杂度也就在log(n) </p>
</li>
<li><p>hash </p>
</li>
<li><p>zset</p>
</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><img src="/2022/03/19/interview-database/redis_dict.png"></p>
<ul>
<li><p>为什么要进行扩缩容？ </p>
<p>  当哈希表中的元素太多或太少时，会进行扩容或者缩容。扩容是出于哈希表的查找效率考虑，当哈希表中的元素达到一定数量时，表中链的长度会随着哈希表元素的增长而增长，链表越长意味着查询效率也会越慢。缩容是为了节省内存空间，避免数组中太多空元素造成空间浪费。 </p>
</li>
<li><p>Redis如何进行扩缩容？ </p>
<p> Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。 </p>
<p> rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1]上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p>
</li>
</ul>
<h3 id="有序集合zset"><a href="#有序集合zset" class="headerlink" title="有序集合zset"></a>有序集合zset</h3><p>  有序集合的底层实现之一是跳跃表，跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。<br><img src="/2022/03/19/interview-database/skip_list.png"></p>
<p>与红黑树等平衡树相比，跳跃表具有以下优点： </p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； </li>
<li>更容易实现； </li>
<li>支持无锁操作。 </li>
<li>范围查找时比红黑树有优势。 </li>
<li>查找、添加、删除操作都可以在对数期望时间下完成。</li>
</ul>
<h2 id="Redis使用场景"><a href="#Redis使用场景" class="headerlink" title="Redis使用场景"></a>Redis使用场景</h2><ul>
<li>计数器 </li>
<li>缓存 </li>
<li>查找表 </li>
<li>消息队列 </li>
<li>session缓存 </li>
<li>分布式锁实现 </li>
<li>利用Zset实现排行榜</li>
</ul>
<h2 id="Redis和Memcached的区别"><a href="#Redis和Memcached的区别" class="headerlink" title="Redis和Memcached的区别"></a>Redis和Memcached的区别</h2><ul>
<li><p>数据类型 </p>
<p>Memcached只支持字符串类型，Redis支持五种数据类型 </p>
</li>
<li><p>数据持久化 </p>
<p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 </p>
</li>
<li><p>分布式 </p>
<p>Memcached 不支持分布式；Redis Cluster 实现了分布式的支持。 </p>
</li>
<li><p>内存管理机制 </p>
<p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而Memcached 的数据则会一直在内存中。Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。</p>
</li>
</ul>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p><img src="/2022/03/19/interview-database/redis_eliminating.png"></p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 </p>
<ul>
<li>RDB持久化 <ul>
<li><p>触发机制： </p>
<ul>
<li><p>save命令：客户端向Redis发送save命令来创建一个快照文件。 </p>
<p>  <img src="/2022/03/19/interview-database/save.png"></p>
</li>
<li><p>bgsave命令：客户端向Redis发送bgsave命令，Redis调用fork创建一个子进程， 然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求。 </p>
<p>  <img src="/2022/03/19/interview-database/bgsave.png"></p>
</li>
<li><p>自动生成：通过配置，满足任何一个条件就会创建快照文件。 </p>
<p>  <img src="/2022/03/19/interview-database/auto.png"></p>
</li>
</ul>
</li>
<li><p>具体执行： </p>
<ol>
<li>redis调用系统的fork()函数创建一个子进程 </li>
<li>子进程将数据集写入一个临时的RDB文件 </li>
<li>当子进程完成对临时的RDB文件的写入时，redis用新的RDB文件来替换原来旧的RDB文件，并将旧的RDB文件删除</li>
</ol>
</li>
<li><p>优点： </p>
<ul>
<li>RDB 非常适用于灾难恢复 </li>
<li>RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 </li>
<li>RDB对redis对外提供读写服务的时候，影响非常小，因为redis 主进程只需要fork一个子进程出来，让子进程对磁盘io来进行rdb持久化。</li>
</ul>
</li>
<li><p>缺点： </p>
<ul>
<li>如果redis要故障时要尽可能少的丢失数据，RDB没有AOF好，</li>
</ul>
</li>
</ul>
</li>
<li>AOF持久化 <ul>
<li>实现： <ul>
<li><p>将写命令添加到 AOF 文件（Append Only File）的末尾。 </p>
</li>
<li><p>使用 AOF 持久化需要设置同步选项，从而确保写命令什么时候会同步到磁盘文件上。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项： </p>
<p>  <img src="/2022/03/19/interview-database/redis_sync.png"></p>
</li>
<li><p>always 选项会严重降低服务器的性能； </p>
</li>
<li><p>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响； </p>
</li>
<li><p>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</p>
</li>
</ul>
</li>
<li>优点： <ul>
<li>AOF可以更好的保护数据不丢失，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。</li>
</ul>
</li>
<li>缺点： <ul>
<li>AOF 文件比 RDB 文件大，且恢复速度慢。 </li>
<li>数据集大的时候，比 rdb 启动效率低。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><ul>
<li><p>MULTI 命令用于开启一个事务，它总是返回 OK 。 </p>
</li>
<li><p>MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。</p>
<p>  <img src="/2022/03/19/interview-database/multi1.png"></p>
</li>
<li><p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。 </p>
<p>  <img src="/2022/03/19/interview-database/multi2.png"></p>
</li>
<li><p>事务中的错误 </p>
<ul>
<li><p>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误。对于这种情况，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。 </p>
<p><img src="/2022/03/19/interview-database/multi3.png"></p>
</li>
<li><p>命令可能在 EXEC 调用之后失败。比如，事务中的命令可能处理了错误类型的键。对于这种情况，即使事务中有某个&#x2F;某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。 </p>
<p><img src="/2022/03/19/interview-database/multi4.png"></p>
</li>
</ul>
</li>
<li><p>带watch的事务<br>WATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务将被打断，不再执行， 直接返回失败。 </p>
<p><img src="/2022/03/19/interview-database/multi5.png"></p>
</li>
<li><p>三个特性 </p>
<ul>
<li>单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </li>
<li>没有隔离级别的概念：队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题 </li>
<li>不保证原子性：Redis 同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li>
</ul>
</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>Redis服务器是事件驱动程序 </p>
<h3 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h3><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I&#x2F;O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。 </p>
<p><img src="/2022/03/19/interview-database/file_event.png"></p>
<h3 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h3><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器 </p>
<p><img src="/2022/03/19/interview-database/time_event.png"></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>为了增加系统可靠性和读写性能，可以建立Redis主从集群。Redis Replication是一种简单、易用的主从模式（master-slave）的复制机制，它能够使得slave节点成为与master节点完全相同的副本。 </p>
<h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ol>
<li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令； </li>
<li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令； </li>
<li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li>
</ol>
<h2 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h2><p><a href="https://segmentfault.com/a/1190000022808576">https://segmentfault.com/a/1190000022808576</a> </p>
<h3 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h3><ul>
<li><p>介绍 </p>
<ul>
<li>主从模式里使用一个redis实例作为主机(master)，其余多个实例作为备份机(slave)； </li>
<li>master用来支持数据的写入和读取操作，而slave支持读取及master的数据同步； </li>
<li>在整个架构里，master和slave实例里的数据完全一致；</li>
</ul>
<p>  <img src="/2022/03/19/interview-database/master_slave.png"></p>
</li>
<li><p>原理 </p>
<ul>
<li><p>全量同步 </p>
<ul>
<li>当从节点启动时，会向主节点发送SYNC命令； </li>
<li>主节点接收到SYNC命令后，开始在后台执行保存快照的命令生成RDB文件，并使用缓冲区记录此后执行的所有写命令； </li>
<li>主节点快照完成后，将快照文件和所有缓存命令发送给集群内的从节点，并在发送期间继续记录被执行的写命令； </li>
<li>主节点快照发送完毕后开始向从节点发送缓冲区中的写命令； </li>
<li>从节点载入快照文件后，开始接收命令请求，执行接收到的主节点缓冲区的写命令。</li>
</ul>
</li>
<li><p>增量同步 </p>
<p>  主从复制中因网络等原因造成数据丢失场景，当从节点再次连上主节点。如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。</p>
</li>
</ul>
</li>
<li><p>主节点故障处理方式 </p>
<p>  主从模式中，每个客户端连接redis实例时都指定了ip和端口号。如果所连接的redis实例因为故障下线了，则无法通知客户端连接其他客户端地址，因此只能进行手动操作。主从模式很好地解决了数据备份的问题，但是主节点因为故障下线后，需要手动更改客户端配置重新连接，这种模式并不能保证服务的高可用。</p>
</li>
</ul>
<h3 id="Sentinel（哨兵）模式"><a href="#Sentinel（哨兵）模式" class="headerlink" title="Sentinel（哨兵）模式"></a>Sentinel（哨兵）模式</h3><ul>
<li><p>参考 </p>
<p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html">https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html</a> </p>
</li>
<li><p>介绍 </p>
<p>和主从模式不一样的是，哨兵模式中增加了独立进程（即哨兵）来监控集群中的一举一动。客户端在连接集群时，首先连接哨兵，通过哨兵查询主节点的地址，然后再去连接主节点进行数据交互。哨兵的核心功能是主节点的自动故障转移。 </p>
<p>如下图所示，如果master异常，则会进行master-slave切换，将最优的一个slave切换为主节点。 </p>
<p><img src="/2022/03/19/interview-database/sentinel.png"></p>
</li>
<li><p>原理 </p>
<ul>
<li>每个哨兵每秒向集群中的master、slave以及其他哨兵发送一个PING命令； </li>
<li>如果某个实例距离最后一次有效回复ping命令的时间超过一定值，则会被标记为主观下线； </li>
<li>如果master被标记为主观下线，那么其他正在监视master的哨兵以每秒的频率确认其确实进入主观下线状态，且数量达到一定值时，master会被标记为下线，然后通知其他的从服务器，修改配置文件，让它们切换主机； </li>
<li>客户端在master节点发生故障时会重向哨兵要地址，此时会获得最新的master节点地址。</li>
</ul>
<p>补充： </p>
<ul>
<li>主观下线：任何一个哨兵都是可以监控探测，并作出Redis节点下线的判断； </li>
<li>客观下线：由哨兵集群共同决定Redis节点是否下线；</li>
</ul>
<p><img src="/2022/03/19/interview-database/level.png"></p>
</li>
<li><p>选举&#x2F;共识机制 </p>
<p>判断完主库下线后，由哪个哨兵节点来执行主从切换呢？这里就需要哨兵集群的选举机制了。</p>
<ul>
<li><p>为什么必然会出现选举&#x2F;共识机制？ </p>
<p>为了避免哨兵的单点情况发生，所以需要一个哨兵的分布式集群。作为分布式集群，必然涉及共识问题（即选举问题）；同时故障的转移和通知都只需要一个主的哨兵节点就可以了。 </p>
</li>
<li><p>哨兵的选举机制是什么样的？ </p>
<p>哨兵的选举机制其实很简单，就是一个Raft选举算法： 选举的票数大于<code>num(sentinels)/2+1</code>时，将成为领导者，如果没有超过，继续选举</p>
</li>
</ul>
</li>
<li><p>缺点 </p>
<p>哨兵模式的出现虽然解决了主从模式中master节点宕机不能自主切换（即高可用）的问题。但是，随着业务的逐渐增长，不可避免需要对当前业务进行扩容，无法可扩展。<br>常见的扩容方式有垂直和水平扩容两种方式： </p>
<ul>
<li>垂直扩容：通过增加master内存来增加容量； </li>
<li>水平扩容：通过增加节点来进行扩容，即在当前基础上再增加一个master节点。</li>
</ul>
<p>水平扩容涉及到数据的迁移，且迁移过程中又要保证服务的可用性，哨兵模式无法满足这种情形。因此，redis cluster应运而生。</p>
</li>
</ul>
<h3 id="Cluster-模式"><a href="#Cluster-模式" class="headerlink" title="Cluster 模式"></a>Cluster 模式</h3><ul>
<li><p>介绍 </p>
<ul>
<li>redis cluster模式采用了无中心节点的方式来实现，每个主节点都会与其它主节点保持连接。节点间通过gossip协议交换彼此的信息，同时每个主节点又有一个或多个从节点； </li>
<li>客户端连接集群时，直接与redis集群的每个主节点连接，根据hash算法取模将key存储在不同的哈希槽上； </li>
<li>在集群中采用数据分片的方式，将redis集群分为16384个哈希槽。举个例子，比如当前集群有3个节点，那么这些哈希槽分别存储于三个主节点中： <ul>
<li>Master1负责0~5460号哈希槽 </li>
<li>Master2负责5461~10922号哈希槽 </li>
<li>Master3负责10922~16383号哈希槽</li>
</ul>
</li>
</ul>
<p>每个节点会保存一份数据分布表，节点会将自己的slot信息发送给其他节点，节点间不停的传递数据分布表； </p>
<p>客户端连接集群时，通过集群中某个节点地址进行连接。客户端尝试向这个节点执行命令时，比如获取某个key值，如果key所在的slot刚好在该节点上，则能够直接执行成功。如果slot不在该节点，则节点会返回MOVED错误，同时把该slot对应的节点告诉客户端，客户端可以去该节点执行命令。<br><img src="/2022/03/19/interview-database/cluster.png"></p>
</li>
<li><p>原理 </p>
<p>redis cluster中主节点故障处理方式与哨兵模式较为相像，当约定时间内某节点无法与集群中的另一个节点顺利完成ping消息通信时，则将该节点标记为主观下线状态，同时将这个信息向整个集群广播。 </p>
<p>如果一个节点收到某个节点失联的数量达到了集群的大多数时，那么将该节点标记为客观下线状态，并向集群广播下线节点的fail消息。然后立即对该故障节点进行主从切换。等到原来的主节点恢复后，会自动成为新主节点的从节点。如果主节点没有从节点，那么当它发生故障时，集群就将处于不可用状态。 </p>
</li>
<li><p>扩容问题 </p>
<p>在哨兵模式中我们在扩容的时候遇到了问题，那么cluster中我们如何动态上线某个节点呢。当集群中加入某个节点时，哈希槽又是如何来进行分配的？当集群中加入新节点时，会与集群中的某个节点进行握手，该节点会把集群内的其它节点信息通过gossip协议发送给新节点，新节点与这些节点完成握手后加入到集群中。 </p>
<p>然后集群中的节点会各取一部分哈希槽分配给新节点，如下图： </p>
<ul>
<li>Master1负责1365-5460 </li>
<li>Master2负责6827-10922 </li>
<li>Master3负责12288-16383 </li>
<li>Master4负责0-1364,5461-6826,10923-12287</li>
</ul>
<p><img src="/2022/03/19/interview-database/cluster_add.png"></p>
<p>当集群中要删除节点时，只需要将节点中的所有哈希槽移动到其它节点，然后再移除空白（不包含任何哈希槽）的节点就可以了。</p>
</li>
</ul>
<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2><h3 id="为什么-Redis-在单线程下能如此快？"><a href="#为什么-Redis-在单线程下能如此快？" class="headerlink" title="为什么 Redis 在单线程下能如此快？"></a>为什么 Redis 在单线程下能如此快？</h3><ul>
<li><p>纯内存操作 </p>
<p>Redis提供了丰富的数据类型，并使用高效的操作方式进行操作，这些操作都在内存中进行，并不会大量消耗CPU资源，所以速度极快。 </p>
</li>
<li><p>使用IO多路复用技术 </p>
<p>Redis可以在单线程中监听多个Socket的请求，在任意一个Socket可读&#x2F;可写时，Redis去读取客户端请求，在内存中操作对应的数据，然后再写回到Socket中。 </p>
</li>
<li><p>非CPU密集型任务 </p>
<p>采用单线程的缺点很明显，无法使用多核CPU，由于Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽。 </p>
</li>
<li><p>单线程的优势 </p>
<ul>
<li>没有了多线程上下文切换的性能损耗 </li>
<li>没有了访问共享资源加锁的性能损耗 </li>
<li>开发和调试非常友好，可维护性高</li>
</ul>
</li>
</ul>
<h3 id="Redis-如何处理热点-key-访问"><a href="#Redis-如何处理热点-key-访问" class="headerlink" title="Redis 如何处理热点 key 访问"></a>Redis 如何处理热点 key 访问</h3><ul>
<li><p>问题 </p>
<p>所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。 </p>
</li>
<li><p>发现 </p>
<ul>
<li>借业务经验，进行预估哪些是热key </li>
<li>在Proxy层做收集 </li>
<li>客户端进行统计</li>
</ul>
</li>
<li><p>如何解决 </p>
<ul>
<li>利用二级缓存<br>发现热key以后，把热key加载到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。 </li>
<li>对热key进行备份<br>不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。</li>
</ul>
</li>
</ul>
<h3 id="简述-Redis-哨兵的选举过程"><a href="#简述-Redis-哨兵的选举过程" class="headerlink" title="简述 Redis 哨兵的选举过程"></a>简述 Redis 哨兵的选举过程</h3><p>略  </p>
<h1 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h1><h2 id="什么是MongoDB？"><a href="#什么是MongoDB？" class="headerlink" title="什么是MongoDB？"></a>什么是MongoDB？</h2><p>  MongoDB是一个分布式文件存储的数据库，提供高性能，高可用性和易扩展性。 </p>
<p>  MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。 MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 </p>
<p><img src="/2022/03/19/interview-database/mongodb.png"></p>
<p><img src="/2022/03/19/interview-database/mongodb_example.png"></p>
<h2 id="MongoDB有什么特点？"><a href="#MongoDB有什么特点？" class="headerlink" title="MongoDB有什么特点？"></a>MongoDB有什么特点？</h2><ul>
<li>MongoDB目前只支持单文档事务，MongoDB暂时不适合需要复杂事务的场景。 </li>
<li>高性能、高可用、可扩展 </li>
<li>丰富的查询支持<br>支持读写（CRUD）操作、比如数据聚合、文本搜索、地理空间查询等 </li>
<li>支持动态Schemas。（动态Schema意味着单个集合中的文档可以包含不同类型的结构或形状。例如，以下两个文档都可以存储在一个集合中） <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; message  :  Hello World &#125;</span><br><span class="line">&#123; id  : 10,  description  :  India &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="MongoDB支持哪些数据类型？"><a href="#MongoDB支持哪些数据类型？" class="headerlink" title="MongoDB支持哪些数据类型？"></a>MongoDB支持哪些数据类型？</h2><p><img src="/2022/03/19/interview-database/mongodb_type.png"></p>
<h2 id="解释一下NoSql，它与RDBMS的区别？"><a href="#解释一下NoSql，它与RDBMS的区别？" class="headerlink" title="解释一下NoSql，它与RDBMS的区别？"></a>解释一下NoSql，它与RDBMS的区别？</h2><ul>
<li><p>NoSQL是非关系型数据库，NoSQL &#x3D; Not Only SQL。 </p>
</li>
<li><p>关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。 </p>
</li>
<li><p>在处理非结构化&#x2F;半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。再考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。 </p>
<h2 id="NoSQL有哪些类型？"><a href="#NoSQL有哪些类型？" class="headerlink" title="NoSQL有哪些类型？"></a>NoSQL有哪些类型？</h2></li>
<li><p>文档数据库 </p>
<p>这种类型的NoSQL数据库总是基于面向文档的方法来存储数据。文档数据库的主要目标是将单个实体的所有数据存储为一个文档，并且所有文档可以存储为一个集合。一些文档数据库的例子：MongoDB。</p>
</li>
<li><p>键值数据库 </p>
<p>这种类型的数据库以无模式的方式存储数据，因为键值存储是存储数据的最简单的方式。键可以是指向任何类型数据的点，比如对象、字符串或任何其他类型的数据。这些数据库的主要优点是易于实现和添加数据。例如:Redis, </p>
</li>
<li><p>列式数据库 </p>
<p> 这些类型的数据库将数据存储在键空间中的列中。键空间总是在唯一的名称、值和时间戳上定义。如clickhouse。 </p>
</li>
<li><p>图数据库 </p>
<p>这些类型的数据库主要是为可以很容易地表示为图形数据的数据而设计的。这意味着，数据之间存在着数量不定的数据关系，如家庭关系和社会关系等。如GraphDB。</p>
</li>
</ul>
<h2 id="Mongodb的object-id如何理解？"><a href="#Mongodb的object-id如何理解？" class="headerlink" title="Mongodb的object_id如何理解？"></a>Mongodb的object_id如何理解？</h2><p>  ObjectId 类似唯一主键，可以很快的去生成和排序，包含 12 bytes，含义如下： </p>
<p><img src="/2022/03/19/interview-database/mongodb_objectID.png"></p>
<p>  MongoDB 中存储的文档必须有一个 _id 键。这个键的值可以是任何类型的，默认是个 ObjectId 对象。</p>
<h2 id="MongoDB如何保证可靠性的？"><a href="#MongoDB如何保证可靠性的？" class="headerlink" title="MongoDB如何保证可靠性的？"></a>MongoDB如何保证可靠性的？</h2><p>  通过复制将数据同步在多个服务器，保证冗余容灾。 </p>
<p>  mongodb的复制至少需要两个节点。其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据。主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。 </p>
<p>  <img src="/2022/03/19/interview-database/mongodb_sync.png"></p>
<h2 id="说说MongoDB的分片？"><a href="#说说MongoDB的分片？" class="headerlink" title="说说MongoDB的分片？"></a>说说MongoDB的分片？</h2><p>  有时，MongoDB中的数据会非常庞大，以至于对如此大的数据集进行查询会导致服务器上大量的CPU被占用。为了解决这种情况，MongoDB提出了分片的概念，基本上是将数据集拆分到多个MongoDB实例中。 </p>
<p>  分片的组成部分包括： </p>
<ul>
<li>分片（Shard）–基本上说，这不过是一个保存数据子集的MongoDB实例。在生产环境中，所有分片都必须是副本集的一部分。 </li>
<li>配置服务器–一个mongodb实例，其中包含有关集群的元数据，基本上是有关将保存分片数据的各种mongodb实例的信息。 </li>
<li>路由器–一个mongodb实例，主要负责将客户端发送的命令重定向到正确的服务器。</li>
</ul>
<p>  <img src="/2022/03/19/interview-database/mongodb_shard.png"></p>
<h1 id="clickhouse"><a href="#clickhouse" class="headerlink" title="clickhouse"></a>clickhouse</h1><h2 id="什么是clickhouse？"><a href="#什么是clickhouse？" class="headerlink" title="什么是clickhouse？"></a>什么是clickhouse？</h2><p>  ClickHouse是一个用于联机分析(OLAP)的列式数据库管理系统(DBMS)。 </p>
<p>  在传统的行式数据库系统中，数据按如下顺序存储，处于同一行中的数据总是被物理的存储在一起。如mysql。<br><img src="/2022/03/19/interview-database/row.png"><br>  在列式数据库系统中，数据按如下的顺序存储：<br><img src="/2022/03/19/interview-database/col.png"></p>
<h2 id="列式存储的好处？"><a href="#列式存储的好处？" class="headerlink" title="列式存储的好处？"></a>列式存储的好处？</h2><ul>
<li>针对分析类查询，通常只需要读取表的一小部分列。在列式数据库中你可以只读取你需要的数据。例如，如果只需要读取100列中的5列，这将帮助你最少减少20倍的I&#x2F;O消耗。 </li>
<li>由于数据总是打包成批量读取的，所以压缩是非常容易的。同时数据按列分别存储这也更容易压缩。这进一步降低了I&#x2F;O的体积。 </li>
<li>由于I&#x2F;O的降低，这将帮助更多的数据被系统缓存。</li>
</ul>
<h2 id="clickhouse的特点"><a href="#clickhouse的特点" class="headerlink" title="clickhouse的特点"></a>clickhouse的特点</h2><ul>
<li>没有完整的事务支持。 </li>
<li>缺少高频率，低延迟的修改或删除已存在数据的能力。仅能用于批量删除或修改数据， </li>
<li>适合在线查询：在没有对数据做任何预处理的情况下以极低的延迟处理查询并将结果加载到用户的页面中。 </li>
<li>真正的列式数据库管理系统 </li>
<li>拥有完善的SQl支持和函数 </li>
<li>支持高可用</li>
</ul>
<h2 id="行式存储和列式存储的区别？"><a href="#行式存储和列式存储的区别？" class="headerlink" title="行式存储和列式存储的区别？"></a>行式存储和列式存储的区别？</h2><ul>
<li>行式存储（Row-based）的适用场景包括： <ul>
<li>适合随机的增删改查操作; </li>
<li>需要在行中选取所有属性的查询操作; </li>
<li>需要频繁插入或更新的操作，其操作与索引和行的大小更为相关。<br>通常行式数据库的给出的优化方案是加“索引”，给表分区等等之类的.</li>
</ul>
</li>
<li>列式存储的适用场景包括： <ul>
<li>大数据量查询 </li>
<li>非事务</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>interview_intelligence</title>
    <url>/2022/03/18/interview-intelligence/</url>
    <content><![CDATA[<h3 id="不均匀的硬币产生等概率"><a href="#不均匀的硬币产生等概率" class="headerlink" title="不均匀的硬币产生等概率"></a>不均匀的硬币产生等概率</h3><p>问题描述：有一枚不均匀的硬币，已知抛出此硬币后，正面向上的概率为 p（0 &lt; p &lt; 1）。请利用这枚硬币产生出概率相等的两个事件。 </p>
<p>扔两次，先p后q为事件1，先q后p为事件2，二者概率相同。其余情况（pp、qq）则废弃。 </p>
<h3 id="64-匹马，8-个赛道，找出前-4-匹马最少需要比几次？"><a href="#64-匹马，8-个赛道，找出前-4-匹马最少需要比几次？" class="headerlink" title="64 匹马，8 个赛道，找出前 4 匹马最少需要比几次？"></a>64 匹马，8 个赛道，找出前 4 匹马最少需要比几次？</h3><p><img src="/2022/03/18/interview-intelligence/horse_racing.png"></p>
<p>最少10次选出前四，最多11次选出前四。 A2、A3、A4、B2、B3、C1、C2、D1八匹马跑一次，即：在剩下需要排名的马中，除了B1外，其它8匹马跑一次（1次）。 </p>
<p>在这次比赛中，如果B2或者C1排名第一或者第二，那从该次比赛中取出前两个，和A1,B1，一起作为前4名。否则，将A2,A3,A4,B1再比赛一次（1次），取前三名和A1一起作为前4名。 </p>
<h3 id="有2个8斤水桶-都装满水-还有一个3斤空水桶-如何将这16斤水平均分给4个人？（分配后不能再倒回）"><a href="#有2个8斤水桶-都装满水-还有一个3斤空水桶-如何将这16斤水平均分给4个人？（分配后不能再倒回）" class="headerlink" title="有2个8斤水桶,都装满水,还有一个3斤空水桶,如何将这16斤水平均分给4个人？（分配后不能再倒回）"></a>有2个8斤水桶,都装满水,还有一个3斤空水桶,如何将这16斤水平均分给4个人？（分配后不能再倒回）</h3><p>略</p>
<h3 id="有16种溶液，其中有且只有一种是有毒的，这种有毒的溶液与另一种试剂A混合会变色，而其他无毒溶液与A混合不会变色。已知一次实验需要1小时，由于一次混合反应需要使用1个试管，问最少使用多少个试管可以在1小时内识别出有毒溶液？"><a href="#有16种溶液，其中有且只有一种是有毒的，这种有毒的溶液与另一种试剂A混合会变色，而其他无毒溶液与A混合不会变色。已知一次实验需要1小时，由于一次混合反应需要使用1个试管，问最少使用多少个试管可以在1小时内识别出有毒溶液？" class="headerlink" title="有16种溶液，其中有且只有一种是有毒的，这种有毒的溶液与另一种试剂A混合会变色，而其他无毒溶液与A混合不会变色。已知一次实验需要1小时，由于一次混合反应需要使用1个试管，问最少使用多少个试管可以在1小时内识别出有毒溶液？"></a>有16种溶液，其中有且只有一种是有毒的，这种有毒的溶液与另一种试剂A混合会变色，而其他无毒溶液与A混合不会变色。已知一次实验需要1小时，由于一次混合反应需要使用1个试管，问最少使用多少个试管可以在1小时内识别出有毒溶液？</h3><p>然后，取4个试管，第一个试管加入编号二进制形式中第一位（指最低位）是1的溶液，第二个试管加入编号第二位是1的溶液，其他2个试管分别加入编号第3,4位为1 的溶液。然后再将试剂A加入4个试管中，看那些试管发生了反应，就可以知道有毒溶液的编号了。</p>
<p>例如：第1、2、4号试管内发生了反应，则我们知道是第7号溶液是有毒的。原因是7的二进制编码是1011，因此7号溶液是唯一加入了1、2、4号试管，而没有加入3号试管的溶液。</p>
]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Intelligence</tag>
      </tags>
  </entry>
  <entry>
    <title>interview-network</title>
    <url>/2022/03/19/interview-network/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？"><a href="#简述-TCP-三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？" class="headerlink" title="简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？"></a>简述 TCP 三次握手以及四次挥手的流程。为什么需要三次握手以及四次挥手？</h3><ul>
<li><p>为什么需要三次握手：</p>
<p>  <img src="/2022/03/19/interview-network/tcp3.png" alt="image"></p>
<p>  客户端和服务端通信前要进行连接，“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。</p>
</li>
<li><p>四次挥手的原因</p>
<p>  <img src="/2022/03/19/interview-network/tcp4.png" alt="image"></p>
<p>  客户端发送了FIN 连接释放报文之后，服务器收到了这个报文，就进入了CLOSE—WAIT状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送FIN连接释放报文。</p>
</li>
<li><p>TIME_WAIT的原因</p>
<p>  客户端接收到服务器端的FIN报文后进入此状态，此时并不是直接进入CLOSED状态，还需要等待一个时间计时器设置的时间2MSL。这么做有两个理由：</p>
<p>  确保最后一个确认报文能够到达。如果B没收到A发送来的确认报文，那么就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况的发生。</p>
<p>  等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
</li>
</ul>
<h3 id="TCP-挥手时出现大量-CLOSE-WAIT-或-TIME-WAIT-怎么解决？"><a href="#TCP-挥手时出现大量-CLOSE-WAIT-或-TIME-WAIT-怎么解决？" class="headerlink" title="TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？"></a>TCP 挥手时出现大量 CLOSE_WAIT 或 TIME_WAIT 怎么解决？</h3><p>略</p>
<h3 id="Syn-flood攻击及其防范"><a href="#Syn-flood攻击及其防范" class="headerlink" title="Syn flood攻击及其防范"></a>Syn flood攻击及其防范</h3><p>syn flood属于Dos攻击的一种。如果恶意地向某个服务器端口发送大量的SYN包，则可以使服务器打开大量的半开连接，分配TCB（Transmission Control Block）, 从而消耗大量的服务器资源，同时也使得正常的连接请求无法被响应。当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的Syn报文，一旦接收到Client发来的Syn报文，就需要为该请求分配一个TCB，通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYN ACK命令，立即转为SYN-RECEIVED即半开连接状态。系统会为此耗尽资源。</p>
<p>常见的防攻击方法有：</p>
<p>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉，因此这种方法属于入门级的SYN Flood方法。</p>
<h3 id="TCP-中常见的拥塞控制算法有哪些？"><a href="#TCP-中常见的拥塞控制算法有哪些？" class="headerlink" title="TCP 中常见的拥塞控制算法有哪些？"></a>TCP 中常见的拥塞控制算法有哪些？</h3><p>TCP主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。</p>
<p><img src="/2022/03/19/interview-network/congestion_control.png" alt="image"></p>
<p>快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段 ，而不必继续等待设置的重传计时器到期。</p>
<p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p>
<ol>
<li><p>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意，接下去不执行慢开始算法。</p>
</li>
<li><p>由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重的拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认），因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>
</li>
</ol>
<h3 id="DNS解析过程，以及DNS劫持"><a href="#DNS解析过程，以及DNS劫持" class="headerlink" title="DNS解析过程，以及DNS劫持"></a>DNS解析过程，以及DNS劫持</h3><p><img src="/2022/03/19/interview-network/DNS.png" alt="image"></p>
<p>DNS劫持（DNS Hijacking）：又被称为域名劫持，DNS重定向（DNS direaction）,是一种DNS攻击方式。DNS查询没有得到正确的解析，以致引导user访问到恶意的网站，从而窃取用户隐私，或者进行某些恶意的操作。</p>
<p>DNS劫持现象：你入一个google.com网址，出来的是百度的页面</p>
<p>HTTP劫持现象：访问着github的页面，右下角出现了一个格格不入的广告弹窗</p>
<ol>
<li><p>本机DNS劫持</p>
<p> 攻击者通过某些手段使用户的计算机感染上木马病毒，或者恶意软件之后，恶意修改本地DNS配置，比如修改本地hosts文件，缓存等</p>
</li>
<li><p>路由DNS劫持</p>
<p> 很多用户默认路由器的默认密码，攻击者可以侵入到路由管理员账号中，修改路由器的默认配置。（路由器通常会提供 DNS 代理服务，接管整个网络的域名查询。）</p>
</li>
<li><p>攻击DNS服务器</p>
<p> 直接攻击DNS服务器，例如对DNS服务器进行DDOS攻击，可以是DNS服务器宕机，出现异常请求，还可以利用某些手段感染dns服务器的缓存，使给用户返回来的是恶意的ip地址</p>
</li>
</ol>
<h3 id="TCP如何保证可靠传输？"><a href="#TCP如何保证可靠传输？" class="headerlink" title="TCP如何保证可靠传输？"></a>TCP如何保证可靠传输？</h3><ul>
<li><p>确认应答和序列号</p>
<p>  TCP传输时将每个字节的数据都进行了编号，这就是序列号。tcp按序号发送报文，接收端收到报文后，会给发送端一个ACK确认报文，用来表示已经成功接收到报文，报文中还带有ack，表示下一次发送端应该从哪里开始发送报文。</p>
</li>
<li><p>校验和</p>
<p>  这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段</p>
</li>
<li><p>超时重传</p>
<p>  如果发送端发送的数据没有收到ACK确认，可能是：（1）发送给接收端的报文丢失了（2）接收端发送的ACK确认报文丢失了。不管是哪种原因，超过一定时间后，没有收到ACK确认，TCP启动超时重传机制，发送端重新发数据，如果接收端已经有了该数据，只是由于ACK确认丢失导致超时重传，会将刚刚发送过来的数据包丢弃。</p>
</li>
<li><p>流量控制</p>
<p>  发送端如果数据发送过快，导致接收端的缓冲区很快就满了，如果持续下去，数据溢出缓冲区，就会出现数据丢失。这时需要在发送端和接收端有一个窗口，窗口的作用为：在发送缓冲区，只有在窗口里面的数据，才能被发送，在接收缓冲区，只有在窗口里的数据才能被接收，接收端收到数据之后，会回复ack，发送端会根据ack的值来判断接收能力，从而动态调整窗口大小，实现流量控制。</p>
</li>
<li><p>拥塞控制</p>
<p>  如果网络出现拥塞，TCP会根据不同情况，采用不同的算法：慢开始，拥塞避免，快重传，快恢复来对窗口大小cwnd和慢开始门限值ssthresh进行调整，从而降低网络拥塞的可能性。</p>
</li>
</ul>
<h3 id="什么是-TCP-粘包和拆包？"><a href="#什么是-TCP-粘包和拆包？" class="headerlink" title="什么是 TCP 粘包和拆包？"></a>什么是 TCP 粘包和拆包？</h3><p>  在socket通讯过程中，如果通讯的一端一次性连续发送多条数据包，tcp协议会将多个数据包打包成一个tcp报文发送出去，这就是所谓的粘包。而如果通讯的一端发送的数据包超过一次tcp报文所能传输的最大值时，就会将一个数据包拆成多个最大tcp长度的tcp报文分开传输，这就叫做拆包。</p>
<p>  <img src="/2022/03/19/interview-network/TCP_stick.png" alt="image"></p>
<p>  因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p>
<p>  如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p>
<p>  如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p>
<h3 id="从系统层面上，UDP如何保证尽量可靠？"><a href="#从系统层面上，UDP如何保证尽量可靠？" class="headerlink" title="从系统层面上，UDP如何保证尽量可靠？"></a>从系统层面上，UDP如何保证尽量可靠？</h3><p>  传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。</p>
<ul>
<li>添加seq&#x2F;ack机制，确保数据发送到对端</li>
<li>添加发送和接收缓冲区，主要是用户超时重传。</li>
<li>添加超时重传机制。</li>
</ul>
<h3 id="什么是-ARP-协议？简述其使用场景？什么是RARP协议？"><a href="#什么是-ARP-协议？简述其使用场景？什么是RARP协议？" class="headerlink" title="什么是 ARP 协议？简述其使用场景？什么是RARP协议？"></a>什么是 ARP 协议？简述其使用场景？什么是RARP协议？</h3><p>  ARP实现由 IP 地址得到 MAC 地址。如果主机 A 知道主机 B 的 IP 地址，但是ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送ARP 请求分组，主机 B 收到该请求后会发送ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机B 的IP 地址到MAC 地址的映射。</p>
<p>  ARP属于网络层协议</p>
<p>  RARP（Reverse Address Resolution Protocol）是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。对于使用嵌入式设备时，会遇到没有任何输入接口或无法通过 DHCP 动态获取 IP 地址的情况。在类似情况下，就可以使用 RARP。例如，打印机服务器等小型嵌入式设备接入到网络时会用到。</p>
<p>  为此，需要架设一台 RARP 服务器，从而在这个服务器上注册设备的 MAC 地址及其 IP 地址。</p>
<h3 id="简述在四层和七层网络协议中负载均衡的原理"><a href="#简述在四层和七层网络协议中负载均衡的原理" class="headerlink" title="简述在四层和七层网络协议中负载均衡的原理"></a>简述在四层和七层网络协议中负载均衡的原理</h3><p>  所谓四层就是基于IP+端口的负载均衡；七层就是基于URL等应用层信息的负载均衡。</p>
<p>  <img src="/2022/03/19/interview-network/network_protocol.png" alt="image"></p>
<ul>
<li><p>四层负载均衡：</p>
<p>  以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。</p>
</li>
<li><p>七层负载均衡：</p>
<p>  以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。</p>
</li>
</ul>
<h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><h3 id="HTTP-中-GET-和-POST-区别？"><a href="#HTTP-中-GET-和-POST-区别？" class="headerlink" title="HTTP 中 GET 和 POST 区别？"></a>HTTP 中 GET 和 POST 区别？</h3><ul>
<li>Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据。</li>
<li>Get 将表单中数据的按照 variable&#x3D;value 的形式，添加到 action 所指向的 URL 后面，并且两者使用“?”连接，而各个变量之间使用“&amp;”连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。</li>
<li>Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post 的所有操作对用户来说都是不可见的。</li>
<li>Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，所以在上传文件只能使用 Post。</li>
</ul>
<h3 id="Cookie-和-Session-的关系和区别是什么？"><a href="#Cookie-和-Session-的关系和区别是什么？" class="headerlink" title="Cookie 和 Session 的关系和区别是什么？"></a>Cookie 和 Session 的关系和区别是什么？</h3><p>Cookie保存在客户端，Session保存在服务端，二者都是用来保存用户状态的。</p>
<h3 id="简述-HTTP-1-0，1-1，2-0-的主要区别-？"><a href="#简述-HTTP-1-0，1-1，2-0-的主要区别-？" class="headerlink" title="简述 HTTP 1.0，1.1，2.0 的主要区别 ？"></a>简述 HTTP 1.0，1.1，2.0 的主要区别 ？</h3><ul>
<li><p>HTTP 1.0，1.1 的主要区别</p>
<ul>
<li><p>缓存处理</p>
<p>  HTTP1.0中主要使用header里的If-Modified-Since,Expires来作为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略如Entity tag，If-Unmodified-Since等。</p>
</li>
<li><p>带宽优化及网络连接的使用</p>
<p>  HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content）</p>
</li>
<li><p>长连接</p>
<p>  HTTP 1.1支持长连接（PersistentConnection）和请求流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
<p>  <img src="/2022/03/19/interview-network/PersistentConnection.png" alt="image"></p>
<p>  <img src="/2022/03/19/interview-network/pipeline.png" alt="image"></p>
</li>
</ul>
</li>
<li><p>HTTP 1.x，2.0 的主要区别</p>
<ul>
<li><p>新的二进制格式</p>
<p>  HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。</p>
</li>
<li><p>多路复用</p>
<p>  多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。同一 Tcp 中可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
<p>  <img src="/2022/03/19/interview-network/multx.png" alt="image"></p>
</li>
<li><p>header压缩</p>
<p>  HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
</li>
<li><p>服务端推送（server push）</p>
<p>  例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了</p>
</li>
</ul>
</li>
</ul>
<h3 id="https的过程是什么样？"><a href="#https的过程是什么样？" class="headerlink" title="https的过程是什么样？"></a>https的过程是什么样？</h3><ul>
<li><p>为什么需要https？</p>
<p>  传统的http协议可能有以下的问题：</p>
<ul>
<li>通信使用明文（不加密），内容可能被窃听</li>
<li>无法证明报文的完整性，所以可能遭篡改</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
</ul>
<p><img src="/2022/03/19/interview-network/unsafe.png" alt="image"></p>
</li>
<li><p>https的工作流程</p>
<p><img src="/2022/03/19/interview-network/safe.png" alt="image"></p>
</li>
<li><p>https的缺点</p>
<ul>
<li>需要权威CA颁发的SSL证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。</li>
<li>HTTPS普遍认为性能消耗要大于HTTP，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。</li>
</ul>
</li>
<li><p>http协议和https协议的区别</p>
<ul>
<li>https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl&#x2F;tls加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>HTTPS协议比http有以下优势：数据隐私性、数据完整性、身份认证。</li>
</ul>
</li>
</ul>
<h3 id="什么是跨域，什么情况下会发生跨域请求？"><a href="#什么是跨域，什么情况下会发生跨域请求？" class="headerlink" title="什么是跨域，什么情况下会发生跨域请求？"></a>什么是跨域，什么情况下会发生跨域请求？</h3><p>跨域”指的是不同源之间的资源访问。只要请求的 url 有以下不同，都属于“跨域”：</p>
<ul>
<li>协议: http, https, …</li>
<li>域名</li>
<li>端口</li>
</ul>
<p>这种“跨域”限制其实是 浏览器自带的安全机制，只有 在浏览器上 发生跨域请求操作时，才会自动禁止访问的错误。</p>
<p>虽然浏览器出于安全考虑做了“跨域”访问的限制，但开发时不可避免会有这样不同源资源访问的需求，因此 W3C 就制定了 CORS(Cross-origin resource sharing 跨域资源共享) 的机制。CORS 是一种解决“跨域”的方案。</p>
<p>然后就是后端服务器支持了，服务器需要在 Response Header 上添加 <code>Access-Control-xxx-yyy</code> 的字段，浏览器识别到了，才能放行该请求。比如，最常见的就是加 <code>Access-Control-Allow-Origin</code> 这个返回头，值设置为需要放行的域名。</p>
<h3 id="http常见的状态码"><a href="#http常见的状态码" class="headerlink" title="http常见的状态码"></a>http常见的状态码</h3><ul>
<li>100（continue）：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输。</li>
<li>200（OK）：成功。</li>
<li>206（Partial Content）：一般用来做断点续传，或者是视频文件等大文件的加载。</li>
<li>301（Move Permanently）：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名</li>
<li>302（Found）：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</li>
<li>304（Not Motified）：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分。</li>
<li>400（Bad Request）：参数有误，请求无法被服务器识别</li>
<li>403（Frobidden）：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回</li>
<li>404（Not Found）：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</li>
<li>503（Service Unavailable）：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503</li>
</ul>
<h3 id="简述-HTTP-报文头部的组成结构"><a href="#简述-HTTP-报文头部的组成结构" class="headerlink" title="简述 HTTP 报文头部的组成结构"></a>简述 HTTP 报文头部的组成结构</h3><p>如下所示：</p>
<p><img src="/httpReq.png" alt="image"></p>
<p><img src="/httpReqMsg.png" alt="image"></p>
<p><img src="/httpRespMsg.png" alt="image"></p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><h4 id="什么是IO多路复用？"><a href="#什么是IO多路复用？" class="headerlink" title="什么是IO多路复用？"></a>什么是IO多路复用？</h4><p>IO指的就是读入&#x2F;写出数据的过程，和等待读入&#x2F;写出数据的过程。一旦拿到数据后就变成了数据操作了，就不是IO了。</p>
<p>多路是指网络连接，复用指的是同一个线程。IO 多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪就会阻塞应用程序，交出CPU。</p>
<h4 id="为什么需要IO多路复用？"><a href="#为什么需要IO多路复用？" class="headerlink" title="为什么需要IO多路复用？"></a>为什么需要IO多路复用？</h4><p>在没有IO多路复用之前，对于网络请求，有BIO、NIO两种实现方式，但它们都有一些问题。</p>
<p>1、同步阻塞（BIO）</p>
<ul>
<li><p>服务端采用单线程时，当 accept 一个请求后，在 recv 或 send 调用阻塞时，将无法 accept 其他请求（必须等上一个请求处理 recv 或 send 完 ）（无法处理并发）</p>
<p><img src="/2022/03/19/interview-network/BIO.png" alt="image"></p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// accept阻塞</span></span><br><span class="line">    client_fd = accept(listen_fd);</span><br><span class="line">    fds.append(client_fd);</span><br><span class="line">    <span class="keyword">for</span> (fd in fds) &#123;</span><br><span class="line">            <span class="comment">// recv阻塞（会影响上面的accept）</span></span><br><span class="line">        <span class="keyword">if</span> (recv(fd)) &#123;</span><br><span class="line">                <span class="comment">// logic</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务端采用多线程时，当 accept 一个请求后，开启线程进行 recv，可以完成并发处理，但随着请求数增加需要增加系统线程，大量的线程占用很大的内存空间，并且线程切换会带来很大的开销。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// accept阻塞</span></span><br><span class="line">    client_fd = <span class="built_in">accept</span>(listen_fd)</span><br><span class="line">    <span class="comment">// 开启线程read数据（fd增多导致线程数增多）</span></span><br><span class="line">    <span class="keyword">new</span> Thread <span class="built_in">func</span>() &#123;</span><br><span class="line">        <span class="comment">// recv阻塞（多线程不影响上面的accept）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">recv</span>(fd)) &#123;</span><br><span class="line">            <span class="comment">// logic</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>2、同步非阻塞（NIO）</p>
<ul>
<li><p>服务器端当 accept 一个请求后，加入 fds 集合，每次轮询一遍 fds 集合 recv (非阻塞)数据，没有数据则立即返回错误，每次轮询所有 fd （包括没有发生读写实际的 fd）会很浪费 CPU。</p>
<p><img src="/2022/03/19/interview-network/NIO.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码描述</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// accept非阻塞（cpu一直忙轮询）</span></span><br><span class="line">    client_fd = accept(listen_fd)</span><br><span class="line">    <span class="keyword">if</span> (client_fd != null) &#123;</span><br><span class="line">        <span class="comment">// 有人连接</span></span><br><span class="line">        fds.append(client_fd)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无人连接</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (fd in fds) &#123;</span><br><span class="line">        <span class="comment">// recv非阻塞</span></span><br><span class="line">        setNonblocking(client_fd)</span><br><span class="line">        <span class="comment">// recv 为非阻塞命令</span></span><br><span class="line">        <span class="keyword">if</span> (len = recv(fd) &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 有读写数据</span></span><br><span class="line">            <span class="comment">// logic</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无读写数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="IO多路复用如何工作？"><a href="#IO多路复用如何工作？" class="headerlink" title="IO多路复用如何工作？"></a>IO多路复用如何工作？</h4><ul>
<li><p>select 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> max_fd, </span></span><br><span class="line"><span class="params">    fd_set *readset, </span></span><br><span class="line"><span class="params">    fd_set *writeset, </span></span><br><span class="line"><span class="params">    fd_set *exceptset, </span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> timeval *timeout</span></span><br><span class="line"><span class="params">)</span>    </span><br></pre></td></tr></table></figure>

<p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。</p>
<p>缺点：</p>
<ol>
<li><p>单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 ;</p>
</li>
<li><p>每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；</p>
</li>
<li><p>对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发）</p>
</li>
</ol>
<p>  例子：<a href="https://kongkongk.github.io/2020/07/02/select-function-application-example/">https://kongkongk.github.io/2020/07/02/select-function-application-example/</a></p>
</li>
<li><p>poll 函数</p>
  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">/* requested events */</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>  poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.<br>  例子：<a href="https://www.cnblogs.com/pang1567/p/4122729.html">https://www.cnblogs.com/pang1567/p/4122729.html</a></p>
</li>
<li><p>epoll 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建用于epoll工作的FD</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对事件操作：增、删等</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待事件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>; </span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/19/interview-network/epoll.png" alt="image"></p>
<p>  epoll 通过两个方面，很好解决了 select&#x2F;poll 的问题。</p>
<p>  第一点，epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删查一般时间复杂度是 O(logn)，通过对这棵黑红树进行操作，这样就不需要像 select&#x2F;poll 每次操作时都传入整个 socket 集合，只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。</p>
<p>  第二点， epoll 使用事件驱动的机制，内核里维护了一个链表来记录就绪事件，当某个 socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select&#x2F;poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</p>
<p>  epoll 支持两种事件触发模式，分别是边缘触发（edge-triggered，ET）和水平触发（level-triggered，LT）：</p>
<ul>
<li>使用边缘触发模式时，当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；</li>
<li>使用水平触发模式时，当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束，目的是告诉我们有数据需要读取；</li>
<li>如何理解名字：边缘（电平发生变化：高电平到低电平,或者低电平到高电平），水平（只有高电平(1)或低电平(0)时才触发通知）</li>
</ul>
<p> 实例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在这里进行一些初始化的操作，</span></span><br><span class="line"><span class="comment">* 比如初始化数据和socket等。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内核中创建ep对象</span></span><br><span class="line">    epfd=<span class="built_in">epoll_create</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 需要监听的socket放到ep中</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 阻塞获取</span></span><br><span class="line">        nfds = <span class="built_in">epoll_wait</span>(epfd,events,<span class="number">20</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd) &#123;</span><br><span class="line">                <span class="comment">// 这里处理accept事件</span></span><br><span class="line">                connfd = <span class="built_in">accept</span>(listenfd);</span><br><span class="line">                <span class="comment">// 接收新连接写到内核对象中</span></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events&amp;EPOLLIN) &#123;</span><br><span class="line">                <span class="comment">// 这里处理read事件</span></span><br><span class="line">                <span class="built_in">read</span>(sockfd, BUF, MAXLINE);</span><br><span class="line">                <span class="comment">//读完后准备写</span></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) &#123;</span><br><span class="line">                <span class="comment">// 这里处理write事件</span></span><br><span class="line">                <span class="built_in">write</span>(sockfd, BUF, n);</span><br><span class="line">                <span class="comment">//写完后准备读</span></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="select-、-poll、epoll的区别"><a href="#select-、-poll、epoll的区别" class="headerlink" title="select 、 poll、epoll的区别"></a>select 、 poll、epoll的区别</h4><p><img src="/2022/03/19/interview-network/IO.png" alt="image"></p>
<p>使用场景：</p>
<ul>
<li>select 的 timeout 参数精度为微秒，而 poll 和 epoll 为毫秒，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。 select 可移植性更好，几乎被所有主流平台所支持。</li>
<li>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</li>
<li>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</li>
</ul>
<h3 id="Redis为什么使用IO多路复用技术？"><a href="#Redis为什么使用IO多路复用技术？" class="headerlink" title="Redis为什么使用IO多路复用技术？"></a>Redis为什么使用IO多路复用技术？</h3><p>Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I&#x2F;O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I&#x2F;O 阻塞导致整个进程无法对其它客户提供服务，而 I&#x2F;O 多路复用 就是为了解决这个问题而出现的。</p>
]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>interview_security</title>
    <url>/2022/03/18/interview-security/</url>
    <content><![CDATA[<h3 id="AES和DES的区别？秘钥长度"><a href="#AES和DES的区别？秘钥长度" class="headerlink" title="AES和DES的区别？秘钥长度"></a>AES和DES的区别？秘钥长度</h3><ul>
<li><p>DES </p>
<p>DES是对称性加密里常见的一种，是一种使用秘钥加密的块算法。秘钥长度是64位（bit）， 超过位数秘钥被忽略。对称性加密一般会按照固定长度，把待加密字符串分成块。不足一整块或者刚好最后有特殊填充字符。 </p>
<p><img src="/2022/03/18/interview-security/des.png"></p>
<p>特点：分组比较短、秘钥太短、密码生命周期短、运算速度较慢。 </p>
</li>
<li><p>AES </p>
<p>AES的区块长度固定为128 比特，密钥长度则可以是128，192或256比特； </p>
<p>特点：运算速度快，安全性高，资源消耗少 </p>
</li>
<li><p>总结：AES是高级算法，它比DES更快，更安全。</p>
</li>
</ul>
<h3 id="非对称加密和对称加密的区别？"><a href="#非对称加密和对称加密的区别？" class="headerlink" title="非对称加密和对称加密的区别？"></a>非对称加密和对称加密的区别？</h3><ul>
<li><p>对称加密</p>
<p>  指的就是加、解密使用的同是一串密钥，所以被称做对称加密。对称加密只有一个密钥作为私钥。常见的对称加密算法：DES，AES等。 </p>
</li>
<li><p>非对称加密</p>
<p>  指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。 </p>
</li>
<li><p>总结</p>
<p>  非对称加密更安全，但是效率比较慢，对称加密效率高，但是不安全。一般来说可以混合使用：将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通，例如https。</p>
</li>
</ul>
<h3 id="RSA的原理？"><a href="#RSA的原理？" class="headerlink" title="RSA的原理？"></a>RSA的原理？</h3><p><a href="https://cjting.me/2020/03/13/rsa/">https://cjting.me/2020/03/13/rsa/</a> </p>
<p>密钥越长，它就越难破解。一般来说，1024位的RSA密钥基本安全，2048位的密钥极其安全。 </p>
]]></content>
      <categories>
        <category>Interview Knowledge</category>
      </categories>
      <tags>
        <tag>Interview</tag>
        <tag>Information Security</tag>
      </tags>
  </entry>
</search>
